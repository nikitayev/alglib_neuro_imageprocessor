(**************************************************************************
ALGLIB 3.16.0 (source code generated 2019-12-19)
Copyright (c) Sergey Bochkanov (ALGLIB project).

>>> SOURCE LICENSE >>>
This software is a non-commercial edition of  ALGLIB  package,  which  is
licensed under ALGLIB Personal and Academic Use License Agreement (PAULA).

See paula-v1.0.pdf file in the archive  root  for  full  text  of  license
agreement.
>>> END OF LICENSE >>>

**************************************************************************)
unit XALGLIB;
{$IFDEF FPC}
{$MODE OBJFPC}
{$H+}
{$ELSE}
{$POINTERMATH ON}
{$ENDIF}
{$ALIGN 8}

interface

uses
    SysUtils, Classes;

const    
    AlglibSerial = 1;
    AlglibParallel = 2;
    
type
    TALGLIBInteger      = NativeInt;
    Complex = record
        X, Y: Double;
{$IFNDEF FPC}
        class operator Implicit(R: Double):Complex;
{$ENDIF}
    end;
    PComplex = ^Complex;
    
    TIVector            = array of TALGLIBInteger;
    TVector             = array of Double;
    TBVector            = array of Boolean;
    TCVector            = array of Complex;

    TIMatrix            = array of array of TALGLIBInteger;
    TMatrix             = array of array of Double;
    TBMatrix            = array of array of Boolean;
    TCMatrix            = array of array of Complex;

    
    
    (********************************************************************
    Callback definitions for optimizers/fitters/solvers.
    
    Callbacks for unparameterized (general) functions:
    * Tndimensional_func        calculates f(arg), stores result to func
    * Tndimensional_grad        calculates func = f(arg), 
                                grad[i] = df(arg)/d(arg[i])
    * Tndimensional_hess        calculates func = f(arg),
                                grad[i] = df(arg)/d(arg[i]),
                                hess[i,j] = d2f(arg)/(d(arg[i])*d(arg[j]))
    
    Callbacks for systems of functions:
    * Tndimensional_fvec        calculates vector function f(arg),
                                stores result to fi
    * Tndimensional_jac         calculates f[i] = fi(arg)
                                jac[i,j] = df[i](arg)/d(arg[j])
                                
    Callbacks for  parameterized  functions,  i.e.  for  functions  which 
    depend on two vectors: P and Q.  Gradient  and Hessian are calculated 
    with respect to P only.
    * Tndimensional_pfunc       calculates f(p,q),
                                stores result to func
    * Tndimensional_pgrad       calculates func = f(p,q),
                                grad[i] = df(p,q)/d(p[i])
    * Tndimensional_phess       calculates func = f(p,q),
                                grad[i] = df(p,q)/d(p[i]),
                                hess[i,j] = d2f(p,q)/(d(p[i])*d(p[j]))

    Callbacks for progress reports:
    * Tndimensional_rep         reports current position of optimization algo    
    
    Callbacks for ODE solvers:
    * Tndimensional_ode_rp      calculates dy/dx for given y[] and x
    
    Callbacks for integrators:
    * Tintegrator1_func         calculates f(x) for given x
                                (additional parameters xminusa and bminusx
                                contain x-a and b-x)
    ********************************************************************)
    Tndimensional_func = procedure(const arg: TVector; var func: Double; obj: Pointer);
    Tndimensional_grad = procedure(const arg: TVector; var func: Double; grad: TVector; obj: Pointer);
    Tndimensional_hess = procedure(const arg: TVector; var func: Double; grad: TVector; hess: TMatrix; obj: Pointer);
    
    Tndimensional_fvec = procedure(const arg: TVector; fi: TVector; obj: Pointer);
    Tndimensional_jac  = procedure(const arg: TVector; fi: TVector; jac: TMatrix; obj: Pointer);
    
    Tndimensional_pfunc= procedure(const p: TVector; const q: TVector; var func: Double; obj: Pointer);
    Tndimensional_pgrad= procedure(const p: TVector; const q: TVector; var func: Double; grad: TVector; obj: Pointer);
    Tndimensional_phess= procedure(const p: TVector; const q: TVector; var func: Double; grad: TVector; hess: TMatrix; obj: Pointer);
    
    Tndimensional_rep  = procedure(const arg: TVector; func: Double; obj: Pointer);

    Tndimensional_ode_rp=procedure(const y: TVector; x: Double; dy: TVector; obj: Pointer);

    Tintegrator1_func  = procedure(x: Double; xminusa: Double; bminusx: Double; var f: Double; obj: Pointer);
    
    Tkdtreerequestbuffer = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tkdtreerequestbuffer;
        procedure   Deallocate();
    end;
    Tkdtree = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tkdtree;
        procedure   Deallocate();
    end;
    Thqrndstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Thqrndstate;
        procedure   Deallocate();
    end;
    Txdebugrecord1 = record
        i: TALGLIBInteger;
        c: Complex;
        a: TVector;
    end;
    Todesolverstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Todesolverstate;
        procedure   Deallocate();
    end;
    Todesolverreport = record
        nfev: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tsparsematrix = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tsparsematrix;
        procedure   Deallocate();
    end;
    Tsparsebuffers = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tsparsebuffers;
        procedure   Deallocate();
    end;
    Tmatinvreport = record
        r1: Double;
        rinf: Double;
    end;
    Toptguardreport = record
        nonc0suspected: Boolean;
        nonc0test0positive: Boolean;
        nonc0fidx: TALGLIBInteger;
        nonc0lipschitzc: Double;
        nonc1suspected: Boolean;
        nonc1test0positive: Boolean;
        nonc1test1positive: Boolean;
        nonc1fidx: TALGLIBInteger;
        nonc1lipschitzc: Double;
        badgradsuspected: Boolean;
        badgradfidx: TALGLIBInteger;
        badgradvidx: TALGLIBInteger;
        badgradxbase: TVector;
        badgraduser: TMatrix;
        badgradnum: TMatrix;
    end;
    Toptguardnonc0report = record
        positive: Boolean;
        fidx: TALGLIBInteger;
        x0: TVector;
        d: TVector;
        n: TALGLIBInteger;
        stp: TVector;
        f: TVector;
        cnt: TALGLIBInteger;
        stpidxa: TALGLIBInteger;
        stpidxb: TALGLIBInteger;
    end;
    Toptguardnonc1test0report = record
        positive: Boolean;
        fidx: TALGLIBInteger;
        x0: TVector;
        d: TVector;
        n: TALGLIBInteger;
        stp: TVector;
        f: TVector;
        cnt: TALGLIBInteger;
        stpidxa: TALGLIBInteger;
        stpidxb: TALGLIBInteger;
    end;
    Toptguardnonc1test1report = record
        positive: Boolean;
        fidx: TALGLIBInteger;
        vidx: TALGLIBInteger;
        x0: TVector;
        d: TVector;
        n: TALGLIBInteger;
        stp: TVector;
        g: TVector;
        cnt: TALGLIBInteger;
        stpidxa: TALGLIBInteger;
        stpidxb: TALGLIBInteger;
    end;
    Tdensesolverreport = record
        r1: Double;
        rinf: Double;
    end;
    Tdensesolverlsreport = record
        r2: Double;
        cx: TMatrix;
        n: TALGLIBInteger;
        k: TALGLIBInteger;
    end;
    Tminlbfgsstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminlbfgsstate;
        procedure   Deallocate();
    end;
    Tminlbfgsreport = record
        iterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tnormestimatorstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tnormestimatorstate;
        procedure   Deallocate();
    end;
    Tlinlsqrstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tlinlsqrstate;
        procedure   Deallocate();
    end;
    Tlinlsqrreport = record
        iterationscount: TALGLIBInteger;
        nmv: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tminbleicstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminbleicstate;
        procedure   Deallocate();
    end;
    Tminbleicreport = record
        iterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        varidx: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
        debugeqerr: Double;
        debugfs: Double;
        debugff: Double;
        debugdx: Double;
        debugfeasqpits: TALGLIBInteger;
        debugfeasgpaits: TALGLIBInteger;
        inneriterationscount: TALGLIBInteger;
        outeriterationscount: TALGLIBInteger;
    end;
    Tminqpstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminqpstate;
        procedure   Deallocate();
    end;
    Tminqpreport = record
        inneriterationscount: TALGLIBInteger;
        outeriterationscount: TALGLIBInteger;
        nmv: TALGLIBInteger;
        ncholesky: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
        lagbc: TVector;
        laglc: TVector;
    end;
    Tminlpstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminlpstate;
        procedure   Deallocate();
    end;
    Tminlpreport = record
        f: Double;
        y: TVector;
        stats: TIVector;
        primalerror: Double;
        dualerror: Double;
        iterationscount: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tminnlcstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminnlcstate;
        procedure   Deallocate();
    end;
    Tminnlcreport = record
        iterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
        bcerr: Double;
        bcidx: TALGLIBInteger;
        lcerr: Double;
        lcidx: TALGLIBInteger;
        nlcerr: Double;
        nlcidx: TALGLIBInteger;
        dbgphase0its: TALGLIBInteger;
    end;
    Tminbcstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminbcstate;
        procedure   Deallocate();
    end;
    Tminbcreport = record
        iterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        varidx: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tminnsstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminnsstate;
        procedure   Deallocate();
    end;
    Tminnsreport = record
        iterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        cerr: Double;
        lcerr: Double;
        nlcerr: Double;
        terminationtype: TALGLIBInteger;
        varidx: TALGLIBInteger;
        funcidx: TALGLIBInteger;
    end;
    Tminasastate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminasastate;
        procedure   Deallocate();
    end;
    Tminasareport = record
        iterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
        activeconstraints: TALGLIBInteger;
    end;
    Tmincgstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tmincgstate;
        procedure   Deallocate();
    end;
    Tmincgreport = record
        iterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tminlmstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tminlmstate;
        procedure   Deallocate();
    end;
    Tminlmreport = record
        iterationscount: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
        nfunc: TALGLIBInteger;
        njac: TALGLIBInteger;
        ngrad: TALGLIBInteger;
        nhess: TALGLIBInteger;
        ncholesky: TALGLIBInteger;
    end;
    Teigsubspacestate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Teigsubspacestate;
        procedure   Deallocate();
    end;
    Teigsubspacereport = record
        iterationscount: TALGLIBInteger;
    end;
    Tmodelerrors = record
        relclserror: Double;
        avgce: Double;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
    end;
    Tmultilayerperceptron = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tmultilayerperceptron;
        procedure   Deallocate();
    end;
    Tssamodel = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tssamodel;
        procedure   Deallocate();
    end;
    Tlinearmodel = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tlinearmodel;
        procedure   Deallocate();
    end;
    Tlrreport = record
        c: TMatrix;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
        cvrmserror: Double;
        cvavgerror: Double;
        cvavgrelerror: Double;
        ncvdefects: TALGLIBInteger;
        cvdefects: TIVector;
    end;
    Tlogitmodel = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tlogitmodel;
        procedure   Deallocate();
    end;
    Tmnlreport = record
        ngrad: TALGLIBInteger;
        nhess: TALGLIBInteger;
    end;
    Tmcpdstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tmcpdstate;
        procedure   Deallocate();
    end;
    Tmcpdreport = record
        inneriterationscount: TALGLIBInteger;
        outeriterationscount: TALGLIBInteger;
        nfev: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tmlpensemble = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tmlpensemble;
        procedure   Deallocate();
    end;
    Tmlpreport = record
        relclserror: Double;
        avgce: Double;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
        ngrad: TALGLIBInteger;
        nhess: TALGLIBInteger;
        ncholesky: TALGLIBInteger;
    end;
    Tmlpcvreport = record
        relclserror: Double;
        avgce: Double;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
    end;
    Tmlptrainer = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tmlptrainer;
        procedure   Deallocate();
    end;
    Tclusterizerstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tclusterizerstate;
        procedure   Deallocate();
    end;
    Tahcreport = record
        terminationtype: TALGLIBInteger;
        npoints: TALGLIBInteger;
        p: TIVector;
        z: TIMatrix;
        pz: TIMatrix;
        pm: TIMatrix;
        mergedist: TVector;
    end;
    Tkmeansreport = record
        npoints: TALGLIBInteger;
        nfeatures: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
        iterationscount: TALGLIBInteger;
        energy: Double;
        k: TALGLIBInteger;
        c: TMatrix;
        cidx: TIVector;
    end;
    Tdecisionforestbuilder = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tdecisionforestbuilder;
        procedure   Deallocate();
    end;
    Tdecisionforestbuffer = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tdecisionforestbuffer;
        procedure   Deallocate();
    end;
    Tdecisionforest = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tdecisionforest;
        procedure   Deallocate();
    end;
    Tdfreport = record
        relclserror: Double;
        avgce: Double;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
        oobrelclserror: Double;
        oobavgce: Double;
        oobrmserror: Double;
        oobavgerror: Double;
        oobavgrelerror: Double;
        topvars: TIVector;
        varimportances: TVector;
    end;
    Tknnbuffer = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tknnbuffer;
        procedure   Deallocate();
    end;
    Tknnbuilder = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tknnbuilder;
        procedure   Deallocate();
    end;
    Tknnmodel = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tknnmodel;
        procedure   Deallocate();
    end;
    Tknnreport = record
        relclserror: Double;
        avgce: Double;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
    end;
    Tautogkreport = record
        terminationtype: TALGLIBInteger;
        nfev: TALGLIBInteger;
        nintervals: TALGLIBInteger;
    end;
    Tautogkstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tautogkstate;
        procedure   Deallocate();
    end;
    Tidwcalcbuffer = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tidwcalcbuffer;
        procedure   Deallocate();
    end;
    Tidwmodel = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tidwmodel;
        procedure   Deallocate();
    end;
    Tidwbuilder = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tidwbuilder;
        procedure   Deallocate();
    end;
    Tidwreport = record
        rmserror: Double;
        avgerror: Double;
        maxerror: Double;
        r2: Double;
    end;
    Tbarycentricinterpolant = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tbarycentricinterpolant;
        procedure   Deallocate();
    end;
    Tspline1dinterpolant = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tspline1dinterpolant;
        procedure   Deallocate();
    end;
    Tspline1dfitreport = record
        taskrcond: Double;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
        maxerror: Double;
    end;
    Tpspline2interpolant = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tpspline2interpolant;
        procedure   Deallocate();
    end;
    Tpspline3interpolant = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tpspline3interpolant;
        procedure   Deallocate();
    end;
    Tspline3dinterpolant = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tspline3dinterpolant;
        procedure   Deallocate();
    end;
    Tpolynomialfitreport = record
        taskrcond: Double;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
        maxerror: Double;
    end;
    Tbarycentricfitreport = record
        taskrcond: Double;
        dbest: TALGLIBInteger;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
        maxerror: Double;
    end;
    Tlsfitreport = record
        taskrcond: Double;
        iterationscount: TALGLIBInteger;
        varidx: TALGLIBInteger;
        rmserror: Double;
        avgerror: Double;
        avgrelerror: Double;
        maxerror: Double;
        wrmserror: Double;
        covpar: TMatrix;
        errpar: TVector;
        errcurve: TVector;
        noise: TVector;
        r2: Double;
    end;
    Tlsfitstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tlsfitstate;
        procedure   Deallocate();
    end;
    Tspline2dinterpolant = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tspline2dinterpolant;
        procedure   Deallocate();
    end;
    Tspline2dbuilder = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tspline2dbuilder;
        procedure   Deallocate();
    end;
    Tspline2dfitreport = record
        rmserror: Double;
        avgerror: Double;
        maxerror: Double;
        r2: Double;
    end;
    Trbfcalcbuffer = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Trbfcalcbuffer;
        procedure   Deallocate();
    end;
    Trbfmodel = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Trbfmodel;
        procedure   Deallocate();
    end;
    Trbfreport = record
        rmserror: Double;
        maxerror: Double;
        arows: TALGLIBInteger;
        acols: TALGLIBInteger;
        annz: TALGLIBInteger;
        iterationscount: TALGLIBInteger;
        nmv: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tpolynomialsolverreport = record
        maxerr: Double;
    end;
    Tnleqstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tnleqstate;
        procedure   Deallocate();
    end;
    Tnleqreport = record
        iterationscount: TALGLIBInteger;
        nfunc: TALGLIBInteger;
        njac: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
    end;
    Tsparsesolverreport = record
        terminationtype: TALGLIBInteger;
    end;
    Tlincgstate = class
    private
        ptr: Pointer;
    public
        constructor Create(x_obj: Pointer);
        destructor  Destroy();override;
        function    Clone():Tlincgstate;
        procedure   Deallocate();
    end;
    Tlincgreport = record
        iterationscount: TALGLIBInteger;
        nmv: TALGLIBInteger;
        terminationtype: TALGLIBInteger;
        r2: Double;
    end;


    procedure kdtreeserialize(const obj: Tkdtree; out s_out: AnsiString);overload;
    procedure kdtreeunserialize(const s_in: AnsiString; out obj: Tkdtree);overload;
    procedure kdtreeserialize(const obj: Tkdtree; stream: TStream);overload;
    procedure kdtreeunserialize(stream: TStream; out obj: Tkdtree);overload;
    procedure kdtreebuild( xy: TMatrix;  n: TALGLIBInteger;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
    procedure kdtreebuild( xy: TMatrix;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
    procedure kdtreebuildtagged( xy: TMatrix;  tags: TIVector;  n: TALGLIBInteger;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
    procedure kdtreebuildtagged( xy: TMatrix;  tags: TIVector;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
    procedure kdtreecreaterequestbuffer( kdt: Tkdtree; out  buf: Tkdtreerequestbuffer; const _xparams: UInt64 = 0);
    function kdtreequeryknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequeryknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequeryrnn( kdt: Tkdtree;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequeryrnn( kdt: Tkdtree;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequeryrnnu( kdt: Tkdtree;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequeryrnnu( kdt: Tkdtree;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryrnn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryrnn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryrnnu( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryrnnu( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequeryaknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequeryaknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryaknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreetsqueryaknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
    function kdtreequerybox( kdt: Tkdtree;  boxmin: TVector;  boxmax: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
    function kdtreetsquerybox( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  boxmin: TVector;  boxmax: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure kdtreequeryresultsx( kdt: Tkdtree; var  x: TMatrix; const _xparams: UInt64 = 0);
    procedure kdtreequeryresultsxy( kdt: Tkdtree; var  xy: TMatrix; const _xparams: UInt64 = 0);
    procedure kdtreequeryresultstags( kdt: Tkdtree; var  tags: TIVector; const _xparams: UInt64 = 0);
    procedure kdtreequeryresultsdistances( kdt: Tkdtree; var  r: TVector; const _xparams: UInt64 = 0);
    procedure kdtreetsqueryresultsx( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  x: TMatrix; const _xparams: UInt64 = 0);
    procedure kdtreetsqueryresultsxy( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  xy: TMatrix; const _xparams: UInt64 = 0);
    procedure kdtreetsqueryresultstags( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  tags: TIVector; const _xparams: UInt64 = 0);
    procedure kdtreetsqueryresultsdistances( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  r: TVector; const _xparams: UInt64 = 0);
    procedure kdtreequeryresultsxi( kdt: Tkdtree; out  x: TMatrix; const _xparams: UInt64 = 0);
    procedure kdtreequeryresultsxyi( kdt: Tkdtree; out  xy: TMatrix; const _xparams: UInt64 = 0);
    procedure kdtreequeryresultstagsi( kdt: Tkdtree; out  tags: TIVector; const _xparams: UInt64 = 0);
    procedure kdtreequeryresultsdistancesi( kdt: Tkdtree; out  r: TVector; const _xparams: UInt64 = 0);
    procedure hqrndrandomize(out  state: Thqrndstate; const _xparams: UInt64 = 0);
    procedure hqrndseed( s1: TALGLIBInteger;  s2: TALGLIBInteger; out  state: Thqrndstate; const _xparams: UInt64 = 0);
    function hqrnduniformr( state: Thqrndstate; const _xparams: UInt64 = 0):Double;
    function hqrnduniformi( state: Thqrndstate;  n: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
    function hqrndnormal( state: Thqrndstate; const _xparams: UInt64 = 0):Double;
    procedure hqrndunit2( state: Thqrndstate; out  x: Double; out  y: Double; const _xparams: UInt64 = 0);
    procedure hqrndnormal2( state: Thqrndstate; out  x1: Double; out  x2: Double; const _xparams: UInt64 = 0);
    function hqrndexponential( state: Thqrndstate;  lambdav: Double; const _xparams: UInt64 = 0):Double;
    function hqrnddiscrete( state: Thqrndstate;  x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function hqrndcontinuous( state: Thqrndstate;  x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function Clone(const Src: Txdebugrecord1):Txdebugrecord1;overload;
    procedure xdebuginitrecord1(out  rec1: Txdebugrecord1; const _xparams: UInt64 = 0);
    function xdebugb1count( a: TBVector; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure xdebugb1not(var  a: TBVector; const _xparams: UInt64 = 0);
    procedure xdebugb1appendcopy(var  a: TBVector; const _xparams: UInt64 = 0);
    procedure xdebugb1outeven( n: TALGLIBInteger; out  a: TBVector; const _xparams: UInt64 = 0);
    function xdebugi1sum( a: TIVector; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure xdebugi1neg(var  a: TIVector; const _xparams: UInt64 = 0);
    procedure xdebugi1appendcopy(var  a: TIVector; const _xparams: UInt64 = 0);
    procedure xdebugi1outeven( n: TALGLIBInteger; out  a: TIVector; const _xparams: UInt64 = 0);
    function xdebugr1sum( a: TVector; const _xparams: UInt64 = 0):Double;
    procedure xdebugr1neg(var  a: TVector; const _xparams: UInt64 = 0);
    procedure xdebugr1appendcopy(var  a: TVector; const _xparams: UInt64 = 0);
    procedure xdebugr1outeven( n: TALGLIBInteger; out  a: TVector; const _xparams: UInt64 = 0);
    function xdebugc1sum( a: TCVector; const _xparams: UInt64 = 0):Complex;
    procedure xdebugc1neg(var  a: TCVector; const _xparams: UInt64 = 0);
    procedure xdebugc1appendcopy(var  a: TCVector; const _xparams: UInt64 = 0);
    procedure xdebugc1outeven( n: TALGLIBInteger; out  a: TCVector; const _xparams: UInt64 = 0);
    function xdebugb2count( a: TBMatrix; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure xdebugb2not(var  a: TBMatrix; const _xparams: UInt64 = 0);
    procedure xdebugb2transpose(var  a: TBMatrix; const _xparams: UInt64 = 0);
    procedure xdebugb2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TBMatrix; const _xparams: UInt64 = 0);
    function xdebugi2sum( a: TIMatrix; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure xdebugi2neg(var  a: TIMatrix; const _xparams: UInt64 = 0);
    procedure xdebugi2transpose(var  a: TIMatrix; const _xparams: UInt64 = 0);
    procedure xdebugi2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TIMatrix; const _xparams: UInt64 = 0);
    function xdebugr2sum( a: TMatrix; const _xparams: UInt64 = 0):Double;
    procedure xdebugr2neg(var  a: TMatrix; const _xparams: UInt64 = 0);
    procedure xdebugr2transpose(var  a: TMatrix; const _xparams: UInt64 = 0);
    procedure xdebugr2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TMatrix; const _xparams: UInt64 = 0);
    function xdebugc2sum( a: TCMatrix; const _xparams: UInt64 = 0):Complex;
    procedure xdebugc2neg(var  a: TCMatrix; const _xparams: UInt64 = 0);
    procedure xdebugc2transpose(var  a: TCMatrix; const _xparams: UInt64 = 0);
    procedure xdebugc2outsincos( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TCMatrix; const _xparams: UInt64 = 0);
    function xdebugmaskedbiasedproductsum( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  b: TMatrix;  c: TBMatrix; const _xparams: UInt64 = 0):Double;
    function Clone(const Src: Todesolverreport):Todesolverreport;overload;
    procedure odesolverrkck( y: TVector;  n: TALGLIBInteger;  x: TVector;  m: TALGLIBInteger;  eps: Double;  h: Double; out  state: Todesolverstate; const _xparams: UInt64 = 0);overload;
    procedure odesolverrkck( y: TVector;  x: TVector;  eps: Double;  h: Double; out  state: Todesolverstate; const _xparams: UInt64 = 0);overload;
    function odesolveriteration( state: Todesolverstate; const _xparams: UInt64 = 0):Boolean;
    procedure odesolversolve(state: Todesolverstate; diff: Tndimensional_ode_rp; obj: Pointer; _xparams: UInt64 = 0);
    procedure odesolverresults( state: Todesolverstate; out  m: TALGLIBInteger; out  xtbl: TVector; out  ytbl: TMatrix; out  rep: Todesolverreport; const _xparams: UInt64 = 0);
    procedure sparsecreate( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger; out  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
    procedure sparsecreate( m: TALGLIBInteger;  n: TALGLIBInteger; out  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
    procedure sparsecreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
    procedure sparsecreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
    procedure sparsecreatecrs( m: TALGLIBInteger;  n: TALGLIBInteger;  ner: TIVector; out  s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecreatecrsbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  ner: TIVector;  s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecreatesks( m: TALGLIBInteger;  n: TALGLIBInteger;  d: TIVector;  u: TIVector; out  s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecreatesksbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  d: TIVector;  u: TIVector;  s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecreatesksband( m: TALGLIBInteger;  n: TALGLIBInteger;  bw: TALGLIBInteger; out  s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecreatesksbandbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  bw: TALGLIBInteger;  s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopy( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopybuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparseswap( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparseadd( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; const _xparams: UInt64 = 0);
    procedure sparseset( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; const _xparams: UInt64 = 0);
    function sparseget( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function sparsegetdiagonal( s: Tsparsematrix;  i: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure sparsemv( s: Tsparsematrix;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure sparsemtv( s: Tsparsematrix;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure sparsegemv( s: Tsparsematrix;  alpha: Double;  ops: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure sparsemv2( s: Tsparsematrix;  x: TVector; var  y0: TVector; var  y1: TVector; const _xparams: UInt64 = 0);
    procedure sparsesmv( s: Tsparsematrix;  isupper: Boolean;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    function sparsevsmv( s: Tsparsematrix;  isupper: Boolean;  x: TVector; const _xparams: UInt64 = 0):Double;
    procedure sparsemm( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; const _xparams: UInt64 = 0);
    procedure sparsemtm( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; const _xparams: UInt64 = 0);
    procedure sparsemm2( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b0: TMatrix; var  b1: TMatrix; const _xparams: UInt64 = 0);
    procedure sparsesmm( s: Tsparsematrix;  isupper: Boolean;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; const _xparams: UInt64 = 0);
    procedure sparsetrmv( s: Tsparsematrix;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure sparsetrsv( s: Tsparsematrix;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector; const _xparams: UInt64 = 0);
    procedure sparseresizematrix( s: Tsparsematrix; const _xparams: UInt64 = 0);
    function sparseenumerate( s: Tsparsematrix; var  t0: TALGLIBInteger; var  t1: TALGLIBInteger; out  i: TALGLIBInteger; out  j: TALGLIBInteger; out  v: Double; const _xparams: UInt64 = 0):Boolean;
    function sparserewriteexisting( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; const _xparams: UInt64 = 0):Boolean;
    procedure sparsegetrow( s: Tsparsematrix;  i: TALGLIBInteger; var  irow: TVector; const _xparams: UInt64 = 0);
    procedure sparsegetcompressedrow( s: Tsparsematrix;  i: TALGLIBInteger; var  colidx: TIVector; var  vals: TVector; out  nzcnt: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure sparsetransposesks( s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsetransposecrs( s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytransposecrs( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytransposecrsbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparseconvertto( s0: Tsparsematrix;  fmt: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure sparsecopytobuf( s0: Tsparsematrix;  fmt: TALGLIBInteger;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparseconverttohash( s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytohash( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytohashbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparseconverttocrs( s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytocrs( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytocrsbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparseconverttosks( s: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytosks( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure sparsecopytosksbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
    function sparsegetmatrixtype( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
    function sparseishash( s: Tsparsematrix; const _xparams: UInt64 = 0):Boolean;
    function sparseiscrs( s: Tsparsematrix; const _xparams: UInt64 = 0):Boolean;
    function sparseissks( s: Tsparsematrix; const _xparams: UInt64 = 0):Boolean;
    procedure sparsefree(out  s: Tsparsematrix; const _xparams: UInt64 = 0);
    function sparsegetnrows( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
    function sparsegetncols( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
    function sparsegetuppercount( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
    function sparsegetlowercount( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure cmatrixtranspose( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixtranspose( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixenforcesymmetricity(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
    procedure cmatrixcopy( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rvectorcopy( n: TALGLIBInteger;  a: TVector;  ia: TALGLIBInteger; var  b: TVector;  ib: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixcopy( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixgencopy( m: TALGLIBInteger;  n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  beta: Double; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixger( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  alpha: Double;  u: TVector;  iu: TALGLIBInteger;  v: TVector;  iv: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixrank1( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  u: TCVector;  iu: TALGLIBInteger; var  v: TCVector;  iv: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixrank1( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  u: TVector;  iu: TALGLIBInteger; var  v: TVector;  iv: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixgemv( m: TALGLIBInteger;  n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixmv( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TCVector;  ix: TALGLIBInteger; var  y: TCVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixmv( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixsymv( n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
    function rmatrixsyvmv( n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  x: TVector;  ix: TALGLIBInteger; var  tmp: TVector; const _xparams: UInt64 = 0):Double;
    procedure rmatrixtrsv( n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector;  ix: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixrighttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TCMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixlefttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TCMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixrighttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixlefttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixherk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
    procedure rmatrixsyrk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
    procedure cmatrixgemm( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Complex;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger;  optypeb: TALGLIBInteger;  beta: Complex; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixgemm( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger;  optypeb: TALGLIBInteger;  beta: Double; var  c: TMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixsyrk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
    procedure rmatrixrndorthogonal( n: TALGLIBInteger; out  a: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixrndorthogonal( n: TALGLIBInteger; out  a: TCMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; const _xparams: UInt64 = 0);
    procedure smatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; const _xparams: UInt64 = 0);
    procedure spdmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; const _xparams: UInt64 = 0);
    procedure hmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; const _xparams: UInt64 = 0);
    procedure hpdmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixrndorthogonalfromtheright(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixrndorthogonalfromtheleft(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixrndorthogonalfromtheright(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixrndorthogonalfromtheleft(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure smatrixrndmultiply(var  a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure hmatrixrndmultiply(var  a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixlu(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  pivots: TIVector; const _xparams: UInt64 = 0);
    procedure cmatrixlu(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  pivots: TIVector; const _xparams: UInt64 = 0);
    function hpdmatrixcholesky(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Boolean;
    function spdmatrixcholesky(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Boolean;
    procedure spdmatrixcholeskyupdateadd1(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  u: TVector; const _xparams: UInt64 = 0);
    procedure spdmatrixcholeskyupdatefix(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  fix: TBVector; const _xparams: UInt64 = 0);
    procedure spdmatrixcholeskyupdateadd1buf(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  u: TVector; var  bufr: TVector; const _xparams: UInt64 = 0);
    procedure spdmatrixcholeskyupdatefixbuf(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  fix: TBVector; var  bufr: TVector; const _xparams: UInt64 = 0);
    function sparselu( a: Tsparsematrix;  pivottype: TALGLIBInteger; out  p: TIVector; out  q: TIVector; const _xparams: UInt64 = 0):Boolean;
    function sparsecholeskyskyline( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Boolean;
    function rmatrixrcond1( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function rmatrixrcondinf( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function spdmatrixrcond( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
    function rmatrixtrrcond1( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
    function rmatrixtrrcondinf( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
    function hpdmatrixrcond( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
    function cmatrixrcond1( a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function cmatrixrcondinf( a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function rmatrixlurcond1( lua: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function rmatrixlurcondinf( lua: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function spdmatrixcholeskyrcond( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
    function hpdmatrixcholeskyrcond( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
    function cmatrixlurcond1( lua: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function cmatrixlurcondinf( lua: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function cmatrixtrrcond1( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
    function cmatrixtrrcondinf( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
    function Clone(const Src: Tmatinvreport):Tmatinvreport;overload;
    procedure rmatrixluinverse(var  a: TMatrix;  pivots: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure rmatrixluinverse(var  a: TMatrix;  pivots: TIVector; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure rmatrixinverse(var  a: TMatrix;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure rmatrixinverse(var  a: TMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure cmatrixluinverse(var  a: TCMatrix;  pivots: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure cmatrixluinverse(var  a: TCMatrix;  pivots: TIVector; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure cmatrixinverse(var  a: TCMatrix;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure cmatrixinverse(var  a: TCMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure spdmatrixcholeskyinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure spdmatrixcholeskyinverse(var  a: TMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure spdmatrixinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure spdmatrixinverse(var  a: TMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure hpdmatrixcholeskyinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure hpdmatrixcholeskyinverse(var  a: TCMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure hpdmatrixinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure hpdmatrixinverse(var  a: TCMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure rmatrixtrinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure rmatrixtrinverse(var  a: TMatrix;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure cmatrixtrinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure cmatrixtrinverse(var  a: TCMatrix;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
    procedure rmatrixqr(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixlq(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TVector; const _xparams: UInt64 = 0);
    procedure cmatrixqr(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TCVector; const _xparams: UInt64 = 0);
    procedure cmatrixlq(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TCVector; const _xparams: UInt64 = 0);
    procedure rmatrixqrunpackq( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TVector;  qcolumns: TALGLIBInteger; out  q: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixqrunpackr( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  r: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixlqunpackq( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TVector;  qrows: TALGLIBInteger; out  q: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixlqunpackl( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  l: TMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixqrunpackq( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TCVector;  qcolumns: TALGLIBInteger; out  q: TCMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixqrunpackr( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  r: TCMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixlqunpackq( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TCVector;  qrows: TALGLIBInteger; out  q: TCMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixlqunpackl( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  l: TCMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixbd(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tauq: TVector; out  taup: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixbdunpackq( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tauq: TVector;  qcolumns: TALGLIBInteger; out  q: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixbdmultiplybyq( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tauq: TVector; var  z: TMatrix;  zrows: TALGLIBInteger;  zcolumns: TALGLIBInteger;  fromtheright: Boolean;  dotranspose: Boolean; const _xparams: UInt64 = 0);
    procedure rmatrixbdunpackpt( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  taup: TVector;  ptrows: TALGLIBInteger; out  pt: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixbdmultiplybyp( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  taup: TVector; var  z: TMatrix;  zrows: TALGLIBInteger;  zcolumns: TALGLIBInteger;  fromtheright: Boolean;  dotranspose: Boolean; const _xparams: UInt64 = 0);
    procedure rmatrixbdunpackdiagonals( b: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  isupper: Boolean; out  d: TVector; out  e: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixhessenberg(var  a: TMatrix;  n: TALGLIBInteger; out  tau: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixhessenbergunpackq( a: TMatrix;  n: TALGLIBInteger;  tau: TVector; out  q: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixhessenbergunpackh( a: TMatrix;  n: TALGLIBInteger; out  h: TMatrix; const _xparams: UInt64 = 0);
    procedure smatrixtd(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  tau: TVector; out  d: TVector; out  e: TVector; const _xparams: UInt64 = 0);
    procedure smatrixtdunpackq( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  tau: TVector; out  q: TMatrix; const _xparams: UInt64 = 0);
    procedure hmatrixtd(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  tau: TCVector; out  d: TVector; out  e: TVector; const _xparams: UInt64 = 0);
    procedure hmatrixtdunpackq( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  tau: TCVector; out  q: TCMatrix; const _xparams: UInt64 = 0);
    function Clone(const Src: Toptguardreport):Toptguardreport;overload;
    function Clone(const Src: Toptguardnonc0report):Toptguardnonc0report;overload;
    function Clone(const Src: Toptguardnonc1test0report):Toptguardnonc1test0report;overload;
    function Clone(const Src: Toptguardnonc1test1report):Toptguardnonc1test1report;overload;
    function rmatrixbdsvd(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  isupper: Boolean;  isfractionalaccuracyrequired: Boolean; var  u: TMatrix;  nru: TALGLIBInteger; var  c: TMatrix;  ncc: TALGLIBInteger; var  vt: TMatrix;  ncvt: TALGLIBInteger; const _xparams: UInt64 = 0):Boolean;
    function rmatrixsvd( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  uneeded: TALGLIBInteger;  vtneeded: TALGLIBInteger;  additionalmemory: TALGLIBInteger; out  w: TVector; out  u: TMatrix; out  vt: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function Clone(const Src: Tdensesolverreport):Tdensesolverreport;overload;
    function Clone(const Src: Tdensesolverlsreport):Tdensesolverlsreport;overload;
    procedure rmatrixsolve( a: TMatrix;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixsolvefast( a: TMatrix;  n: TALGLIBInteger; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixsolvem( a: TMatrix;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger;  rfs: Boolean; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixsolvemfast( a: TMatrix;  n: TALGLIBInteger; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixlusolve( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixlusolvefast( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixlusolvem( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
    procedure rmatrixlusolvemfast( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixmixedsolve( a: TMatrix;  lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixmixedsolvem( a: TMatrix;  lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixsolvem( a: TCMatrix;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger;  rfs: Boolean; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixsolvemfast( a: TCMatrix;  n: TALGLIBInteger; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixsolve( a: TCMatrix;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
    procedure cmatrixsolvefast( a: TCMatrix;  n: TALGLIBInteger; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixlusolvem( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixlusolvemfast( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixlusolve( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
    procedure cmatrixlusolvefast( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure cmatrixmixedsolvem( a: TCMatrix;  lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
    procedure cmatrixmixedsolve( a: TCMatrix;  lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
    procedure spdmatrixsolvem( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
    procedure spdmatrixsolvemfast( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure spdmatrixsolve( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
    procedure spdmatrixsolvefast( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure spdmatrixcholeskysolvem( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
    procedure spdmatrixcholeskysolvemfast( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure spdmatrixcholeskysolve( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
    procedure spdmatrixcholeskysolvefast( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure hpdmatrixsolvem( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
    procedure hpdmatrixsolvemfast( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure hpdmatrixsolve( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
    procedure hpdmatrixsolvefast( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure hpdmatrixcholeskysolvem( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
    procedure hpdmatrixcholeskysolvemfast( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure hpdmatrixcholeskysolve( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
    procedure hpdmatrixcholeskysolvefast( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rmatrixsolvels( a: TMatrix;  nrows: TALGLIBInteger;  ncols: TALGLIBInteger;  b: TVector;  threshold: Double; out  info: TALGLIBInteger; out  rep: Tdensesolverlsreport; out  x: TVector; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminlbfgsreport):Tminlbfgsreport;overload;
    procedure minlbfgscreate( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
    procedure minlbfgscreate( m: TALGLIBInteger;  x: TVector; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
    procedure minlbfgscreatef( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
    procedure minlbfgscreatef( m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
    procedure minlbfgssetcond( state: Tminlbfgsstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minlbfgssetxrep( state: Tminlbfgsstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure minlbfgssetstpmax( state: Tminlbfgsstate;  stpmax: Double; const _xparams: UInt64 = 0);
    procedure minlbfgssetscale( state: Tminlbfgsstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minlbfgssetprecdefault( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
    procedure minlbfgssetpreccholesky( state: Tminlbfgsstate;  p: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);
    procedure minlbfgssetprecdiag( state: Tminlbfgsstate;  d: TVector; const _xparams: UInt64 = 0);
    procedure minlbfgssetprecscale( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
    function minlbfgsiteration( state: Tminlbfgsstate; const _xparams: UInt64 = 0):Boolean;
    procedure minlbfgsoptimize(state: Tminlbfgsstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minlbfgsoptimize(state: Tminlbfgsstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minlbfgsoptguardgradient( state: Tminlbfgsstate;  teststep: Double; const _xparams: UInt64 = 0);
    procedure minlbfgsoptguardsmoothness( state: Tminlbfgsstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minlbfgsoptguardsmoothness( state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
    procedure minlbfgsoptguardresults( state: Tminlbfgsstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
    procedure minlbfgsoptguardnonc1test0results( state: Tminlbfgsstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
    procedure minlbfgsoptguardnonc1test1results( state: Tminlbfgsstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
    procedure minlbfgsresults( state: Tminlbfgsstate; out  x: TVector; out  rep: Tminlbfgsreport; const _xparams: UInt64 = 0);
    procedure minlbfgsresultsbuf( state: Tminlbfgsstate; var  x: TVector;  rep: Tminlbfgsreport; const _xparams: UInt64 = 0);
    procedure minlbfgsrestartfrom( state: Tminlbfgsstate;  x: TVector; const _xparams: UInt64 = 0);
    procedure minlbfgsrequesttermination( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
    procedure normestimatorcreate( m: TALGLIBInteger;  n: TALGLIBInteger;  nstart: TALGLIBInteger;  nits: TALGLIBInteger; out  state: Tnormestimatorstate; const _xparams: UInt64 = 0);
    procedure normestimatorsetseed( state: Tnormestimatorstate;  seedval: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure normestimatorestimatesparse( state: Tnormestimatorstate;  a: Tsparsematrix; const _xparams: UInt64 = 0);
    procedure normestimatorresults( state: Tnormestimatorstate; out  nrm: Double; const _xparams: UInt64 = 0);
    function Clone(const Src: Tlinlsqrreport):Tlinlsqrreport;overload;
    procedure linlsqrcreate( m: TALGLIBInteger;  n: TALGLIBInteger; out  state: Tlinlsqrstate; const _xparams: UInt64 = 0);
    procedure linlsqrcreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  state: Tlinlsqrstate; const _xparams: UInt64 = 0);
    procedure linlsqrsetprecunit( state: Tlinlsqrstate; const _xparams: UInt64 = 0);
    procedure linlsqrsetprecdiag( state: Tlinlsqrstate; const _xparams: UInt64 = 0);
    procedure linlsqrsetlambdai( state: Tlinlsqrstate;  lambdai: Double; const _xparams: UInt64 = 0);
    procedure linlsqrsolvesparse( state: Tlinlsqrstate;  a: Tsparsematrix;  b: TVector; const _xparams: UInt64 = 0);
    procedure linlsqrsetcond( state: Tlinlsqrstate;  epsa: Double;  epsb: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure linlsqrresults( state: Tlinlsqrstate; out  x: TVector; out  rep: Tlinlsqrreport; const _xparams: UInt64 = 0);
    procedure linlsqrsetxrep( state: Tlinlsqrstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    function linlsqrpeekiterationscount( s: Tlinlsqrstate; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure linlsqrrequesttermination( state: Tlinlsqrstate; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminbleicreport):Tminbleicreport;overload;
    procedure minbleiccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
    procedure minbleiccreate( x: TVector; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
    procedure minbleiccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
    procedure minbleiccreatef( x: TVector;  diffstep: Double; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
    procedure minbleicsetbc( state: Tminbleicstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure minbleicsetlc( state: Tminbleicstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minbleicsetlc( state: Tminbleicstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    procedure minbleicsetcond( state: Tminbleicstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minbleicsetscale( state: Tminbleicstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minbleicsetprecdefault( state: Tminbleicstate; const _xparams: UInt64 = 0);
    procedure minbleicsetprecdiag( state: Tminbleicstate;  d: TVector; const _xparams: UInt64 = 0);
    procedure minbleicsetprecscale( state: Tminbleicstate; const _xparams: UInt64 = 0);
    procedure minbleicsetxrep( state: Tminbleicstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure minbleicsetstpmax( state: Tminbleicstate;  stpmax: Double; const _xparams: UInt64 = 0);
    function minbleiciteration( state: Tminbleicstate; const _xparams: UInt64 = 0):Boolean;
    procedure minbleicoptimize(state: Tminbleicstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minbleicoptimize(state: Tminbleicstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minbleicoptguardgradient( state: Tminbleicstate;  teststep: Double; const _xparams: UInt64 = 0);
    procedure minbleicoptguardsmoothness( state: Tminbleicstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minbleicoptguardsmoothness( state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
    procedure minbleicoptguardresults( state: Tminbleicstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
    procedure minbleicoptguardnonc1test0results( state: Tminbleicstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
    procedure minbleicoptguardnonc1test1results( state: Tminbleicstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
    procedure minbleicresults( state: Tminbleicstate; out  x: TVector; out  rep: Tminbleicreport; const _xparams: UInt64 = 0);
    procedure minbleicresultsbuf( state: Tminbleicstate; var  x: TVector;  rep: Tminbleicreport; const _xparams: UInt64 = 0);
    procedure minbleicrestartfrom( state: Tminbleicstate;  x: TVector; const _xparams: UInt64 = 0);
    procedure minbleicrequesttermination( state: Tminbleicstate; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminqpreport):Tminqpreport;overload;
    procedure minqpcreate( n: TALGLIBInteger; out  state: Tminqpstate; const _xparams: UInt64 = 0);
    procedure minqpsetlinearterm( state: Tminqpstate;  b: TVector; const _xparams: UInt64 = 0);
    procedure minqpsetquadraticterm( state: Tminqpstate;  a: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);overload;
    procedure minqpsetquadraticterm( state: Tminqpstate;  a: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure minqpsetquadratictermsparse( state: Tminqpstate;  a: Tsparsematrix;  isupper: Boolean; const _xparams: UInt64 = 0);
    procedure minqpsetstartingpoint( state: Tminqpstate;  x: TVector; const _xparams: UInt64 = 0);
    procedure minqpsetorigin( state: Tminqpstate;  xorigin: TVector; const _xparams: UInt64 = 0);
    procedure minqpsetscale( state: Tminqpstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minqpsetscaleautodiag( state: Tminqpstate; const _xparams: UInt64 = 0);
    procedure minqpsetalgobleic( state: Tminqpstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minqpsetalgodenseaul( state: Tminqpstate;  epsx: Double;  rho: Double;  itscnt: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minqpsetalgodenseipm( state: Tminqpstate;  eps: Double; const _xparams: UInt64 = 0);
    procedure minqpsetalgosparseipm( state: Tminqpstate;  eps: Double; const _xparams: UInt64 = 0);
    procedure minqpsetalgoquickqp( state: Tminqpstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxouterits: TALGLIBInteger;  usenewton: Boolean; const _xparams: UInt64 = 0);
    procedure minqpsetbc( state: Tminqpstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure minqpsetbcall( state: Tminqpstate;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
    procedure minqpsetbci( state: Tminqpstate;  i: TALGLIBInteger;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
    procedure minqpsetlc( state: Tminqpstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minqpsetlc( state: Tminqpstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    procedure minqpsetlcsparse( state: Tminqpstate;  c: Tsparsematrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minqpsetlcmixed( state: Tminqpstate;  sparsec: Tsparsematrix;  sparsect: TIVector;  sparsek: TALGLIBInteger;  densec: TMatrix;  densect: TIVector;  densek: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minqpsetlcmixedlegacy( state: Tminqpstate;  densec: TMatrix;  densect: TIVector;  densek: TALGLIBInteger;  sparsec: Tsparsematrix;  sparsect: TIVector;  sparsek: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minqpsetlc2dense( state: Tminqpstate;  a: TMatrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minqpsetlc2dense( state: Tminqpstate;  a: TMatrix;  al: TVector;  au: TVector; const _xparams: UInt64 = 0);overload;
    procedure minqpsetlc2( state: Tminqpstate;  a: Tsparsematrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minqpsetlc2mixed( state: Tminqpstate;  sparsea: Tsparsematrix;  ksparse: TALGLIBInteger;  densea: TMatrix;  kdense: TALGLIBInteger;  al: TVector;  au: TVector; const _xparams: UInt64 = 0);
    procedure minqpaddlc2dense( state: Tminqpstate;  a: TVector;  al: Double;  au: Double; const _xparams: UInt64 = 0);
    procedure minqpaddlc2( state: Tminqpstate;  idxa: TIVector;  vala: TVector;  nnz: TALGLIBInteger;  al: Double;  au: Double; const _xparams: UInt64 = 0);
    procedure minqpoptimize( state: Tminqpstate; const _xparams: UInt64 = 0);
    procedure minqpresults( state: Tminqpstate; out  x: TVector; out  rep: Tminqpreport; const _xparams: UInt64 = 0);
    procedure minqpresultsbuf( state: Tminqpstate; var  x: TVector;  rep: Tminqpreport; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminlpreport):Tminlpreport;overload;
    procedure minlpcreate( n: TALGLIBInteger; out  state: Tminlpstate; const _xparams: UInt64 = 0);
    procedure minlpsetcost( state: Tminlpstate;  c: TVector; const _xparams: UInt64 = 0);
    procedure minlpsetscale( state: Tminlpstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minlpsetbc( state: Tminlpstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure minlpsetbcall( state: Tminlpstate;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
    procedure minlpsetbci( state: Tminlpstate;  i: TALGLIBInteger;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
    procedure minlpsetlc( state: Tminlpstate;  a: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minlpsetlc( state: Tminlpstate;  a: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    procedure minlpsetlc2dense( state: Tminlpstate;  a: TMatrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minlpsetlc2dense( state: Tminlpstate;  a: TMatrix;  al: TVector;  au: TVector; const _xparams: UInt64 = 0);overload;
    procedure minlpsetlc2( state: Tminlpstate;  a: Tsparsematrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minlpaddlc2dense( state: Tminlpstate;  a: TVector;  al: Double;  au: Double; const _xparams: UInt64 = 0);
    procedure minlpaddlc2( state: Tminlpstate;  idxa: TIVector;  vala: TVector;  nnz: TALGLIBInteger;  al: Double;  au: Double; const _xparams: UInt64 = 0);
    procedure minlpoptimize( state: Tminlpstate; const _xparams: UInt64 = 0);
    procedure minlpresults( state: Tminlpstate; out  x: TVector; out  rep: Tminlpreport; const _xparams: UInt64 = 0);
    procedure minlpresultsbuf( state: Tminlpstate; var  x: TVector;  rep: Tminlpreport; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminnlcreport):Tminnlcreport;overload;
    procedure minnlccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
    procedure minnlccreate( x: TVector; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
    procedure minnlccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
    procedure minnlccreatef( x: TVector;  diffstep: Double; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
    procedure minnlcsetbc( state: Tminnlcstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure minnlcsetlc( state: Tminnlcstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minnlcsetlc( state: Tminnlcstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    procedure minnlcsetnlc( state: Tminnlcstate;  nlec: TALGLIBInteger;  nlic: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minnlcsetcond( state: Tminnlcstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minnlcsetscale( state: Tminnlcstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minnlcsetprecinexact( state: Tminnlcstate; const _xparams: UInt64 = 0);
    procedure minnlcsetprecexactlowrank( state: Tminnlcstate;  updatefreq: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minnlcsetprecexactrobust( state: Tminnlcstate;  updatefreq: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minnlcsetprecnone( state: Tminnlcstate; const _xparams: UInt64 = 0);
    procedure minnlcsetstpmax( state: Tminnlcstate;  stpmax: Double; const _xparams: UInt64 = 0);
    procedure minnlcsetalgoaul( state: Tminnlcstate;  rho: Double;  itscnt: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minnlcsetalgoslp( state: Tminnlcstate; const _xparams: UInt64 = 0);
    procedure minnlcsetalgosqp( state: Tminnlcstate; const _xparams: UInt64 = 0);
    procedure minnlcsetxrep( state: Tminnlcstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    function minnlciteration( state: Tminnlcstate; const _xparams: UInt64 = 0):Boolean;
    procedure minnlcoptimize(state: Tminnlcstate; fvec: Tndimensional_fvec; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minnlcoptimize(state: Tminnlcstate; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minnlcoptguardgradient( state: Tminnlcstate;  teststep: Double; const _xparams: UInt64 = 0);
    procedure minnlcoptguardsmoothness( state: Tminnlcstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minnlcoptguardsmoothness( state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
    procedure minnlcoptguardresults( state: Tminnlcstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
    procedure minnlcoptguardnonc1test0results( state: Tminnlcstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
    procedure minnlcoptguardnonc1test1results( state: Tminnlcstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
    procedure minnlcresults( state: Tminnlcstate; out  x: TVector; out  rep: Tminnlcreport; const _xparams: UInt64 = 0);
    procedure minnlcresultsbuf( state: Tminnlcstate; var  x: TVector;  rep: Tminnlcreport; const _xparams: UInt64 = 0);
    procedure minnlcrequesttermination( state: Tminnlcstate; const _xparams: UInt64 = 0);
    procedure minnlcrestartfrom( state: Tminnlcstate;  x: TVector; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminbcreport):Tminbcreport;overload;
    procedure minbccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
    procedure minbccreate( x: TVector; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
    procedure minbccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
    procedure minbccreatef( x: TVector;  diffstep: Double; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
    procedure minbcsetbc( state: Tminbcstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure minbcsetcond( state: Tminbcstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minbcsetscale( state: Tminbcstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minbcsetprecdefault( state: Tminbcstate; const _xparams: UInt64 = 0);
    procedure minbcsetprecdiag( state: Tminbcstate;  d: TVector; const _xparams: UInt64 = 0);
    procedure minbcsetprecscale( state: Tminbcstate; const _xparams: UInt64 = 0);
    procedure minbcsetxrep( state: Tminbcstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure minbcsetstpmax( state: Tminbcstate;  stpmax: Double; const _xparams: UInt64 = 0);
    function minbciteration( state: Tminbcstate; const _xparams: UInt64 = 0):Boolean;
    procedure minbcoptimize(state: Tminbcstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minbcoptimize(state: Tminbcstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minbcoptguardgradient( state: Tminbcstate;  teststep: Double; const _xparams: UInt64 = 0);
    procedure minbcoptguardsmoothness( state: Tminbcstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minbcoptguardsmoothness( state: Tminbcstate; const _xparams: UInt64 = 0);overload;
    procedure minbcoptguardresults( state: Tminbcstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
    procedure minbcoptguardnonc1test0results( state: Tminbcstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
    procedure minbcoptguardnonc1test1results( state: Tminbcstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
    procedure minbcresults( state: Tminbcstate; out  x: TVector; out  rep: Tminbcreport; const _xparams: UInt64 = 0);
    procedure minbcresultsbuf( state: Tminbcstate; var  x: TVector;  rep: Tminbcreport; const _xparams: UInt64 = 0);
    procedure minbcrestartfrom( state: Tminbcstate;  x: TVector; const _xparams: UInt64 = 0);
    procedure minbcrequesttermination( state: Tminbcstate; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminnsreport):Tminnsreport;overload;
    procedure minnscreate( n: TALGLIBInteger;  x: TVector; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
    procedure minnscreate( x: TVector; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
    procedure minnscreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
    procedure minnscreatef( x: TVector;  diffstep: Double; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
    procedure minnssetbc( state: Tminnsstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure minnssetlc( state: Tminnsstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minnssetlc( state: Tminnsstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    procedure minnssetnlc( state: Tminnsstate;  nlec: TALGLIBInteger;  nlic: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minnssetcond( state: Tminnsstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minnssetscale( state: Tminnsstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minnssetalgoags( state: Tminnsstate;  radius: Double;  penalty: Double; const _xparams: UInt64 = 0);
    procedure minnssetxrep( state: Tminnsstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure minnsrequesttermination( state: Tminnsstate; const _xparams: UInt64 = 0);
    function minnsiteration( state: Tminnsstate; const _xparams: UInt64 = 0):Boolean;
    procedure minnsoptimize(state: Tminnsstate; fvec: Tndimensional_fvec; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minnsoptimize(state: Tminnsstate; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minnsresults( state: Tminnsstate; out  x: TVector; out  rep: Tminnsreport; const _xparams: UInt64 = 0);
    procedure minnsresultsbuf( state: Tminnsstate; var  x: TVector;  rep: Tminnsreport; const _xparams: UInt64 = 0);
    procedure minnsrestartfrom( state: Tminnsstate;  x: TVector; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminasareport):Tminasareport;overload;
    procedure minlbfgssetdefaultpreconditioner( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
    procedure minlbfgssetcholeskypreconditioner( state: Tminlbfgsstate;  p: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);
    procedure minbleicsetbarrierwidth( state: Tminbleicstate;  mu: Double; const _xparams: UInt64 = 0);
    procedure minbleicsetbarrierdecay( state: Tminbleicstate;  mudecay: Double; const _xparams: UInt64 = 0);
    procedure minasacreate( n: TALGLIBInteger;  x: TVector;  bndl: TVector;  bndu: TVector; out  state: Tminasastate; const _xparams: UInt64 = 0);overload;
    procedure minasacreate( x: TVector;  bndl: TVector;  bndu: TVector; out  state: Tminasastate; const _xparams: UInt64 = 0);overload;
    procedure minasasetcond( state: Tminasastate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minasasetxrep( state: Tminasastate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure minasasetalgorithm( state: Tminasastate;  algotype: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minasasetstpmax( state: Tminasastate;  stpmax: Double; const _xparams: UInt64 = 0);
    function minasaiteration( state: Tminasastate; const _xparams: UInt64 = 0):Boolean;
    procedure minasaoptimize(state: Tminasastate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minasaresults( state: Tminasastate; out  x: TVector; out  rep: Tminasareport; const _xparams: UInt64 = 0);
    procedure minasaresultsbuf( state: Tminasastate; var  x: TVector;  rep: Tminasareport; const _xparams: UInt64 = 0);
    procedure minasarestartfrom( state: Tminasastate;  x: TVector;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    function Clone(const Src: Tmincgreport):Tmincgreport;overload;
    procedure mincgcreate( n: TALGLIBInteger;  x: TVector; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
    procedure mincgcreate( x: TVector; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
    procedure mincgcreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
    procedure mincgcreatef( x: TVector;  diffstep: Double; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
    procedure mincgsetcond( state: Tmincgstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure mincgsetscale( state: Tmincgstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure mincgsetxrep( state: Tmincgstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure mincgsetcgtype( state: Tmincgstate;  cgtype: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure mincgsetstpmax( state: Tmincgstate;  stpmax: Double; const _xparams: UInt64 = 0);
    procedure mincgsuggeststep( state: Tmincgstate;  stp: Double; const _xparams: UInt64 = 0);
    procedure mincgsetprecdefault( state: Tmincgstate; const _xparams: UInt64 = 0);
    procedure mincgsetprecdiag( state: Tmincgstate;  d: TVector; const _xparams: UInt64 = 0);
    procedure mincgsetprecscale( state: Tmincgstate; const _xparams: UInt64 = 0);
    function mincgiteration( state: Tmincgstate; const _xparams: UInt64 = 0):Boolean;
    procedure mincgoptimize(state: Tmincgstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure mincgoptimize(state: Tmincgstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure mincgoptguardgradient( state: Tmincgstate;  teststep: Double; const _xparams: UInt64 = 0);
    procedure mincgoptguardsmoothness( state: Tmincgstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure mincgoptguardsmoothness( state: Tmincgstate; const _xparams: UInt64 = 0);overload;
    procedure mincgoptguardresults( state: Tmincgstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
    procedure mincgoptguardnonc1test0results( state: Tmincgstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
    procedure mincgoptguardnonc1test1results( state: Tmincgstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
    procedure mincgresults( state: Tmincgstate; out  x: TVector; out  rep: Tmincgreport; const _xparams: UInt64 = 0);
    procedure mincgresultsbuf( state: Tmincgstate; var  x: TVector;  rep: Tmincgreport; const _xparams: UInt64 = 0);
    procedure mincgrestartfrom( state: Tmincgstate;  x: TVector; const _xparams: UInt64 = 0);
    procedure mincgrequesttermination( state: Tmincgstate; const _xparams: UInt64 = 0);
    function Clone(const Src: Tminlmreport):Tminlmreport;overload;
    procedure minlmcreatevj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatevj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatev( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatev( m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatefgh( n: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatefgh( x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmsetcond( state: Tminlmstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure minlmsetxrep( state: Tminlmstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure minlmsetstpmax( state: Tminlmstate;  stpmax: Double; const _xparams: UInt64 = 0);
    procedure minlmsetscale( state: Tminlmstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure minlmsetbc( state: Tminlmstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure minlmsetlc( state: Tminlmstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure minlmsetlc( state: Tminlmstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    procedure minlmsetacctype( state: Tminlmstate;  acctype: TALGLIBInteger; const _xparams: UInt64 = 0);
    function minlmiteration( state: Tminlmstate; const _xparams: UInt64 = 0):Boolean;
    procedure minlmoptimize(state: Tminlmstate; fvec: Tndimensional_fvec; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minlmoptimize(state: Tminlmstate; fvec: Tndimensional_fvec; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minlmoptimize(state: Tminlmstate; func: Tndimensional_func; grad: Tndimensional_grad; hess: Tndimensional_hess; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minlmoptimize(state: Tminlmstate; func: Tndimensional_func; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minlmoptimize(state: Tminlmstate; func: Tndimensional_func; grad: Tndimensional_grad; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure minlmoptguardgradient( state: Tminlmstate;  teststep: Double; const _xparams: UInt64 = 0);
    procedure minlmoptguardresults( state: Tminlmstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
    procedure minlmresults( state: Tminlmstate; out  x: TVector; out  rep: Tminlmreport; const _xparams: UInt64 = 0);
    procedure minlmresultsbuf( state: Tminlmstate; var  x: TVector;  rep: Tminlmreport; const _xparams: UInt64 = 0);
    procedure minlmrestartfrom( state: Tminlmstate;  x: TVector; const _xparams: UInt64 = 0);
    procedure minlmrequesttermination( state: Tminlmstate; const _xparams: UInt64 = 0);
    procedure minlmcreatevgj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatevgj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatefgj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatefgj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatefj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    procedure minlmcreatefj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
    function Clone(const Src: Teigsubspacereport):Teigsubspacereport;overload;
    procedure eigsubspacecreate( n: TALGLIBInteger;  k: TALGLIBInteger; out  state: Teigsubspacestate; const _xparams: UInt64 = 0);
    procedure eigsubspacecreatebuf( n: TALGLIBInteger;  k: TALGLIBInteger;  state: Teigsubspacestate; const _xparams: UInt64 = 0);
    procedure eigsubspacesetcond( state: Teigsubspacestate;  eps: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure eigsubspacesetwarmstart( state: Teigsubspacestate;  usewarmstart: Boolean; const _xparams: UInt64 = 0);
    procedure eigsubspaceoocstart( state: Teigsubspacestate;  mtype: TALGLIBInteger; const _xparams: UInt64 = 0);
    function eigsubspaceooccontinue( state: Teigsubspacestate; const _xparams: UInt64 = 0):Boolean;
    procedure eigsubspaceoocgetrequestinfo( state: Teigsubspacestate; out  requesttype: TALGLIBInteger; out  requestsize: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure eigsubspaceoocgetrequestdata( state: Teigsubspacestate; var  x: TMatrix; const _xparams: UInt64 = 0);
    procedure eigsubspaceoocsendresult( state: Teigsubspacestate;  ax: TMatrix; const _xparams: UInt64 = 0);
    procedure eigsubspaceoocstop( state: Teigsubspacestate; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; const _xparams: UInt64 = 0);
    procedure eigsubspacesolvedenses( state: Teigsubspacestate;  a: TMatrix;  isupper: Boolean; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; const _xparams: UInt64 = 0);
    procedure eigsubspacesolvesparses( state: Teigsubspacestate;  a: Tsparsematrix;  isupper: Boolean; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; const _xparams: UInt64 = 0);
    function smatrixevd( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean; out  d: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function smatrixevdr( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  b1: Double;  b2: Double; out  m: TALGLIBInteger; out  w: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function smatrixevdi( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  i1: TALGLIBInteger;  i2: TALGLIBInteger; out  w: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function hmatrixevd( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean; out  d: TVector; out  z: TCMatrix; const _xparams: UInt64 = 0):Boolean;
    function hmatrixevdr( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  b1: Double;  b2: Double; out  m: TALGLIBInteger; out  w: TVector; out  z: TCMatrix; const _xparams: UInt64 = 0):Boolean;
    function hmatrixevdi( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  i1: TALGLIBInteger;  i2: TALGLIBInteger; out  w: TVector; out  z: TCMatrix; const _xparams: UInt64 = 0):Boolean;
    function smatrixtdevd(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger; var  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function smatrixtdevdr(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  a: Double;  b: Double; out  m: TALGLIBInteger; var  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function smatrixtdevdi(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  i1: TALGLIBInteger;  i2: TALGLIBInteger; var  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function rmatrixevd( a: TMatrix;  n: TALGLIBInteger;  vneeded: TALGLIBInteger; out  wr: TVector; out  wi: TVector; out  vl: TMatrix; out  vr: TMatrix; const _xparams: UInt64 = 0):Boolean;
    procedure samplemoments( x: TVector;  n: TALGLIBInteger; out  mean: Double; out  variance: Double; out  skewness: Double; out  kurtosis: Double; const _xparams: UInt64 = 0);overload;
    procedure samplemoments( x: TVector; out  mean: Double; out  variance: Double; out  skewness: Double; out  kurtosis: Double; const _xparams: UInt64 = 0);overload;
    function samplemean( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function samplemean( x: TVector; const _xparams: UInt64 = 0):Double;overload;
    function samplevariance( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function samplevariance( x: TVector; const _xparams: UInt64 = 0):Double;overload;
    function sampleskewness( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function sampleskewness( x: TVector; const _xparams: UInt64 = 0):Double;overload;
    function samplekurtosis( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function samplekurtosis( x: TVector; const _xparams: UInt64 = 0):Double;overload;
    procedure sampleadev( x: TVector;  n: TALGLIBInteger; out  adev: Double; const _xparams: UInt64 = 0);overload;
    procedure sampleadev( x: TVector; out  adev: Double; const _xparams: UInt64 = 0);overload;
    procedure samplemedian( x: TVector;  n: TALGLIBInteger; out  median: Double; const _xparams: UInt64 = 0);overload;
    procedure samplemedian( x: TVector; out  median: Double; const _xparams: UInt64 = 0);overload;
    procedure samplepercentile( x: TVector;  n: TALGLIBInteger;  p: Double; out  v: Double; const _xparams: UInt64 = 0);overload;
    procedure samplepercentile( x: TVector;  p: Double; out  v: Double; const _xparams: UInt64 = 0);overload;
    function cov2( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function cov2( x: TVector;  y: TVector; const _xparams: UInt64 = 0):Double;overload;
    function pearsoncorr2( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function pearsoncorr2( x: TVector;  y: TVector; const _xparams: UInt64 = 0):Double;overload;
    function spearmancorr2( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function spearmancorr2( x: TVector;  y: TVector; const _xparams: UInt64 = 0):Double;overload;
    procedure covm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure covm( x: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure pearsoncorrm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure pearsoncorrm( x: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure spearmancorrm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure spearmancorrm( x: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure covm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure covm2( x: TMatrix;  y: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure pearsoncorrm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure pearsoncorrm2( x: TMatrix;  y: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure spearmancorrm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure spearmancorrm2( x: TMatrix;  y: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure rankdata(var  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure rankdata(var  xy: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure rankdatacentered(var  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure rankdatacentered(var  xy: TMatrix; const _xparams: UInt64 = 0);overload;
    function pearsoncorrelation( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function spearmanrankcorrelation( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure pcabuildbasis( x: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; const _xparams: UInt64 = 0);
    procedure pcatruncatedsubspace( x: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nneeded: TALGLIBInteger;  eps: Double;  maxits: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; const _xparams: UInt64 = 0);
    procedure pcatruncatedsubspacesparse( x: Tsparsematrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nneeded: TALGLIBInteger;  eps: Double;  maxits: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; const _xparams: UInt64 = 0);
    procedure dsoptimalsplit2( a: TVector;  c: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  threshold: Double; out  pal: Double; out  pbl: Double; out  par: Double; out  pbr: Double; out  cve: Double; const _xparams: UInt64 = 0);
    procedure dsoptimalsplit2fast(var  a: TVector; var  c: TIVector; var  tiesbuf: TIVector; var  cntbuf: TIVector; var  bufr: TVector; var  bufi: TIVector;  n: TALGLIBInteger;  nc: TALGLIBInteger;  alpha: Double; out  info: TALGLIBInteger; out  threshold: Double; out  rms: Double; out  cvrms: Double; const _xparams: UInt64 = 0);
    function Clone(const Src: Tmodelerrors):Tmodelerrors;overload;
    procedure mlpserialize(const obj: Tmultilayerperceptron; out s_out: AnsiString);overload;
    procedure mlpunserialize(const s_in: AnsiString; out obj: Tmultilayerperceptron);overload;
    procedure mlpserialize(const obj: Tmultilayerperceptron; stream: TStream);overload;
    procedure mlpunserialize(stream: TStream; out obj: Tmultilayerperceptron);overload;
    procedure mlpcreate0( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreate1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreate2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreateb0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreateb1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreateb2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreater0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreater1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreater2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreatec0( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreatec1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcreatec2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcopy( network1: Tmultilayerperceptron; out  network2: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpcopytunableparameters( network1: Tmultilayerperceptron;  network2: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlprandomize( network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlprandomizefull( network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
    procedure mlpinitpreprocessor( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure mlpproperties( network: Tmultilayerperceptron; out  nin: TALGLIBInteger; out  nout: TALGLIBInteger; out  wcount: TALGLIBInteger; const _xparams: UInt64 = 0);
    function mlpgetinputscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
    function mlpgetoutputscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
    function mlpgetweightscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
    function mlpissoftmax( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):Boolean;
    function mlpgetlayerscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
    function mlpgetlayersize( network: Tmultilayerperceptron;  k: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure mlpgetinputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger; out  mean: Double; out  sigma: Double; const _xparams: UInt64 = 0);
    procedure mlpgetoutputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger; out  mean: Double; out  sigma: Double; const _xparams: UInt64 = 0);
    procedure mlpgetneuroninfo( network: Tmultilayerperceptron;  k: TALGLIBInteger;  i: TALGLIBInteger; out  fkind: TALGLIBInteger; out  threshold: Double; const _xparams: UInt64 = 0);
    function mlpgetweight( network: Tmultilayerperceptron;  k0: TALGLIBInteger;  i0: TALGLIBInteger;  k1: TALGLIBInteger;  i1: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure mlpsetinputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger;  mean: Double;  sigma: Double; const _xparams: UInt64 = 0);
    procedure mlpsetoutputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger;  mean: Double;  sigma: Double; const _xparams: UInt64 = 0);
    procedure mlpsetneuroninfo( network: Tmultilayerperceptron;  k: TALGLIBInteger;  i: TALGLIBInteger;  fkind: TALGLIBInteger;  threshold: Double; const _xparams: UInt64 = 0);
    procedure mlpsetweight( network: Tmultilayerperceptron;  k0: TALGLIBInteger;  i0: TALGLIBInteger;  k1: TALGLIBInteger;  i1: TALGLIBInteger;  w: Double; const _xparams: UInt64 = 0);
    procedure mlpactivationfunction( net: Double;  k: TALGLIBInteger; out  f: Double; out  df: Double; out  d2f: Double; const _xparams: UInt64 = 0);
    procedure mlpprocess( network: Tmultilayerperceptron;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure mlpprocessi( network: Tmultilayerperceptron;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
    function mlperror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlperrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlperrorn( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpclserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
    function mlprelclserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlprelclserrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpavgce( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpavgcesparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlprmserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlprmserrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpavgerror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpavgerrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpavgrelerror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpavgrelerrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure mlpgrad( network: Tmultilayerperceptron;  x: TVector;  desiredy: TVector; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
    procedure mlpgradn( network: Tmultilayerperceptron;  x: TVector;  desiredy: TVector; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
    procedure mlpgradbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
    procedure mlpgradbatchsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
    procedure mlpgradbatchsubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  idx: TIVector;  subsetsize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
    procedure mlpgradbatchsparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  idx: TIVector;  subsetsize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
    procedure mlpgradnbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
    procedure mlphessiannbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; var  h: TMatrix; const _xparams: UInt64 = 0);
    procedure mlphessianbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; var  h: TMatrix; const _xparams: UInt64 = 0);
    procedure mlpallerrorssubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; out  rep: Tmodelerrors; const _xparams: UInt64 = 0);
    procedure mlpallerrorssparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; out  rep: Tmodelerrors; const _xparams: UInt64 = 0);
    function mlperrorsubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlperrorsparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure fisherlda( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  w: TVector; const _xparams: UInt64 = 0);
    procedure fisherldan( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  w: TMatrix; const _xparams: UInt64 = 0);
    procedure ssacreate(out  s: Tssamodel; const _xparams: UInt64 = 0);
    procedure ssasetwindow( s: Tssamodel;  windowwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssasetseed( s: Tssamodel;  seed: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssasetpoweruplength( s: Tssamodel;  pwlen: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssasetmemorylimit( s: Tssamodel;  memlimit: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssaaddsequence( s: Tssamodel;  x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure ssaaddsequence( s: Tssamodel;  x: TVector; const _xparams: UInt64 = 0);overload;
    procedure ssaappendpointandupdate( s: Tssamodel;  x: Double;  updateits: Double; const _xparams: UInt64 = 0);
    procedure ssaappendsequenceandupdate( s: Tssamodel;  x: TVector;  nticks: TALGLIBInteger;  updateits: Double; const _xparams: UInt64 = 0);overload;
    procedure ssaappendsequenceandupdate( s: Tssamodel;  x: TVector;  updateits: Double; const _xparams: UInt64 = 0);overload;
    procedure ssasetalgoprecomputed( s: Tssamodel;  a: TMatrix;  windowwidth: TALGLIBInteger;  nbasis: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure ssasetalgoprecomputed( s: Tssamodel;  a: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure ssasetalgotopkdirect( s: Tssamodel;  topk: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssasetalgotopkrealtime( s: Tssamodel;  topk: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssacleardata( s: Tssamodel; const _xparams: UInt64 = 0);
    procedure ssagetbasis( s: Tssamodel; out  a: TMatrix; out  sv: TVector; out  windowwidth: TALGLIBInteger; out  nbasis: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssagetlrr( s: Tssamodel; out  a: TVector; out  windowwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssaanalyzelastwindow( s: Tssamodel; out  trend: TVector; out  noise: TVector; out  nticks: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure ssaanalyzelast( s: Tssamodel;  nticks: TALGLIBInteger; out  trend: TVector; out  noise: TVector; const _xparams: UInt64 = 0);
    procedure ssaanalyzesequence( s: Tssamodel;  data: TVector;  nticks: TALGLIBInteger; out  trend: TVector; out  noise: TVector; const _xparams: UInt64 = 0);overload;
    procedure ssaanalyzesequence( s: Tssamodel;  data: TVector; out  trend: TVector; out  noise: TVector; const _xparams: UInt64 = 0);overload;
    procedure ssaforecastlast( s: Tssamodel;  nticks: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);
    procedure ssaforecastsequence( s: Tssamodel;  data: TVector;  datalen: TALGLIBInteger;  forecastlen: TALGLIBInteger;  applysmoothing: Boolean; out  trend: TVector; const _xparams: UInt64 = 0);overload;
    procedure ssaforecastsequence( s: Tssamodel;  data: TVector;  forecastlen: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);overload;
    procedure ssaforecastavglast( s: Tssamodel;  m: TALGLIBInteger;  nticks: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);
    procedure ssaforecastavgsequence( s: Tssamodel;  data: TVector;  datalen: TALGLIBInteger;  m: TALGLIBInteger;  forecastlen: TALGLIBInteger;  applysmoothing: Boolean; out  trend: TVector; const _xparams: UInt64 = 0);overload;
    procedure ssaforecastavgsequence( s: Tssamodel;  data: TVector;  m: TALGLIBInteger;  forecastlen: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);overload;
    function gammafunction( x: Double; const _xparams: UInt64 = 0):Double;
    function lngamma( x: Double; out  sgngam: Double; const _xparams: UInt64 = 0):Double;
    function errorfunction( x: Double; const _xparams: UInt64 = 0):Double;
    function errorfunctionc( x: Double; const _xparams: UInt64 = 0):Double;
    function normaldistribution( x: Double; const _xparams: UInt64 = 0):Double;
    function normalpdf( x: Double; const _xparams: UInt64 = 0):Double;
    function normalcdf( x: Double; const _xparams: UInt64 = 0):Double;
    function inverf( e: Double; const _xparams: UInt64 = 0):Double;
    function invnormaldistribution( y0: Double; const _xparams: UInt64 = 0):Double;
    function invnormalcdf( y0: Double; const _xparams: UInt64 = 0):Double;
    function bivariatenormalpdf( x: Double;  y: Double;  rho: Double; const _xparams: UInt64 = 0):Double;
    function bivariatenormalcdf( x: Double;  y: Double;  rho: Double; const _xparams: UInt64 = 0):Double;
    function incompletegamma( a: Double;  x: Double; const _xparams: UInt64 = 0):Double;
    function incompletegammac( a: Double;  x: Double; const _xparams: UInt64 = 0):Double;
    function invincompletegammac( a: Double;  y0: Double; const _xparams: UInt64 = 0):Double;
    function Clone(const Src: Tlrreport):Tlrreport;overload;
    procedure lrbuild( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
    procedure lrbuilds( xy: TMatrix;  s: TVector;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
    procedure lrbuildzs( xy: TMatrix;  s: TVector;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
    procedure lrbuildz( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
    procedure lrunpack( lm: Tlinearmodel; out  v: TVector; out  nvars: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure lrpack( v: TVector;  nvars: TALGLIBInteger; out  lm: Tlinearmodel; const _xparams: UInt64 = 0);
    function lrprocess( lm: Tlinearmodel;  x: TVector; const _xparams: UInt64 = 0):Double;
    function lrrmserror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function lravgerror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function lravgrelerror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure filtersma(var  x: TVector;  n: TALGLIBInteger;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure filtersma(var  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure filterema(var  x: TVector;  n: TALGLIBInteger;  alpha: Double; const _xparams: UInt64 = 0);overload;
    procedure filterema(var  x: TVector;  alpha: Double; const _xparams: UInt64 = 0);overload;
    procedure filterlrma(var  x: TVector;  n: TALGLIBInteger;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure filterlrma(var  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    function Clone(const Src: Tmnlreport):Tmnlreport;overload;
    procedure mnltrainh( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlogitmodel; out  rep: Tmnlreport; const _xparams: UInt64 = 0);
    procedure mnlprocess( lm: Tlogitmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure mnlprocessi( lm: Tlogitmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
    procedure mnlunpack( lm: Tlogitmodel; out  a: TMatrix; out  nvars: TALGLIBInteger; out  nclasses: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure mnlpack( a: TMatrix;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  lm: Tlogitmodel; const _xparams: UInt64 = 0);
    function mnlavgce( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mnlrelclserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mnlrmserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mnlavgerror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mnlavgrelerror( lm: Tlogitmodel;  xy: TMatrix;  ssize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mnlclserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
    function Clone(const Src: Tmcpdreport):Tmcpdreport;overload;
    procedure mcpdcreate( n: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
    procedure mcpdcreateentry( n: TALGLIBInteger;  entrystate: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
    procedure mcpdcreateexit( n: TALGLIBInteger;  exitstate: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
    procedure mcpdcreateentryexit( n: TALGLIBInteger;  entrystate: TALGLIBInteger;  exitstate: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
    procedure mcpdaddtrack( s: Tmcpdstate;  xy: TMatrix;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure mcpdaddtrack( s: Tmcpdstate;  xy: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure mcpdsetec( s: Tmcpdstate;  ec: TMatrix; const _xparams: UInt64 = 0);
    procedure mcpdaddec( s: Tmcpdstate;  i: TALGLIBInteger;  j: TALGLIBInteger;  c: Double; const _xparams: UInt64 = 0);
    procedure mcpdsetbc( s: Tmcpdstate;  bndl: TMatrix;  bndu: TMatrix; const _xparams: UInt64 = 0);
    procedure mcpdaddbc( s: Tmcpdstate;  i: TALGLIBInteger;  j: TALGLIBInteger;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
    procedure mcpdsetlc( s: Tmcpdstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure mcpdsetlc( s: Tmcpdstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    procedure mcpdsettikhonovregularizer( s: Tmcpdstate;  v: Double; const _xparams: UInt64 = 0);
    procedure mcpdsetprior( s: Tmcpdstate;  pp: TMatrix; const _xparams: UInt64 = 0);
    procedure mcpdsetpredictionweights( s: Tmcpdstate;  pw: TVector; const _xparams: UInt64 = 0);
    procedure mcpdsolve( s: Tmcpdstate; const _xparams: UInt64 = 0);
    procedure mcpdresults( s: Tmcpdstate; out  p: TMatrix; out  rep: Tmcpdreport; const _xparams: UInt64 = 0);
    procedure mlpeserialize(const obj: Tmlpensemble; out s_out: AnsiString);overload;
    procedure mlpeunserialize(const s_in: AnsiString; out obj: Tmlpensemble);overload;
    procedure mlpeserialize(const obj: Tmlpensemble; stream: TStream);overload;
    procedure mlpeunserialize(stream: TStream; out obj: Tmlpensemble);overload;
    procedure mlpecreate0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreate1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreate2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreateb0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreateb1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreateb2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreater0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreater1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreater2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreatec0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreatec1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreatec2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpecreatefromnetwork( network: Tmultilayerperceptron;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlperandomize( ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
    procedure mlpeproperties( ensemble: Tmlpensemble; out  nin: TALGLIBInteger; out  nout: TALGLIBInteger; const _xparams: UInt64 = 0);
    function mlpeissoftmax( ensemble: Tmlpensemble; const _xparams: UInt64 = 0):Boolean;
    procedure mlpeprocess( ensemble: Tmlpensemble;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure mlpeprocessi( ensemble: Tmlpensemble;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
    function mlperelclserror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpeavgce( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpermserror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpeavgerror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function mlpeavgrelerror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function Clone(const Src: Tmlpreport):Tmlpreport;overload;
    function Clone(const Src: Tmlpcvreport):Tmlpcvreport;overload;
    procedure mlptrainlm( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
    procedure mlptrainlbfgs( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
    procedure mlptraines( network: Tmultilayerperceptron;  trnxy: TMatrix;  trnsize: TALGLIBInteger;  valxy: TMatrix;  valsize: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
    procedure mlpkfoldcvlbfgs( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger;  foldscount: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  cvrep: Tmlpcvreport; const _xparams: UInt64 = 0);
    procedure mlpkfoldcvlm( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  foldscount: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  cvrep: Tmlpcvreport; const _xparams: UInt64 = 0);
    procedure mlpkfoldcv( s: Tmlptrainer;  network: Tmultilayerperceptron;  nrestarts: TALGLIBInteger;  foldscount: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
    procedure mlpcreatetrainer( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  s: Tmlptrainer; const _xparams: UInt64 = 0);
    procedure mlpcreatetrainercls( nin: TALGLIBInteger;  nclasses: TALGLIBInteger; out  s: Tmlptrainer; const _xparams: UInt64 = 0);
    procedure mlpsetdataset( s: Tmlptrainer;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure mlpsetsparsedataset( s: Tmlptrainer;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure mlpsetdecay( s: Tmlptrainer;  decay: Double; const _xparams: UInt64 = 0);
    procedure mlpsetcond( s: Tmlptrainer;  wstep: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure mlpsetalgobatch( s: Tmlptrainer; const _xparams: UInt64 = 0);
    procedure mlptrainnetwork( s: Tmlptrainer;  network: Tmultilayerperceptron;  nrestarts: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
    procedure mlpstarttraining( s: Tmlptrainer;  network: Tmultilayerperceptron;  randomstart: Boolean; const _xparams: UInt64 = 0);
    function mlpcontinuetraining( s: Tmlptrainer;  network: Tmultilayerperceptron; const _xparams: UInt64 = 0):Boolean;
    procedure mlpebagginglm( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  ooberrors: Tmlpcvreport; const _xparams: UInt64 = 0);
    procedure mlpebagginglbfgs( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  ooberrors: Tmlpcvreport; const _xparams: UInt64 = 0);
    procedure mlpetraines( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
    procedure mlptrainensemblees( s: Tmlptrainer;  ensemble: Tmlpensemble;  nrestarts: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
    function Clone(const Src: Tahcreport):Tahcreport;overload;
    function Clone(const Src: Tkmeansreport):Tkmeansreport;overload;
    procedure clusterizercreate(out  s: Tclusterizerstate; const _xparams: UInt64 = 0);
    procedure clusterizersetpoints( s: Tclusterizerstate;  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger;  disttype: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure clusterizersetpoints( s: Tclusterizerstate;  xy: TMatrix;  disttype: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure clusterizersetdistances( s: Tclusterizerstate;  d: TMatrix;  npoints: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);overload;
    procedure clusterizersetdistances( s: Tclusterizerstate;  d: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);overload;
    procedure clusterizersetahcalgo( s: Tclusterizerstate;  algo: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure clusterizersetkmeanslimits( s: Tclusterizerstate;  restarts: TALGLIBInteger;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure clusterizersetkmeansinit( s: Tclusterizerstate;  initalgo: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure clusterizersetseed( s: Tclusterizerstate;  seed: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure clusterizerrunahc( s: Tclusterizerstate; out  rep: Tahcreport; const _xparams: UInt64 = 0);
    procedure clusterizerrunkmeans( s: Tclusterizerstate;  k: TALGLIBInteger; out  rep: Tkmeansreport; const _xparams: UInt64 = 0);
    procedure clusterizergetdistances( xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger;  disttype: TALGLIBInteger; out  d: TMatrix; const _xparams: UInt64 = 0);
    procedure clusterizergetkclusters( rep: Tahcreport;  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; const _xparams: UInt64 = 0);
    procedure clusterizerseparatedbydist( rep: Tahcreport;  r: Double; out  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; const _xparams: UInt64 = 0);
    procedure clusterizerseparatedbycorr( rep: Tahcreport;  r: Double; out  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; const _xparams: UInt64 = 0);
    function Clone(const Src: Tdfreport):Tdfreport;overload;
    procedure dfserialize(const obj: Tdecisionforest; out s_out: AnsiString);overload;
    procedure dfunserialize(const s_in: AnsiString; out obj: Tdecisionforest);overload;
    procedure dfserialize(const obj: Tdecisionforest; stream: TStream);overload;
    procedure dfunserialize(stream: TStream; out obj: Tdecisionforest);overload;
    procedure dfcreatebuffer( model: Tdecisionforest; out  buf: Tdecisionforestbuffer; const _xparams: UInt64 = 0);
    procedure dfbuildercreate(out  s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
    procedure dfbuildersetdataset( s: Tdecisionforestbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure dfbuildersetrndvars( s: Tdecisionforestbuilder;  rndvars: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure dfbuildersetrndvarsratio( s: Tdecisionforestbuilder;  f: Double; const _xparams: UInt64 = 0);
    procedure dfbuildersetrndvarsauto( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
    procedure dfbuildersetsubsampleratio( s: Tdecisionforestbuilder;  f: Double; const _xparams: UInt64 = 0);
    procedure dfbuildersetseed( s: Tdecisionforestbuilder;  seedval: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure dfbuildersetrdfalgo( s: Tdecisionforestbuilder;  algotype: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure dfbuildersetrdfsplitstrength( s: Tdecisionforestbuilder;  splitstrength: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure dfbuildersetimportancetrngini( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
    procedure dfbuildersetimportanceoobgini( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
    procedure dfbuildersetimportancepermutation( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
    procedure dfbuildersetimportancenone( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
    function dfbuildergetprogress( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0):Double;
    function dfbuilderpeekprogress( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0):Double;
    procedure dfbuilderbuildrandomforest( s: Tdecisionforestbuilder;  ntrees: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; const _xparams: UInt64 = 0);
    function dfbinarycompression( df: Tdecisionforest; const _xparams: UInt64 = 0):Double;
    procedure dfprocess( df: Tdecisionforest;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure dfprocessi( df: Tdecisionforest;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
    function dfprocess0( model: Tdecisionforest;  x: TVector; const _xparams: UInt64 = 0):Double;
    function dfclassify( model: Tdecisionforest;  x: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure dftsprocess( df: Tdecisionforest;  buf: Tdecisionforestbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    function dfrelclserror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function dfavgce( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function dfrmserror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function dfavgerror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function dfavgrelerror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure dfbuildrandomdecisionforest( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger;  ntrees: TALGLIBInteger;  r: Double; out  info: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; const _xparams: UInt64 = 0);
    procedure dfbuildrandomdecisionforestx1( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger;  ntrees: TALGLIBInteger;  nrndvars: TALGLIBInteger;  r: Double; out  info: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; const _xparams: UInt64 = 0);
    function Clone(const Src: Tknnreport):Tknnreport;overload;
    procedure knnserialize(const obj: Tknnmodel; out s_out: AnsiString);overload;
    procedure knnunserialize(const s_in: AnsiString; out obj: Tknnmodel);overload;
    procedure knnserialize(const obj: Tknnmodel; stream: TStream);overload;
    procedure knnunserialize(stream: TStream; out obj: Tknnmodel);overload;
    procedure knncreatebuffer( model: Tknnmodel; out  buf: Tknnbuffer; const _xparams: UInt64 = 0);
    procedure knnbuildercreate(out  s: Tknnbuilder; const _xparams: UInt64 = 0);
    procedure knnbuildersetdatasetreg( s: Tknnbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nout: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure knnbuildersetdatasetcls( s: Tknnbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure knnbuildersetnorm( s: Tknnbuilder;  nrmtype: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure knnbuilderbuildknnmodel( s: Tknnbuilder;  k: TALGLIBInteger;  eps: Double; out  model: Tknnmodel; out  rep: Tknnreport; const _xparams: UInt64 = 0);
    procedure knnrewritekeps( model: Tknnmodel;  k: TALGLIBInteger;  eps: Double; const _xparams: UInt64 = 0);
    procedure knnprocess( model: Tknnmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    function knnprocess0( model: Tknnmodel;  x: TVector; const _xparams: UInt64 = 0):Double;
    function knnclassify( model: Tknnmodel;  x: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
    procedure knnprocessi( model: Tknnmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
    procedure knntsprocess( model: Tknnmodel;  buf: Tknnbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    function knnrelclserror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function knnavgce( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function knnrmserror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function knnavgerror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function knnavgrelerror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure knnallerrors( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; out  rep: Tknnreport; const _xparams: UInt64 = 0);
    procedure kmeansgenerate( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  k: TALGLIBInteger;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TMatrix; out  xyc: TIVector; const _xparams: UInt64 = 0);
    procedure gqgeneraterec( alpha: TVector;  beta: TVector;  mu0: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure gqgenerategausslobattorec( alpha: TVector;  beta: TVector;  mu0: Double;  a: Double;  b: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure gqgenerategaussradaurec( alpha: TVector;  beta: TVector;  mu0: Double;  a: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure gqgenerategausslegendre( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure gqgenerategaussjacobi( n: TALGLIBInteger;  alpha: Double;  beta: Double; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure gqgenerategausslaguerre( n: TALGLIBInteger;  alpha: Double; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure gqgenerategausshermite( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure gkqgeneraterec( alpha: TVector;  beta: TVector;  mu0: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
    procedure gkqgenerategausslegendre( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
    procedure gkqgenerategaussjacobi( n: TALGLIBInteger;  alpha: Double;  beta: Double; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
    procedure gkqlegendrecalc( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
    procedure gkqlegendretbl( n: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; out  eps: Double; const _xparams: UInt64 = 0);
    function Clone(const Src: Tautogkreport):Tautogkreport;overload;
    procedure autogksmooth( a: Double;  b: Double; out  state: Tautogkstate; const _xparams: UInt64 = 0);
    procedure autogksmoothw( a: Double;  b: Double;  xwidth: Double; out  state: Tautogkstate; const _xparams: UInt64 = 0);
    procedure autogksingular( a: Double;  b: Double;  alpha: Double;  beta: Double; out  state: Tautogkstate; const _xparams: UInt64 = 0);
    function autogkiteration( state: Tautogkstate; const _xparams: UInt64 = 0):Boolean;
    procedure autogkintegrate(state: Tautogkstate; func: Tintegrator1_func; obj: Pointer; _xparams: UInt64 = 0);
    procedure autogkresults( state: Tautogkstate; out  v: Double; out  rep: Tautogkreport; const _xparams: UInt64 = 0);
    procedure fftc1d(var  a: TCVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure fftc1d(var  a: TCVector; const _xparams: UInt64 = 0);overload;
    procedure fftc1dinv(var  a: TCVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure fftc1dinv(var  a: TCVector; const _xparams: UInt64 = 0);overload;
    procedure fftr1d( a: TVector;  n: TALGLIBInteger; out  f: TCVector; const _xparams: UInt64 = 0);overload;
    procedure fftr1d( a: TVector; out  f: TCVector; const _xparams: UInt64 = 0);overload;
    procedure fftr1dinv( f: TCVector;  n: TALGLIBInteger; out  a: TVector; const _xparams: UInt64 = 0);overload;
    procedure fftr1dinv( f: TCVector; out  a: TVector; const _xparams: UInt64 = 0);overload;
    procedure fhtr1d(var  a: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure fhtr1dinv(var  a: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure convc1d( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
    procedure convc1dinv( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
    procedure convc1dcircular( s: TCVector;  m: TALGLIBInteger;  r: TCVector;  n: TALGLIBInteger; out  c: TCVector; const _xparams: UInt64 = 0);
    procedure convc1dcircularinv( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
    procedure convr1d( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
    procedure convr1dinv( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
    procedure convr1dcircular( s: TVector;  m: TALGLIBInteger;  r: TVector;  n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
    procedure convr1dcircularinv( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
    procedure corrc1d( signal: TCVector;  n: TALGLIBInteger;  pattern: TCVector;  m: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
    procedure corrc1dcircular( signal: TCVector;  m: TALGLIBInteger;  pattern: TCVector;  n: TALGLIBInteger; out  c: TCVector; const _xparams: UInt64 = 0);
    procedure corrr1d( signal: TVector;  n: TALGLIBInteger;  pattern: TVector;  m: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
    procedure corrr1dcircular( signal: TVector;  m: TALGLIBInteger;  pattern: TVector;  n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
    function Clone(const Src: Tidwreport):Tidwreport;overload;
    procedure idwserialize(const obj: Tidwmodel; out s_out: AnsiString);overload;
    procedure idwunserialize(const s_in: AnsiString; out obj: Tidwmodel);overload;
    procedure idwserialize(const obj: Tidwmodel; stream: TStream);overload;
    procedure idwunserialize(stream: TStream; out obj: Tidwmodel);overload;
    procedure idwcreatecalcbuffer( s: Tidwmodel; out  buf: Tidwcalcbuffer; const _xparams: UInt64 = 0);
    procedure idwbuildercreate( nx: TALGLIBInteger;  ny: TALGLIBInteger; out  state: Tidwbuilder; const _xparams: UInt64 = 0);
    procedure idwbuildersetnlayers( state: Tidwbuilder;  nlayers: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure idwbuildersetpoints( state: Tidwbuilder;  xy: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure idwbuildersetpoints( state: Tidwbuilder;  xy: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure idwbuildersetalgomstab( state: Tidwbuilder;  srad: Double; const _xparams: UInt64 = 0);
    procedure idwbuildersetalgotextbookshepard( state: Tidwbuilder;  p: Double; const _xparams: UInt64 = 0);
    procedure idwbuildersetalgotextbookmodshepard( state: Tidwbuilder;  r: Double; const _xparams: UInt64 = 0);
    procedure idwbuildersetuserterm( state: Tidwbuilder;  v: Double; const _xparams: UInt64 = 0);
    procedure idwbuildersetconstterm( state: Tidwbuilder; const _xparams: UInt64 = 0);
    procedure idwbuildersetzeroterm( state: Tidwbuilder; const _xparams: UInt64 = 0);
    function idwcalc1( s: Tidwmodel;  x0: Double; const _xparams: UInt64 = 0):Double;
    function idwcalc2( s: Tidwmodel;  x0: Double;  x1: Double; const _xparams: UInt64 = 0):Double;
    function idwcalc3( s: Tidwmodel;  x0: Double;  x1: Double;  x2: Double; const _xparams: UInt64 = 0):Double;
    procedure idwcalc( s: Tidwmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
    procedure idwcalcbuf( s: Tidwmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure idwtscalcbuf( s: Tidwmodel;  buf: Tidwcalcbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure idwfit( state: Tidwbuilder; out  model: Tidwmodel; out  rep: Tidwreport; const _xparams: UInt64 = 0);
    function barycentriccalc( b: Tbarycentricinterpolant;  t: Double; const _xparams: UInt64 = 0):Double;
    procedure barycentricdiff1( b: Tbarycentricinterpolant;  t: Double; out  f: Double; out  df: Double; const _xparams: UInt64 = 0);
    procedure barycentricdiff2( b: Tbarycentricinterpolant;  t: Double; out  f: Double; out  df: Double; out  d2f: Double; const _xparams: UInt64 = 0);
    procedure barycentriclintransx( b: Tbarycentricinterpolant;  ca: Double;  cb: Double; const _xparams: UInt64 = 0);
    procedure barycentriclintransy( b: Tbarycentricinterpolant;  ca: Double;  cb: Double; const _xparams: UInt64 = 0);
    procedure barycentricunpack( b: Tbarycentricinterpolant; out  n: TALGLIBInteger; out  x: TVector; out  y: TVector; out  w: TVector; const _xparams: UInt64 = 0);
    procedure barycentricbuildxyw( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger; out  b: Tbarycentricinterpolant; const _xparams: UInt64 = 0);
    procedure barycentricbuildfloaterhormann( x: TVector;  y: TVector;  n: TALGLIBInteger;  d: TALGLIBInteger; out  b: Tbarycentricinterpolant; const _xparams: UInt64 = 0);
    procedure fitspherels( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  r: Double; const _xparams: UInt64 = 0);
    procedure fitspheremc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rhi: Double; const _xparams: UInt64 = 0);
    procedure fitspheremi( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; const _xparams: UInt64 = 0);
    procedure fitspheremz( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
    procedure fitspherex( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger;  problemtype: TALGLIBInteger;  epsx: Double;  aulits: TALGLIBInteger;  penalty: Double; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
    function Clone(const Src: Tspline1dfitreport):Tspline1dfitreport;overload;
    procedure spline1dbuildlinear( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildlinear( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildcubic( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dgriddiffcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  d: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dgriddiffcubic( x: TVector;  y: TVector; out  d: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dgriddiff2cubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  d1: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dgriddiff2cubic( x: TVector;  y: TVector; out  d1: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dconvcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dconvcubic( x: TVector;  y: TVector;  x2: TVector; out  y2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dconvdiffcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dconvdiffcubic( x: TVector;  y: TVector;  x2: TVector; out  y2: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dconvdiff2cubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; out  d2: TVector; out  dd2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dconvdiff2cubic( x: TVector;  y: TVector;  x2: TVector; out  y2: TVector; out  d2: TVector; out  dd2: TVector; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildcatmullrom( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundtype: TALGLIBInteger;  tension: Double; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildcatmullrom( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildhermite( x: TVector;  y: TVector;  d: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildhermite( x: TVector;  y: TVector;  d: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildakima( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildakima( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    function spline1dcalc( c: Tspline1dinterpolant;  x: Double; const _xparams: UInt64 = 0):Double;
    procedure spline1ddiff( c: Tspline1dinterpolant;  x: Double; out  s: Double; out  ds: Double; out  d2s: Double; const _xparams: UInt64 = 0);
    procedure spline1dunpack( c: Tspline1dinterpolant; out  n: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
    procedure spline1dlintransx( c: Tspline1dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
    procedure spline1dlintransy( c: Tspline1dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
    function spline1dintegrate( c: Tspline1dinterpolant;  x: Double; const _xparams: UInt64 = 0):Double;
    procedure spline1dfit( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  lambdans: Double; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfit( x: TVector;  y: TVector;  m: TALGLIBInteger;  lambdans: Double; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildmonotone( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure spline1dbuildmonotone( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
    procedure pspline2build( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline2interpolant; const _xparams: UInt64 = 0);
    procedure pspline3build( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline3interpolant; const _xparams: UInt64 = 0);
    procedure pspline2buildperiodic( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline2interpolant; const _xparams: UInt64 = 0);
    procedure pspline3buildperiodic( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline3interpolant; const _xparams: UInt64 = 0);
    procedure pspline2parametervalues( p: Tpspline2interpolant; out  n: TALGLIBInteger; out  t: TVector; const _xparams: UInt64 = 0);
    procedure pspline3parametervalues( p: Tpspline3interpolant; out  n: TALGLIBInteger; out  t: TVector; const _xparams: UInt64 = 0);
    procedure pspline2calc( p: Tpspline2interpolant;  t: Double; out  x: Double; out  y: Double; const _xparams: UInt64 = 0);
    procedure pspline3calc( p: Tpspline3interpolant;  t: Double; out  x: Double; out  y: Double; out  z: Double; const _xparams: UInt64 = 0);
    procedure pspline2tangent( p: Tpspline2interpolant;  t: Double; out  x: Double; out  y: Double; const _xparams: UInt64 = 0);
    procedure pspline3tangent( p: Tpspline3interpolant;  t: Double; out  x: Double; out  y: Double; out  z: Double; const _xparams: UInt64 = 0);
    procedure pspline2diff( p: Tpspline2interpolant;  t: Double; out  x: Double; out  dx: Double; out  y: Double; out  dy: Double; const _xparams: UInt64 = 0);
    procedure pspline3diff( p: Tpspline3interpolant;  t: Double; out  x: Double; out  dx: Double; out  y: Double; out  dy: Double; out  z: Double; out  dz: Double; const _xparams: UInt64 = 0);
    procedure pspline2diff2( p: Tpspline2interpolant;  t: Double; out  x: Double; out  dx: Double; out  d2x: Double; out  y: Double; out  dy: Double; out  d2y: Double; const _xparams: UInt64 = 0);
    procedure pspline3diff2( p: Tpspline3interpolant;  t: Double; out  x: Double; out  dx: Double; out  d2x: Double; out  y: Double; out  dy: Double; out  d2y: Double; out  z: Double; out  dz: Double; out  d2z: Double; const _xparams: UInt64 = 0);
    function pspline2arclength( p: Tpspline2interpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0):Double;
    function pspline3arclength( p: Tpspline3interpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0):Double;
    procedure parametricrdpfixed( x: TMatrix;  n: TALGLIBInteger;  d: TALGLIBInteger;  stopm: TALGLIBInteger;  stopeps: Double; out  x2: TMatrix; out  idx2: TIVector; out  nsections: TALGLIBInteger; const _xparams: UInt64 = 0);
    function spline3dcalc( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; const _xparams: UInt64 = 0):Double;
    procedure spline3dlintransxyz( c: Tspline3dinterpolant;  ax: Double;  bx: Double;  ay: Double;  by: Double;  az: Double;  bz: Double; const _xparams: UInt64 = 0);
    procedure spline3dlintransf( c: Tspline3dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
    procedure spline3dresampletrilinear( a: TVector;  oldzcount: TALGLIBInteger;  oldycount: TALGLIBInteger;  oldxcount: TALGLIBInteger;  newzcount: TALGLIBInteger;  newycount: TALGLIBInteger;  newxcount: TALGLIBInteger; out  b: TVector; const _xparams: UInt64 = 0);
    procedure spline3dbuildtrilinearv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  z: TVector;  l: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline3dinterpolant; const _xparams: UInt64 = 0);
    procedure spline3dcalcvbuf( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; var  f: TVector; const _xparams: UInt64 = 0);
    procedure spline3dcalcv( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; out  f: TVector; const _xparams: UInt64 = 0);
    procedure spline3dunpackv( c: Tspline3dinterpolant; out  n: TALGLIBInteger; out  m: TALGLIBInteger; out  l: TALGLIBInteger; out  d: TALGLIBInteger; out  stype: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
    procedure polynomialbar2cheb( p: Tbarycentricinterpolant;  a: Double;  b: Double; out  t: TVector; const _xparams: UInt64 = 0);
    procedure polynomialcheb2bar( t: TVector;  n: TALGLIBInteger;  a: Double;  b: Double; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialcheb2bar( t: TVector;  a: Double;  b: Double; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbar2pow( p: Tbarycentricinterpolant;  c: Double;  s: Double; out  a: TVector; const _xparams: UInt64 = 0);overload;
    procedure polynomialbar2pow( p: Tbarycentricinterpolant; out  a: TVector; const _xparams: UInt64 = 0);overload;
    procedure polynomialpow2bar( a: TVector;  n: TALGLIBInteger;  c: Double;  s: Double; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialpow2bar( a: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuild( x: TVector;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuild( x: TVector;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuildeqdist( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuildeqdist( a: Double;  b: Double;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuildcheb1( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuildcheb1( a: Double;  b: Double;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuildcheb2( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    procedure polynomialbuildcheb2( a: Double;  b: Double;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
    function polynomialcalceqdist( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;overload;
    function polynomialcalceqdist( a: Double;  b: Double;  f: TVector;  t: Double; const _xparams: UInt64 = 0):Double;overload;
    function polynomialcalccheb1( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;overload;
    function polynomialcalccheb1( a: Double;  b: Double;  f: TVector;  t: Double; const _xparams: UInt64 = 0):Double;overload;
    function polynomialcalccheb2( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;overload;
    function polynomialcalccheb2( a: Double;  b: Double;  f: TVector;  t: Double; const _xparams: UInt64 = 0):Double;overload;
    function Clone(const Src: Tpolynomialfitreport):Tpolynomialfitreport;overload;
    function Clone(const Src: Tbarycentricfitreport):Tbarycentricfitreport;overload;
    function Clone(const Src: Tlsfitreport):Tlsfitreport;overload;
    procedure lstfitpiecewiselinearrdpfixed( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  x2: TVector; out  y2: TVector; out  nsections: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure lstfitpiecewiselinearrdp( x: TVector;  y: TVector;  n: TALGLIBInteger;  eps: Double; out  x2: TVector; out  y2: TVector; out  nsections: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure polynomialfit( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
    procedure polynomialfit( x: TVector;  y: TVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
    procedure polynomialfitwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
    procedure polynomialfitwc( x: TVector;  y: TVector;  w: TVector;  xc: TVector;  yc: TVector;  dc: TIVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
    function logisticcalc4( x: Double;  a: Double;  b: Double;  c: Double;  d: Double; const _xparams: UInt64 = 0):Double;
    function logisticcalc5( x: Double;  a: Double;  b: Double;  c: Double;  d: Double;  g: Double; const _xparams: UInt64 = 0):Double;
    procedure logisticfit4( x: TVector;  y: TVector;  n: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
    procedure logisticfit4ec( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
    procedure logisticfit5( x: TVector;  y: TVector;  n: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
    procedure logisticfit5ec( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
    procedure logisticfit45x( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double;  is4pl: Boolean;  lambdav: Double;  epsx: Double;  rscnt: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
    procedure barycentricfitfloaterhormannwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  b: Tbarycentricinterpolant; out  rep: Tbarycentricfitreport; const _xparams: UInt64 = 0);
    procedure barycentricfitfloaterhormann( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  b: Tbarycentricinterpolant; out  rep: Tbarycentricfitreport; const _xparams: UInt64 = 0);
    procedure spline1dfitcubicwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfitcubicwc( x: TVector;  y: TVector;  w: TVector;  xc: TVector;  yc: TVector;  dc: TIVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfithermitewc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfithermitewc( x: TVector;  y: TVector;  w: TVector;  xc: TVector;  yc: TVector;  dc: TIVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfitcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfitcubic( x: TVector;  y: TVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfithermite( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfithermite( x: TVector;  y: TVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinearw( y: TVector;  w: TVector;  fmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinearw( y: TVector;  w: TVector;  fmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinearwc( y: TVector;  w: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinearwc( y: TVector;  w: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinear( y: TVector;  fmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinear( y: TVector;  fmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinearc( y: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitlinearc( y: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatewf( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatewf( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatef( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatef( x: TMatrix;  y: TVector;  c: TVector;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatewfg( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatewfg( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatefg( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatefg( x: TMatrix;  y: TVector;  c: TVector;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatewfgh( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatewfgh( x: TMatrix;  y: TVector;  w: TVector;  c: TVector; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatefgh( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitcreatefgh( x: TMatrix;  y: TVector;  c: TVector; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
    procedure lsfitsetcond( state: Tlsfitstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure lsfitsetstpmax( state: Tlsfitstate;  stpmax: Double; const _xparams: UInt64 = 0);
    procedure lsfitsetxrep( state: Tlsfitstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure lsfitsetscale( state: Tlsfitstate;  s: TVector; const _xparams: UInt64 = 0);
    procedure lsfitsetbc( state: Tlsfitstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
    procedure lsfitsetlc( state: Tlsfitstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure lsfitsetlc( state: Tlsfitstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
    function lsfititeration( state: Tlsfitstate; const _xparams: UInt64 = 0):Boolean;
    procedure lsfitfit(state: Tlsfitstate; func: Tndimensional_pfunc; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure lsfitfit(state: Tlsfitstate; func: Tndimensional_pfunc; grad: Tndimensional_pgrad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure lsfitfit(state: Tlsfitstate; func: Tndimensional_pfunc; grad: Tndimensional_pgrad; hess: Tndimensional_phess; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure lsfitresults( state: Tlsfitstate; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
    procedure lsfitsetgradientcheck( state: Tlsfitstate;  teststep: Double; const _xparams: UInt64 = 0);
    function Clone(const Src: Tspline2dfitreport):Tspline2dfitreport;overload;
    procedure spline2dserialize(const obj: Tspline2dinterpolant; out s_out: AnsiString);overload;
    procedure spline2dunserialize(const s_in: AnsiString; out obj: Tspline2dinterpolant);overload;
    procedure spline2dserialize(const obj: Tspline2dinterpolant; stream: TStream);overload;
    procedure spline2dunserialize(stream: TStream; out obj: Tspline2dinterpolant);overload;
    function spline2dcalc( c: Tspline2dinterpolant;  x: Double;  y: Double; const _xparams: UInt64 = 0):Double;
    procedure spline2ddiff( c: Tspline2dinterpolant;  x: Double;  y: Double; out  f: Double; out  fx: Double; out  fy: Double; out  fxy: Double; const _xparams: UInt64 = 0);
    procedure spline2dcalcvbuf( c: Tspline2dinterpolant;  x: Double;  y: Double; var  f: TVector; const _xparams: UInt64 = 0);
    function spline2dcalcvi( c: Tspline2dinterpolant;  x: Double;  y: Double;  i: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    procedure spline2dcalcv( c: Tspline2dinterpolant;  x: Double;  y: Double; out  f: TVector; const _xparams: UInt64 = 0);
    procedure spline2ddiffvi( c: Tspline2dinterpolant;  x: Double;  y: Double;  i: TALGLIBInteger; out  f: Double; out  fx: Double; out  fy: Double; out  fxy: Double; const _xparams: UInt64 = 0);
    procedure spline2dlintransxy( c: Tspline2dinterpolant;  ax: Double;  bx: Double;  ay: Double;  by: Double; const _xparams: UInt64 = 0);
    procedure spline2dlintransf( c: Tspline2dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
    procedure spline2dcopy( c: Tspline2dinterpolant; out  cc: Tspline2dinterpolant; const _xparams: UInt64 = 0);
    procedure spline2dresamplebicubic( a: TMatrix;  oldheight: TALGLIBInteger;  oldwidth: TALGLIBInteger; out  b: TMatrix;  newheight: TALGLIBInteger;  newwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure spline2dresamplebilinear( a: TMatrix;  oldheight: TALGLIBInteger;  oldwidth: TALGLIBInteger; out  b: TMatrix;  newheight: TALGLIBInteger;  newwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure spline2dbuildbilinearv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
    procedure spline2dbuildbicubicv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
    procedure spline2dunpackv( c: Tspline2dinterpolant; out  m: TALGLIBInteger; out  n: TALGLIBInteger; out  d: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
    procedure spline2dbuildbilinear( x: TVector;  y: TVector;  f: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
    procedure spline2dbuildbicubic( x: TVector;  y: TVector;  f: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
    procedure spline2dunpack( c: Tspline2dinterpolant; out  m: TALGLIBInteger; out  n: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
    procedure spline2dbuildercreate( d: TALGLIBInteger; out  state: Tspline2dbuilder; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetuserterm( state: Tspline2dbuilder;  v: Double; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetlinterm( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetconstterm( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetzeroterm( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetpoints( state: Tspline2dbuilder;  xy: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetareaauto( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetarea( state: Tspline2dbuilder;  xa: Double;  xb: Double;  ya: Double;  yb: Double; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetgrid( state: Tspline2dbuilder;  kx: TALGLIBInteger;  ky: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetalgofastddm( state: Tspline2dbuilder;  nlayers: TALGLIBInteger;  lambdav: Double; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetalgoblocklls( state: Tspline2dbuilder;  lambdans: Double; const _xparams: UInt64 = 0);
    procedure spline2dbuildersetalgonaivells( state: Tspline2dbuilder;  lambdans: Double; const _xparams: UInt64 = 0);
    procedure spline2dfit( state: Tspline2dbuilder; out  s: Tspline2dinterpolant; out  rep: Tspline2dfitreport; const _xparams: UInt64 = 0);
    function Clone(const Src: Trbfreport):Trbfreport;overload;
    procedure rbfserialize(const obj: Trbfmodel; out s_out: AnsiString);overload;
    procedure rbfunserialize(const s_in: AnsiString; out obj: Trbfmodel);overload;
    procedure rbfserialize(const obj: Trbfmodel; stream: TStream);overload;
    procedure rbfunserialize(stream: TStream; out obj: Trbfmodel);overload;
    procedure rbfcreate( nx: TALGLIBInteger;  ny: TALGLIBInteger; out  s: Trbfmodel; const _xparams: UInt64 = 0);
    procedure rbfcreatecalcbuffer( s: Trbfmodel; out  buf: Trbfcalcbuffer; const _xparams: UInt64 = 0);
    procedure rbfsetpoints( s: Trbfmodel;  xy: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure rbfsetpoints( s: Trbfmodel;  xy: TMatrix; const _xparams: UInt64 = 0);overload;
    procedure rbfsetpointsandscales( r: Trbfmodel;  xy: TMatrix;  n: TALGLIBInteger;  s: TVector; const _xparams: UInt64 = 0);overload;
    procedure rbfsetpointsandscales( r: Trbfmodel;  xy: TMatrix;  s: TVector; const _xparams: UInt64 = 0);overload;
    procedure rbfsetalgoqnn( s: Trbfmodel;  q: Double;  z: Double; const _xparams: UInt64 = 0);overload;
    procedure rbfsetalgoqnn( s: Trbfmodel; const _xparams: UInt64 = 0);overload;
    procedure rbfsetalgomultilayer( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger;  lambdav: Double; const _xparams: UInt64 = 0);overload;
    procedure rbfsetalgomultilayer( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
    procedure rbfsetalgohierarchical( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger;  lambdans: Double; const _xparams: UInt64 = 0);
    procedure rbfsetlinterm( s: Trbfmodel; const _xparams: UInt64 = 0);
    procedure rbfsetconstterm( s: Trbfmodel; const _xparams: UInt64 = 0);
    procedure rbfsetzeroterm( s: Trbfmodel; const _xparams: UInt64 = 0);
    procedure rbfsetv2bf( s: Trbfmodel;  bf: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rbfsetv2its( s: Trbfmodel;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure rbfsetv2supportr( s: Trbfmodel;  r: Double; const _xparams: UInt64 = 0);
    procedure rbfbuildmodel( s: Trbfmodel; out  rep: Trbfreport; const _xparams: UInt64 = 0);
    function rbfcalc1( s: Trbfmodel;  x0: Double; const _xparams: UInt64 = 0):Double;
    function rbfcalc2( s: Trbfmodel;  x0: Double;  x1: Double; const _xparams: UInt64 = 0):Double;
    function rbfcalc3( s: Trbfmodel;  x0: Double;  x1: Double;  x2: Double; const _xparams: UInt64 = 0):Double;
    procedure rbfcalc( s: Trbfmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
    procedure rbfcalcbuf( s: Trbfmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure rbftscalcbuf( s: Trbfmodel;  buf: Trbfcalcbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
    procedure rbfgridcalc2( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger; out  y: TMatrix; const _xparams: UInt64 = 0);
    procedure rbfgridcalc2v( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger; out  y: TVector; const _xparams: UInt64 = 0);
    procedure rbfgridcalc2vsubset( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  flagy: TBVector; out  y: TVector; const _xparams: UInt64 = 0);
    procedure rbfgridcalc3v( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  x2: TVector;  n2: TALGLIBInteger; out  y: TVector; const _xparams: UInt64 = 0);
    procedure rbfgridcalc3vsubset( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  x2: TVector;  n2: TALGLIBInteger;  flagy: TBVector; out  y: TVector; const _xparams: UInt64 = 0);
    procedure rbfunpack( s: Trbfmodel; out  nx: TALGLIBInteger; out  ny: TALGLIBInteger; out  xwr: TMatrix; out  nc: TALGLIBInteger; out  v: TMatrix; out  modelversion: TALGLIBInteger; const _xparams: UInt64 = 0);
    function rbfgetmodelversion( s: Trbfmodel; const _xparams: UInt64 = 0):TALGLIBInteger;
    function rbfpeekprogress( s: Trbfmodel; const _xparams: UInt64 = 0):Double;
    procedure rbfrequesttermination( s: Trbfmodel; const _xparams: UInt64 = 0);
    procedure nsfitspheremcc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rhi: Double; const _xparams: UInt64 = 0);
    procedure nsfitspheremic( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; const _xparams: UInt64 = 0);
    procedure nsfitspheremzc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
    procedure nsfitspherex( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger;  problemtype: TALGLIBInteger;  epsx: Double;  aulits: TALGLIBInteger;  penalty: Double; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
    procedure spline1dfitpenalized( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfitpenalized( x: TVector;  y: TVector;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfitpenalizedw( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    procedure spline1dfitpenalizedw( x: TVector;  y: TVector;  w: TVector;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
    function ellipticintegralk( m: Double; const _xparams: UInt64 = 0):Double;
    function ellipticintegralkhighprecision( m1: Double; const _xparams: UInt64 = 0):Double;
    function incompleteellipticintegralk( phi: Double;  m: Double; const _xparams: UInt64 = 0):Double;
    function ellipticintegrale( m: Double; const _xparams: UInt64 = 0):Double;
    function incompleteellipticintegrale( phi: Double;  m: Double; const _xparams: UInt64 = 0):Double;
    function hermitecalculate( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function hermitesum( c: TVector;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    procedure hermitecoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
    function dawsonintegral( x: Double; const _xparams: UInt64 = 0):Double;
    procedure sinecosineintegrals( x: Double; out  si: Double; out  ci: Double; const _xparams: UInt64 = 0);
    procedure hyperbolicsinecosineintegrals( x: Double; out  shi: Double; out  chi: Double; const _xparams: UInt64 = 0);
    function poissondistribution( k: TALGLIBInteger;  m: Double; const _xparams: UInt64 = 0):Double;
    function poissoncdistribution( k: TALGLIBInteger;  m: Double; const _xparams: UInt64 = 0):Double;
    function invpoissondistribution( k: TALGLIBInteger;  y: Double; const _xparams: UInt64 = 0):Double;
    function besselj0( x: Double; const _xparams: UInt64 = 0):Double;
    function besselj1( x: Double; const _xparams: UInt64 = 0):Double;
    function besseljn( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function bessely0( x: Double; const _xparams: UInt64 = 0):Double;
    function bessely1( x: Double; const _xparams: UInt64 = 0):Double;
    function besselyn( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function besseli0( x: Double; const _xparams: UInt64 = 0):Double;
    function besseli1( x: Double; const _xparams: UInt64 = 0):Double;
    function besselk0( x: Double; const _xparams: UInt64 = 0):Double;
    function besselk1( x: Double; const _xparams: UInt64 = 0):Double;
    function besselkn( nn: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function incompletebeta( a: Double;  b: Double;  x: Double; const _xparams: UInt64 = 0):Double;
    function invincompletebeta( a: Double;  b: Double;  y: Double; const _xparams: UInt64 = 0):Double;
    function fdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function fcdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function invfdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  y: Double; const _xparams: UInt64 = 0):Double;
    procedure fresnelintegral( x: Double; var  c: Double; var  s: Double; const _xparams: UInt64 = 0);
    procedure jacobianellipticfunctions( u: Double;  m: Double; out  sn: Double; out  cn: Double; out  dn: Double; out  ph: Double; const _xparams: UInt64 = 0);
    function psi( x: Double; const _xparams: UInt64 = 0):Double;
    function exponentialintegralei( x: Double; const _xparams: UInt64 = 0):Double;
    function exponentialintegralen( x: Double;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
    function laguerrecalculate( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function laguerresum( c: TVector;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    procedure laguerrecoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
    function chisquaredistribution( v: Double;  x: Double; const _xparams: UInt64 = 0):Double;
    function chisquarecdistribution( v: Double;  x: Double; const _xparams: UInt64 = 0):Double;
    function invchisquaredistribution( v: Double;  y: Double; const _xparams: UInt64 = 0):Double;
    function legendrecalculate( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function legendresum( c: TVector;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    procedure legendrecoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
    function beta( a: Double;  b: Double; const _xparams: UInt64 = 0):Double;
    function chebyshevcalculate( r: TALGLIBInteger;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    function chebyshevsum( c: TVector;  r: TALGLIBInteger;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
    procedure chebyshevcoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
    procedure fromchebyshev( a: TVector;  n: TALGLIBInteger; out  b: TVector; const _xparams: UInt64 = 0);
    function studenttdistribution( k: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;
    function invstudenttdistribution( k: TALGLIBInteger;  p: Double; const _xparams: UInt64 = 0):Double;
    function binomialdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  p: Double; const _xparams: UInt64 = 0):Double;
    function binomialcdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  p: Double; const _xparams: UInt64 = 0):Double;
    function invbinomialdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  y: Double; const _xparams: UInt64 = 0):Double;
    procedure airy( x: Double; out  ai: Double; out  aip: Double; out  bi: Double; out  bip: Double; const _xparams: UInt64 = 0);
    procedure wilcoxonsignedranktest( x: TVector;  n: TALGLIBInteger;  e: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure onesamplesigntest( x: TVector;  n: TALGLIBInteger;  median: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure pearsoncorrelationsignificance( r: Double;  n: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure spearmanrankcorrelationsignificance( r: Double;  n: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure studentttest1( x: TVector;  n: TALGLIBInteger;  mean: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure studentttest2( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure unequalvariancettest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure mannwhitneyutest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure jarqueberatest( x: TVector;  n: TALGLIBInteger; out  p: Double; const _xparams: UInt64 = 0);
    procedure ftest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    procedure onesamplevariancetest( x: TVector;  n: TALGLIBInteger;  variance: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
    function rmatrixschur(var  a: TMatrix;  n: TALGLIBInteger; out  s: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function smatrixgevd( a: TMatrix;  n: TALGLIBInteger;  isuppera: Boolean;  b: TMatrix;  isupperb: Boolean;  zneeded: TALGLIBInteger;  problemtype: TALGLIBInteger; out  d: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
    function smatrixgevdreduce(var  a: TMatrix;  n: TALGLIBInteger;  isuppera: Boolean;  b: TMatrix;  isupperb: Boolean;  problemtype: TALGLIBInteger; out  r: TMatrix; out  isupperr: Boolean; const _xparams: UInt64 = 0):Boolean;
    procedure rmatrixinvupdatesimple(var  inva: TMatrix;  n: TALGLIBInteger;  updrow: TALGLIBInteger;  updcolumn: TALGLIBInteger;  updval: Double; const _xparams: UInt64 = 0);
    procedure rmatrixinvupdaterow(var  inva: TMatrix;  n: TALGLIBInteger;  updrow: TALGLIBInteger;  v: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixinvupdatecolumn(var  inva: TMatrix;  n: TALGLIBInteger;  updcolumn: TALGLIBInteger;  u: TVector; const _xparams: UInt64 = 0);
    procedure rmatrixinvupdateuv(var  inva: TMatrix;  n: TALGLIBInteger;  u: TVector;  v: TVector; const _xparams: UInt64 = 0);
    function rmatrixludet( a: TMatrix;  pivots: TIVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function rmatrixludet( a: TMatrix;  pivots: TIVector; const _xparams: UInt64 = 0):Double;overload;
    function rmatrixdet( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function rmatrixdet( a: TMatrix; const _xparams: UInt64 = 0):Double;overload;
    function cmatrixludet( a: TCMatrix;  pivots: TIVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Complex;overload;
    function cmatrixludet( a: TCMatrix;  pivots: TIVector; const _xparams: UInt64 = 0):Complex;overload;
    function cmatrixdet( a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Complex;overload;
    function cmatrixdet( a: TCMatrix; const _xparams: UInt64 = 0):Complex;overload;
    function spdmatrixcholeskydet( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
    function spdmatrixcholeskydet( a: TMatrix; const _xparams: UInt64 = 0):Double;overload;
    function spdmatrixdet( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;overload;
    function spdmatrixdet( a: TMatrix; const _xparams: UInt64 = 0):Double;overload;
    function Clone(const Src: Tpolynomialsolverreport):Tpolynomialsolverreport;overload;
    procedure polynomialsolve( a: TVector;  n: TALGLIBInteger; out  x: TCVector; out  rep: Tpolynomialsolverreport; const _xparams: UInt64 = 0);
    function Clone(const Src: Tnleqreport):Tnleqreport;overload;
    procedure nleqcreatelm( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tnleqstate; const _xparams: UInt64 = 0);overload;
    procedure nleqcreatelm( m: TALGLIBInteger;  x: TVector; out  state: Tnleqstate; const _xparams: UInt64 = 0);overload;
    procedure nleqsetcond( state: Tnleqstate;  epsf: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure nleqsetxrep( state: Tnleqstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
    procedure nleqsetstpmax( state: Tnleqstate;  stpmax: Double; const _xparams: UInt64 = 0);
    function nleqiteration( state: Tnleqstate; const _xparams: UInt64 = 0):Boolean;
    procedure nleqsolve(state: Tnleqstate; func: Tndimensional_func; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
    procedure nleqresults( state: Tnleqstate; out  x: TVector; out  rep: Tnleqreport; const _xparams: UInt64 = 0);
    procedure nleqresultsbuf( state: Tnleqstate; var  x: TVector;  rep: Tnleqreport; const _xparams: UInt64 = 0);
    procedure nleqrestartfrom( state: Tnleqstate;  x: TVector; const _xparams: UInt64 = 0);
    function Clone(const Src: Tsparsesolverreport):Tsparsesolverreport;overload;
    procedure sparsesolvesks( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  rep: Tsparsesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
    procedure sparsecholeskysolvesks( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  rep: Tsparsesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
    procedure sparsesolve( a: Tsparsematrix;  n: TALGLIBInteger;  b: TVector; out  x: TVector; out  rep: Tsparsesolverreport; const _xparams: UInt64 = 0);
    procedure sparselusolve( a: Tsparsematrix;  p: TIVector;  q: TIVector;  n: TALGLIBInteger;  b: TVector; out  x: TVector; out  rep: Tsparsesolverreport; const _xparams: UInt64 = 0);
    function Clone(const Src: Tlincgreport):Tlincgreport;overload;
    procedure lincgcreate( n: TALGLIBInteger; out  state: Tlincgstate; const _xparams: UInt64 = 0);
    procedure lincgsetstartingpoint( state: Tlincgstate;  x: TVector; const _xparams: UInt64 = 0);
    procedure lincgsetprecunit( state: Tlincgstate; const _xparams: UInt64 = 0);
    procedure lincgsetprecdiag( state: Tlincgstate; const _xparams: UInt64 = 0);
    procedure lincgsetcond( state: Tlincgstate;  epsf: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure lincgsolvesparse( state: Tlincgstate;  a: Tsparsematrix;  isupper: Boolean;  b: TVector; const _xparams: UInt64 = 0);
    procedure lincgresults( state: Tlincgstate; out  x: TVector; out  rep: Tlincgreport; const _xparams: UInt64 = 0);
    procedure lincgsetrestartfreq( state: Tlincgstate;  srf: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure lincgsetrupdatefreq( state: Tlincgstate;  freq: TALGLIBInteger; const _xparams: UInt64 = 0);
    procedure lincgsetxrep( state: Tlincgstate;  needxrep: Boolean; const _xparams: UInt64 = 0);


(*************************************************************************
This function sets number of worker threads used by  ALGLIB  multithreaded
framework.

Following values are accepted:
* nworkers=0    use all available cores
* nworkers=k>0  use k cores
* nworkers=-k   use all available cores except for k ones (say,  -1  means
                one core will be left free).

  -- ALGLIB --
*************************************************************************)
procedure SetNWorkers(nworkers: Integer);
procedure SetGlobalThreading(xparams: UInt64);
function  GetCoresCount():Integer;
function  GetNWorkers():Integer;
function  GetGlobalThreading():UInt64;

(*************************************************************************
Debug functions
*************************************************************************)
function  x_alloc_counter():Int64;
procedure x_alloc_counter_activate();
procedure x_free_disposed_items();

(*************************************************************************
Cloning functions for basic vector/matrix types
*************************************************************************)
function Clone(const A: TIVector):TIVector;overload;
function Clone(const A: TVector):TVector;overload;
function Clone(const A: TCVector):TCVector;overload;
function Clone(const A: TBVector):TBVector;overload;
function Clone(const A: TIMatrix):TIMatrix;overload;
function Clone(const A: TMatrix):TMatrix;overload;
function Clone(const A: TCMatrix):TCMatrix;overload;
function Clone(const A: TBMatrix):TBMatrix;overload;

(*************************************************************************
Complex math
*************************************************************************)
{$IFDEF FPC}
operator :=(R: Double) Z:Complex;
{$ENDIF}
function C_Complex(X : Double):Complex;overload;
function C_Complex(X, Y: Double):Complex;overload;
function C_Complex(Z: Complex):Complex;overload;
function C_Opposite(const Z : Complex):Complex;
function C_Add(const Z1 : Complex; const Z2 : Complex):Complex;
function C_Mul(const Z1 : Complex; const Z2 : Complex):Complex;
function C_AddR(const Z1 : Complex; const R : Double):Complex;
function C_MulR(const Z1 : Complex; const R : Double):Complex;
function C_Sub(const Z1 : Complex; const Z2 : Complex):Complex;
function C_SubR(const Z1 : Complex; const R : Double):Complex;
function C_RSub(const R : Double; const Z1 : Complex):Complex;
function C_Div(const Z1 : Complex; const Z2 : Complex):Complex;
function C_DivR(const Z1 : Complex; const R : Double):Complex;
function C_RDiv(const R : Double; const Z2 : Complex):Complex;
function C_Equal(const Z1 : Complex; const Z2 : Complex):Boolean;
function C_NotEqual(const Z1 : Complex; const Z2 : Complex):Boolean;
function C_EqualR(const Z1 : Complex; const R : Double):Boolean;
function C_NotEqualR(const Z1 : Complex; const R : Double):Boolean;

function C_Abs(const Z : Complex):Double;
function C_Conj(const Z : Complex):Complex;
function C_Sqr(const Z : Complex):Complex;

(*************************************************************************
Array construction from string
*************************************************************************)
function Str2BVector(S: string):TBVector;
function Str2IVector(S: string):TIVector;
function Str2Vector( S: string):TVector;
function Str2CVector(S: string):TCVector;
function Str2BMatrix(S: string):TBMatrix;
function Str2IMatrix(S: string):TIMatrix;
function Str2Matrix( S: string):TMatrix;
function Str2CMatrix(S: string):TCMatrix;

(*************************************************************************
Array formatting
*************************************************************************)
function FormatComplex(const V: Complex; Dps: Integer):string;
function FormatVector(const V: TBVector; Dps: Integer):string;overload;
function FormatVector(const V: TIVector; Dps: Integer):string;overload;
function FormatVector(const V: TVector;  Dps: Integer):string;overload;
function FormatVector(const V: TCVector; Dps: Integer):string;overload;
function FormatMatrix(const V: TBMatrix; Dps: Integer):string;overload;
function FormatMatrix(const V: TIMatrix; Dps: Integer):string;overload;
function FormatMatrix(const V: TMatrix;  Dps: Integer):string;overload;
function FormatMatrix(const V: TCMatrix; Dps: Integer):string;overload;

function XLen(const A: TVector):TALGLIBInteger;overload;
function XLen(const A: TIVector):TALGLIBInteger;overload;
function XLen(const A: TCVector):TALGLIBInteger;overload;
function XLen(const A: TBVector):TALGLIBInteger;overload;
function XRows(const A: TMatrix):TALGLIBInteger;overload;
function XRows(const A: TIMatrix):TALGLIBInteger;overload;
function XRows(const A: TCMatrix):TALGLIBInteger;overload;
function XRows(const A: TBMatrix):TALGLIBInteger;overload;
function XCols(const A: TMatrix):TALGLIBInteger;overload;
function XCols(const A: TIMatrix):TALGLIBInteger;overload;
function XCols(const A: TCMatrix):TALGLIBInteger;overload;
function XCols(const A: TBMatrix):TALGLIBInteger;overload;

implementation

{$IFDEF FPC}
uses {$IFDEF MSWINDOWS}Windows{$ELSE}Dynlibs{$ENDIF}, Math, StrUtils;
{$ELSE}
uses {$IFDEF MSWINDOWS}Windows{$ELSE}SysUtils{$ENDIF}, Math, StrUtils, AnsiStrings;
{$ENDIF}

type
{$IFDEF FPC}
    XCharType   = AnsiChar;
    XPCharType  = PAnsiChar;
    XStringType = AnsiString;
    XExceptionMask=TFPUExceptionMask;
{$ELSE}
    XCharType   = WideChar;
    XPCharType  = PWideChar;
    XStringType = String;
    XExceptionMask=TArithmeticExceptionMask;
{$ENDIF}
    TSVector            = array of AnsiString;
    TSMatrix            = array of array of AnsiString;
    Int32T              = Int32;
    Int64T              = Int64;
    UInt64T             = UInt64;
    PtrIntT             = NativeInt;
    TSharedLibHandle    = NativeInt;
    PPAnsiChar          = ^PAnsiChar;
    TXActivateCoreFunc  = procedure ();cdecl;
    TXMallocFunc        = function (PP: Pointer; Size: Int64T):Int32T;cdecl;
    TXFreeFunc          = function (PP: Pointer):Int32T;cdecl;
    TXSetNWorkersFunc   = function (N: Int64T):Byte;cdecl;
    TXSetDbgFlag        = procedure (FlagID, FlagValue: Int64T);cdecl;
    TXGetDbgValue       = function (FlagID: Int64T):Int64T;cdecl;
    TXAllocCounterFunc  = function ():Int64T;cdecl;
    TXAllocCounterActivateFunc  = procedure();cdecl;
    TXFreeDisposedItemsFunc     = procedure();cdecl;
    
    x_int = record
        case Integer of
            0 : (val:  TALGLIBInteger) ;
            1 : (longval: Int64T) ;
    end;
    
    x_ptr = record
        case Integer of
            0 : (ptr:  Pointer) ;
            1 : (alignment_enforcer: Int64T) ;
    end;
    
    x_vector = record
        cnt:        UInt64T;
        datatype:   UInt64T;
        owner:      UInt64T;
        last_action:UInt64T;
        xptr:       x_ptr;
    end;
    
    x_matrix = record
        rows:       UInt64T;
        cols:       UInt64T;
        stride:     UInt64T;
        datatype:   UInt64T;
        owner:      UInt64T;
        last_action:UInt64T;
        xptr:       x_ptr;
    end;
    
    px_int    = ^x_int;
    px_vector = ^x_vector;
    px_matrix = ^x_matrix;
    
    Tx_obj_copy_kdtreerequestbuffer = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_kdtreerequestbuffer = procedure(x: Pointer);cdecl;
    Tx_obj_copy_kdtree = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_kdtree = procedure(x: Pointer);cdecl;
    Tkdtreeserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Tkdtreeunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Tkdtreeserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Tkdtreeunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Tkdtreebuild = function(error_msg: PPAnsiChar; xy: px_matrix; n: PNativeInt; nx: PNativeInt; ny: PNativeInt; normtype: PNativeInt; kdt: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tkdtreebuildtagged = function(error_msg: PPAnsiChar; xy: px_matrix; tags: px_vector; n: PNativeInt; nx: PNativeInt; ny: PNativeInt; normtype: PNativeInt; kdt: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tkdtreecreaterequestbuffer = function(error_msg: PPAnsiChar; kdt: PPointer; buf: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryknn = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; x: px_vector; k: PNativeInt; selfmatch: PByte; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryknn = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; buf: PPointer; x: px_vector; k: PNativeInt; selfmatch: PByte; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryrnn = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; x: px_vector; r: PDouble; selfmatch: PByte; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryrnnu = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; x: px_vector; r: PDouble; selfmatch: PByte; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryrnn = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; buf: PPointer; x: px_vector; r: PDouble; selfmatch: PByte; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryrnnu = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; buf: PPointer; x: px_vector; r: PDouble; selfmatch: PByte; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryaknn = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; x: px_vector; k: PNativeInt; selfmatch: PByte; eps: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryaknn = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; buf: PPointer; x: px_vector; k: PNativeInt; selfmatch: PByte; eps: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequerybox = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; boxmin: px_vector; boxmax: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsquerybox = function(error_msg: PPAnsiChar; result: PNativeInt; kdt: PPointer; buf: PPointer; boxmin: px_vector; boxmax: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultsx = function(error_msg: PPAnsiChar; kdt: PPointer; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultsxy = function(error_msg: PPAnsiChar; kdt: PPointer; xy: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultstags = function(error_msg: PPAnsiChar; kdt: PPointer; tags: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultsdistances = function(error_msg: PPAnsiChar; kdt: PPointer; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryresultsx = function(error_msg: PPAnsiChar; kdt: PPointer; buf: PPointer; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryresultsxy = function(error_msg: PPAnsiChar; kdt: PPointer; buf: PPointer; xy: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryresultstags = function(error_msg: PPAnsiChar; kdt: PPointer; buf: PPointer; tags: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tkdtreetsqueryresultsdistances = function(error_msg: PPAnsiChar; kdt: PPointer; buf: PPointer; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultsxi = function(error_msg: PPAnsiChar; kdt: PPointer; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultsxyi = function(error_msg: PPAnsiChar; kdt: PPointer; xy: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultstagsi = function(error_msg: PPAnsiChar; kdt: PPointer; tags: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tkdtreequeryresultsdistancesi = function(error_msg: PPAnsiChar; kdt: PPointer; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_hqrndstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_hqrndstate = procedure(x: Pointer);cdecl;
    Thqrndrandomize = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Thqrndseed = function(error_msg: PPAnsiChar; s1: PNativeInt; s2: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Thqrnduniformr = function(error_msg: PPAnsiChar; result: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Thqrnduniformi = function(error_msg: PPAnsiChar; result: PNativeInt; state: PPointer; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Thqrndnormal = function(error_msg: PPAnsiChar; result: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Thqrndunit2 = function(error_msg: PPAnsiChar; state: PPointer; x: PDouble; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Thqrndnormal2 = function(error_msg: PPAnsiChar; state: PPointer; x1: PDouble; x2: PDouble; _xparams: UInt64):Int32T;cdecl;
    Thqrndexponential = function(error_msg: PPAnsiChar; result: PDouble; state: PPointer; lambdav: PDouble; _xparams: UInt64):Int32T;cdecl;
    Thqrnddiscrete = function(error_msg: PPAnsiChar; result: PDouble; state: PPointer; x: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Thqrndcontinuous = function(error_msg: PPAnsiChar; result: PDouble; state: PPointer; x: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;

    x_xdebugrecord1 = record
         i: x_int;
         c: Complex;
         a: x_vector;
    end;
    px_xdebugrecord1 = ^x_xdebugrecord1;
    Txdebuginitrecord1 = function(error_msg: PPAnsiChar; rec1: px_xdebugrecord1; _xparams: UInt64):Int32T;cdecl;
    Txdebugb1count = function(error_msg: PPAnsiChar; result: PNativeInt; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugb1not = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugb1appendcopy = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugb1outeven = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugi1sum = function(error_msg: PPAnsiChar; result: PNativeInt; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugi1neg = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugi1appendcopy = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugi1outeven = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugr1sum = function(error_msg: PPAnsiChar; result: PDouble; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugr1neg = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugr1appendcopy = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugr1outeven = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugc1sum = function(error_msg: PPAnsiChar; result: PComplex; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugc1neg = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugc1appendcopy = function(error_msg: PPAnsiChar; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugc1outeven = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Txdebugb2count = function(error_msg: PPAnsiChar; result: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugb2not = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugb2transpose = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugb2outsin = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugi2sum = function(error_msg: PPAnsiChar; result: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugi2neg = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugi2transpose = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugi2outsin = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugr2sum = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugr2neg = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugr2transpose = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugr2outsin = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugc2sum = function(error_msg: PPAnsiChar; result: PComplex; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugc2neg = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugc2transpose = function(error_msg: PPAnsiChar; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugc2outsincos = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Txdebugmaskedbiasedproductsum = function(error_msg: PPAnsiChar; result: PDouble; m: PNativeInt; n: PNativeInt; a: px_matrix; b: px_matrix; c: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_odesolverstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_odesolverstate = procedure(x: Pointer);cdecl;
    Tx_odesolverstate_get_needdy = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_odesolverstate_set_needdy = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_odesolverstate_get_y = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_odesolverstate_get_dy = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_odesolverstate_get_x = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_odesolverstate_set_x = function(x: Pointer; src: PDouble):Int32T;cdecl;

    x_odesolverreport = record
         nfev: x_int;
         terminationtype: x_int;
    end;
    px_odesolverreport = ^x_odesolverreport;
    Todesolverrkck = function(error_msg: PPAnsiChar; y: px_vector; n: PNativeInt; x: px_vector; m: PNativeInt; eps: PDouble; h: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Todesolveriteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Todesolverresults = function(error_msg: PPAnsiChar; state: PPointer; m: PNativeInt; xtbl: px_vector; ytbl: px_matrix; rep: px_odesolverreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_sparsematrix = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_sparsematrix = procedure(x: Pointer);cdecl;
    Tx_obj_copy_sparsebuffers = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_sparsebuffers = procedure(x: Pointer);cdecl;
    Tsparsecreate = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; k: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecreatebuf = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; k: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecreatecrs = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; ner: px_vector; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecreatecrsbuf = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; ner: px_vector; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecreatesks = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; d: px_vector; u: px_vector; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecreatesksbuf = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; d: px_vector; u: px_vector; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecreatesksband = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; bw: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecreatesksbandbuf = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; bw: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopy = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopybuf = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseswap = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseadd = function(error_msg: PPAnsiChar; s: PPointer; i: PNativeInt; j: PNativeInt; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsparseset = function(error_msg: PPAnsiChar; s: PPointer; i: PNativeInt; j: PNativeInt; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsparseget = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; i: PNativeInt; j: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetdiagonal = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; i: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsparsemv = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsemtv = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsegemv = function(error_msg: PPAnsiChar; s: PPointer; alpha: PDouble; ops: PNativeInt; x: px_vector; ix: PNativeInt; beta: PDouble; y: px_vector; iy: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsparsemv2 = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; y0: px_vector; y1: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsesmv = function(error_msg: PPAnsiChar; s: PPointer; isupper: PByte; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsevsmv = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; isupper: PByte; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsemm = function(error_msg: PPAnsiChar; s: PPointer; a: px_matrix; k: PNativeInt; b: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsparsemtm = function(error_msg: PPAnsiChar; s: PPointer; a: px_matrix; k: PNativeInt; b: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsparsemm2 = function(error_msg: PPAnsiChar; s: PPointer; a: px_matrix; k: PNativeInt; b0: px_matrix; b1: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsparsesmm = function(error_msg: PPAnsiChar; s: PPointer; isupper: PByte; a: px_matrix; k: PNativeInt; b: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsparsetrmv = function(error_msg: PPAnsiChar; s: PPointer; isupper: PByte; isunit: PByte; optype: PNativeInt; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsetrsv = function(error_msg: PPAnsiChar; s: PPointer; isupper: PByte; isunit: PByte; optype: PNativeInt; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparseresizematrix = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseenumerate = function(error_msg: PPAnsiChar; result: PByte; s: PPointer; t0: PNativeInt; t1: PNativeInt; i: PNativeInt; j: PNativeInt; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsparserewriteexisting = function(error_msg: PPAnsiChar; result: PByte; s: PPointer; i: PNativeInt; j: PNativeInt; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetrow = function(error_msg: PPAnsiChar; s: PPointer; i: PNativeInt; irow: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetcompressedrow = function(error_msg: PPAnsiChar; s: PPointer; i: PNativeInt; colidx: px_vector; vals: px_vector; nzcnt: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsparsetransposesks = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsetransposecrs = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytransposecrs = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytransposecrsbuf = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseconvertto = function(error_msg: PPAnsiChar; s0: PPointer; fmt: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytobuf = function(error_msg: PPAnsiChar; s0: PPointer; fmt: PNativeInt; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseconverttohash = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytohash = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytohashbuf = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseconverttocrs = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytocrs = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytocrsbuf = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseconverttosks = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytosks = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsecopytosksbuf = function(error_msg: PPAnsiChar; s0: PPointer; s1: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetmatrixtype = function(error_msg: PPAnsiChar; result: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseishash = function(error_msg: PPAnsiChar; result: PByte; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseiscrs = function(error_msg: PPAnsiChar; result: PByte; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparseissks = function(error_msg: PPAnsiChar; result: PByte; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsefree = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetnrows = function(error_msg: PPAnsiChar; result: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetncols = function(error_msg: PPAnsiChar; result: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetuppercount = function(error_msg: PPAnsiChar; result: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tsparsegetlowercount = function(error_msg: PPAnsiChar; result: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixtranspose = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; b: px_matrix; ib: PNativeInt; jb: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixtranspose = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; b: px_matrix; ib: PNativeInt; jb: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixenforcesymmetricity = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixcopy = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; b: px_matrix; ib: PNativeInt; jb: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trvectorcopy = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_vector; ia: PNativeInt; b: px_vector; ib: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixcopy = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; b: px_matrix; ib: PNativeInt; jb: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixgencopy = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; alpha: PDouble; a: px_matrix; ia: PNativeInt; ja: PNativeInt; beta: PDouble; b: px_matrix; ib: PNativeInt; jb: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixger = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; alpha: PDouble; u: px_vector; iu: PNativeInt; v: px_vector; iv: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrank1 = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; u: px_vector; iu: PNativeInt; v: px_vector; iv: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrank1 = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; u: px_vector; iu: PNativeInt; v: px_vector; iv: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixgemv = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; alpha: PDouble; a: px_matrix; ia: PNativeInt; ja: PNativeInt; opa: PNativeInt; x: px_vector; ix: PNativeInt; beta: PDouble; y: px_vector; iy: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixmv = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; opa: PNativeInt; x: px_vector; ix: PNativeInt; y: px_vector; iy: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixmv = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; opa: PNativeInt; x: px_vector; ix: PNativeInt; y: px_vector; iy: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsymv = function(error_msg: PPAnsiChar; n: PNativeInt; alpha: PDouble; a: px_matrix; ia: PNativeInt; ja: PNativeInt; isupper: PByte; x: px_vector; ix: PNativeInt; beta: PDouble; y: px_vector; iy: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsyvmv = function(error_msg: PPAnsiChar; result: PDouble; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; isupper: PByte; x: px_vector; ix: PNativeInt; tmp: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixtrsv = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_matrix; ia: PNativeInt; ja: PNativeInt; isupper: PByte; isunit: PByte; optype: PNativeInt; x: px_vector; ix: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrighttrsm = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; i1: PNativeInt; j1: PNativeInt; isupper: PByte; isunit: PByte; optype: PNativeInt; x: px_matrix; i2: PNativeInt; j2: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlefttrsm = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; i1: PNativeInt; j1: PNativeInt; isupper: PByte; isunit: PByte; optype: PNativeInt; x: px_matrix; i2: PNativeInt; j2: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrighttrsm = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; i1: PNativeInt; j1: PNativeInt; isupper: PByte; isunit: PByte; optype: PNativeInt; x: px_matrix; i2: PNativeInt; j2: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlefttrsm = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; a: px_matrix; i1: PNativeInt; j1: PNativeInt; isupper: PByte; isunit: PByte; optype: PNativeInt; x: px_matrix; i2: PNativeInt; j2: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixherk = function(error_msg: PPAnsiChar; n: PNativeInt; k: PNativeInt; alpha: PDouble; a: px_matrix; ia: PNativeInt; ja: PNativeInt; optypea: PNativeInt; beta: PDouble; c: px_matrix; ic: PNativeInt; jc: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsyrk = function(error_msg: PPAnsiChar; n: PNativeInt; k: PNativeInt; alpha: PDouble; a: px_matrix; ia: PNativeInt; ja: PNativeInt; optypea: PNativeInt; beta: PDouble; c: px_matrix; ic: PNativeInt; jc: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixgemm = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; k: PNativeInt; alpha: PComplex; a: px_matrix; ia: PNativeInt; ja: PNativeInt; optypea: PNativeInt; b: px_matrix; ib: PNativeInt; jb: PNativeInt; optypeb: PNativeInt; beta: PComplex; c: px_matrix; ic: PNativeInt; jc: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixgemm = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; k: PNativeInt; alpha: PDouble; a: px_matrix; ia: PNativeInt; ja: PNativeInt; optypea: PNativeInt; b: px_matrix; ib: PNativeInt; jb: PNativeInt; optypeb: PNativeInt; beta: PDouble; c: px_matrix; ic: PNativeInt; jc: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixsyrk = function(error_msg: PPAnsiChar; n: PNativeInt; k: PNativeInt; alpha: PDouble; a: px_matrix; ia: PNativeInt; ja: PNativeInt; optypea: PNativeInt; beta: PDouble; c: px_matrix; ic: PNativeInt; jc: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrndorthogonal = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrndcond = function(error_msg: PPAnsiChar; n: PNativeInt; c: PDouble; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrndorthogonal = function(error_msg: PPAnsiChar; n: PNativeInt; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrndcond = function(error_msg: PPAnsiChar; n: PNativeInt; c: PDouble; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixrndcond = function(error_msg: PPAnsiChar; n: PNativeInt; c: PDouble; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixrndcond = function(error_msg: PPAnsiChar; n: PNativeInt; c: PDouble; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thmatrixrndcond = function(error_msg: PPAnsiChar; n: PNativeInt; c: PDouble; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixrndcond = function(error_msg: PPAnsiChar; n: PNativeInt; c: PDouble; a: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrndorthogonalfromtheright = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrndorthogonalfromtheleft = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrndorthogonalfromtheright = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrndorthogonalfromtheleft = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixrndmultiply = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Thmatrixrndmultiply = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlu = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; pivots: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlu = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; pivots: px_vector; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixcholesky = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholesky = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskyupdateadd1 = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; u: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskyupdatefix = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; fix: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskyupdateadd1buf = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; u: px_vector; bufr: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskyupdatefixbuf = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; fix: px_vector; bufr: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparselu = function(error_msg: PPAnsiChar; result: PByte; a: PPointer; pivottype: PNativeInt; p: px_vector; q: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsecholeskyskyline = function(error_msg: PPAnsiChar; result: PByte; a: PPointer; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrcond1 = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixrcondinf = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixrcond = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixtrrcond1 = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; isunit: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixtrrcondinf = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; isunit: PByte; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixrcond = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrcond1 = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixrcondinf = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlurcond1 = function(error_msg: PPAnsiChar; result: PDouble; lua: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlurcondinf = function(error_msg: PPAnsiChar; result: PDouble; lua: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskyrcond = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixcholeskyrcond = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlurcond1 = function(error_msg: PPAnsiChar; result: PDouble; lua: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlurcondinf = function(error_msg: PPAnsiChar; result: PDouble; lua: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixtrrcond1 = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; isunit: PByte; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixtrrcondinf = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; isunit: PByte; _xparams: UInt64):Int32T;cdecl;

    x_matinvreport = record
         r1: Double;
         rinf: Double;
    end;
    px_matinvreport = ^x_matinvreport;
    Trmatrixluinverse = function(error_msg: PPAnsiChar; a: px_matrix; pivots: px_vector; n: PNativeInt; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Trmatrixinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixluinverse = function(error_msg: PPAnsiChar; a: px_matrix; pivots: px_vector; n: PNativeInt; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskyinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixcholeskyinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Trmatrixtrinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; isunit: PByte; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixtrinverse = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; isunit: PByte; info: PNativeInt; rep: px_matinvreport; _xparams: UInt64):Int32T;cdecl;
    Trmatrixqr = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlq = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixqr = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlq = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixqrunpackq = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; qcolumns: PNativeInt; q: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixqrunpackr = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; r: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlqunpackq = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; qrows: PNativeInt; q: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlqunpackl = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; l: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixqrunpackq = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; qcolumns: PNativeInt; q: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixqrunpackr = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; r: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlqunpackq = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tau: px_vector; qrows: PNativeInt; q: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlqunpackl = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; l: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixbd = function(error_msg: PPAnsiChar; a: px_matrix; m: PNativeInt; n: PNativeInt; tauq: px_vector; taup: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixbdunpackq = function(error_msg: PPAnsiChar; qp: px_matrix; m: PNativeInt; n: PNativeInt; tauq: px_vector; qcolumns: PNativeInt; q: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixbdmultiplybyq = function(error_msg: PPAnsiChar; qp: px_matrix; m: PNativeInt; n: PNativeInt; tauq: px_vector; z: px_matrix; zrows: PNativeInt; zcolumns: PNativeInt; fromtheright: PByte; dotranspose: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixbdunpackpt = function(error_msg: PPAnsiChar; qp: px_matrix; m: PNativeInt; n: PNativeInt; taup: px_vector; ptrows: PNativeInt; pt: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixbdmultiplybyp = function(error_msg: PPAnsiChar; qp: px_matrix; m: PNativeInt; n: PNativeInt; taup: px_vector; z: px_matrix; zrows: PNativeInt; zcolumns: PNativeInt; fromtheright: PByte; dotranspose: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixbdunpackdiagonals = function(error_msg: PPAnsiChar; b: px_matrix; m: PNativeInt; n: PNativeInt; isupper: PByte; d: px_vector; e: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixhessenberg = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; tau: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixhessenbergunpackq = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; tau: px_vector; q: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixhessenbergunpackh = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; h: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixtd = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; tau: px_vector; d: px_vector; e: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixtdunpackq = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; tau: px_vector; q: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thmatrixtd = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; tau: px_vector; d: px_vector; e: px_vector; _xparams: UInt64):Int32T;cdecl;
    Thmatrixtdunpackq = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; tau: px_vector; q: px_matrix; _xparams: UInt64):Int32T;cdecl;

    x_optguardreport = record
         nonc0suspected: UInt64T;
         nonc0test0positive: UInt64T;
         nonc0fidx: x_int;
         nonc0lipschitzc: Double;
         nonc1suspected: UInt64T;
         nonc1test0positive: UInt64T;
         nonc1test1positive: UInt64T;
         nonc1fidx: x_int;
         nonc1lipschitzc: Double;
         badgradsuspected: UInt64T;
         badgradfidx: x_int;
         badgradvidx: x_int;
         badgradxbase: x_vector;
         badgraduser: x_matrix;
         badgradnum: x_matrix;
    end;
    px_optguardreport = ^x_optguardreport;

    x_optguardnonc0report = record
         positive: UInt64T;
         fidx: x_int;
         x0: x_vector;
         d: x_vector;
         n: x_int;
         stp: x_vector;
         f: x_vector;
         cnt: x_int;
         stpidxa: x_int;
         stpidxb: x_int;
    end;
    px_optguardnonc0report = ^x_optguardnonc0report;

    x_optguardnonc1test0report = record
         positive: UInt64T;
         fidx: x_int;
         x0: x_vector;
         d: x_vector;
         n: x_int;
         stp: x_vector;
         f: x_vector;
         cnt: x_int;
         stpidxa: x_int;
         stpidxb: x_int;
    end;
    px_optguardnonc1test0report = ^x_optguardnonc1test0report;

    x_optguardnonc1test1report = record
         positive: UInt64T;
         fidx: x_int;
         vidx: x_int;
         x0: x_vector;
         d: x_vector;
         n: x_int;
         stp: x_vector;
         g: x_vector;
         cnt: x_int;
         stpidxa: x_int;
         stpidxb: x_int;
    end;
    px_optguardnonc1test1report = ^x_optguardnonc1test1report;
    Trmatrixbdsvd = function(error_msg: PPAnsiChar; result: PByte; d: px_vector; e: px_vector; n: PNativeInt; isupper: PByte; isfractionalaccuracyrequired: PByte; u: px_matrix; nru: PNativeInt; c: px_matrix; ncc: PNativeInt; vt: px_matrix; ncvt: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsvd = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; m: PNativeInt; n: PNativeInt; uneeded: PNativeInt; vtneeded: PNativeInt; additionalmemory: PNativeInt; w: px_vector; u: px_matrix; vt: px_matrix; _xparams: UInt64):Int32T;cdecl;

    x_densesolverreport = record
         r1: Double;
         rinf: Double;
    end;
    px_densesolverreport = ^x_densesolverreport;

    x_densesolverlsreport = record
         r2: Double;
         cx: x_matrix;
         n: x_int;
         k: x_int;
    end;
    px_densesolverlsreport = ^x_densesolverlsreport;
    Trmatrixsolve = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsolvefast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsolvem = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_matrix; m: PNativeInt; rfs: PByte; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsolvemfast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlusolve = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlusolvefast = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlusolvem = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixlusolvemfast = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixmixedsolve = function(error_msg: PPAnsiChar; a: px_matrix; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixmixedsolvem = function(error_msg: PPAnsiChar; a: px_matrix; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixsolvem = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_matrix; m: PNativeInt; rfs: PByte; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixsolvemfast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixsolve = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixsolvefast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlusolvem = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlusolvemfast = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlusolve = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixlusolvefast = function(error_msg: PPAnsiChar; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixmixedsolvem = function(error_msg: PPAnsiChar; a: px_matrix; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixmixedsolve = function(error_msg: PPAnsiChar; a: px_matrix; lua: px_matrix; p: px_vector; n: PNativeInt; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixsolvem = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixsolvemfast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixsolve = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixsolvefast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskysolvem = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskysolvemfast = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskysolve = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskysolvefast = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixsolvem = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixsolvemfast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixsolve = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixsolvefast = function(error_msg: PPAnsiChar; a: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixcholeskysolvem = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; rep: px_densesolverreport; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixcholeskysolvemfast = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_matrix; m: PNativeInt; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixcholeskysolve = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; rep: px_densesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Thpdmatrixcholeskysolvefast = function(error_msg: PPAnsiChar; cha: px_matrix; n: PNativeInt; isupper: PByte; b: px_vector; info: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixsolvels = function(error_msg: PPAnsiChar; a: px_matrix; nrows: PNativeInt; ncols: PNativeInt; b: px_vector; threshold: PDouble; info: PNativeInt; rep: px_densesolverlsreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minlbfgsstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minlbfgsstate = procedure(x: Pointer);cdecl;
    Tx_minlbfgsstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlbfgsstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlbfgsstate_get_needfg = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlbfgsstate_set_needfg = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlbfgsstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlbfgsstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlbfgsstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_minlbfgsstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_minlbfgsstate_get_g = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minlbfgsstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_minlbfgsreport = record
         iterationscount: x_int;
         nfev: x_int;
         terminationtype: x_int;
    end;
    px_minlbfgsreport = ^x_minlbfgsreport;
    Tminlbfgscreate = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgscreatef = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetcond = function(error_msg: PPAnsiChar; state: PPointer; epsg: PDouble; epsf: PDouble; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetprecdefault = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetpreccholesky = function(error_msg: PPAnsiChar; state: PPointer; p: px_matrix; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetprecdiag = function(error_msg: PPAnsiChar; state: PPointer; d: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetprecscale = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsiteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsoptguardgradient = function(error_msg: PPAnsiChar; state: PPointer; teststep: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsoptguardsmoothness = function(error_msg: PPAnsiChar; state: PPointer; level: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsoptguardresults = function(error_msg: PPAnsiChar; state: PPointer; rep: px_optguardreport; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsoptguardnonc1test0results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test0report; lngrep: px_optguardnonc1test0report; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsoptguardnonc1test1results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test1report; lngrep: px_optguardnonc1test1report; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minlbfgsreport; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minlbfgsreport; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgsrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_normestimatorstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_normestimatorstate = procedure(x: Pointer);cdecl;
    Tnormestimatorcreate = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; nstart: PNativeInt; nits: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tnormestimatorsetseed = function(error_msg: PPAnsiChar; state: PPointer; seedval: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tnormestimatorestimatesparse = function(error_msg: PPAnsiChar; state: PPointer; a: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tnormestimatorresults = function(error_msg: PPAnsiChar; state: PPointer; nrm: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_linlsqrstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_linlsqrstate = procedure(x: Pointer);cdecl;

    x_linlsqrreport = record
         iterationscount: x_int;
         nmv: x_int;
         terminationtype: x_int;
    end;
    px_linlsqrreport = ^x_linlsqrreport;
    Tlinlsqrcreate = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrcreatebuf = function(error_msg: PPAnsiChar; m: PNativeInt; n: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrsetprecunit = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrsetprecdiag = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrsetlambdai = function(error_msg: PPAnsiChar; state: PPointer; lambdai: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrsolvesparse = function(error_msg: PPAnsiChar; state: PPointer; a: PPointer; b: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsa: PDouble; epsb: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_linlsqrreport; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrpeekiterationscount = function(error_msg: PPAnsiChar; result: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlinlsqrrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minbleicstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minbleicstate = procedure(x: Pointer);cdecl;
    Tx_minbleicstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minbleicstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minbleicstate_get_needfg = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minbleicstate_set_needfg = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minbleicstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minbleicstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minbleicstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_minbleicstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_minbleicstate_get_g = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minbleicstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_minbleicreport = record
         iterationscount: x_int;
         nfev: x_int;
         varidx: x_int;
         terminationtype: x_int;
         debugeqerr: Double;
         debugfs: Double;
         debugff: Double;
         debugdx: Double;
         debugfeasqpits: x_int;
         debugfeasgpaits: x_int;
         inneriterationscount: x_int;
         outeriterationscount: x_int;
    end;
    px_minbleicreport = ^x_minbleicreport;
    Tminbleiccreate = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbleiccreatef = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetlc = function(error_msg: PPAnsiChar; state: PPointer; c: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsg: PDouble; epsf: PDouble; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetprecdefault = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetprecdiag = function(error_msg: PPAnsiChar; state: PPointer; d: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetprecscale = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminbleiciteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbleicoptguardgradient = function(error_msg: PPAnsiChar; state: PPointer; teststep: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminbleicoptguardsmoothness = function(error_msg: PPAnsiChar; state: PPointer; level: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminbleicoptguardresults = function(error_msg: PPAnsiChar; state: PPointer; rep: px_optguardreport; _xparams: UInt64):Int32T;cdecl;
    Tminbleicoptguardnonc1test0results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test0report; lngrep: px_optguardnonc1test0report; _xparams: UInt64):Int32T;cdecl;
    Tminbleicoptguardnonc1test1results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test1report; lngrep: px_optguardnonc1test1report; _xparams: UInt64):Int32T;cdecl;
    Tminbleicresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minbleicreport; _xparams: UInt64):Int32T;cdecl;
    Tminbleicresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minbleicreport; _xparams: UInt64):Int32T;cdecl;
    Tminbleicrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbleicrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minqpstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minqpstate = procedure(x: Pointer);cdecl;

    x_minqpreport = record
         inneriterationscount: x_int;
         outeriterationscount: x_int;
         nmv: x_int;
         ncholesky: x_int;
         terminationtype: x_int;
         lagbc: x_vector;
         laglc: x_vector;
    end;
    px_minqpreport = ^x_minqpreport;
    Tminqpcreate = function(error_msg: PPAnsiChar; n: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlinearterm = function(error_msg: PPAnsiChar; state: PPointer; b: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetquadraticterm = function(error_msg: PPAnsiChar; state: PPointer; a: px_matrix; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetquadratictermsparse = function(error_msg: PPAnsiChar; state: PPointer; a: PPointer; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetstartingpoint = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetorigin = function(error_msg: PPAnsiChar; state: PPointer; xorigin: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetscaleautodiag = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetalgobleic = function(error_msg: PPAnsiChar; state: PPointer; epsg: PDouble; epsf: PDouble; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetalgodenseaul = function(error_msg: PPAnsiChar; state: PPointer; epsx: PDouble; rho: PDouble; itscnt: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetalgodenseipm = function(error_msg: PPAnsiChar; state: PPointer; eps: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetalgosparseipm = function(error_msg: PPAnsiChar; state: PPointer; eps: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetalgoquickqp = function(error_msg: PPAnsiChar; state: PPointer; epsg: PDouble; epsf: PDouble; epsx: PDouble; maxouterits: PNativeInt; usenewton: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetbcall = function(error_msg: PPAnsiChar; state: PPointer; bndl: PDouble; bndu: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetbci = function(error_msg: PPAnsiChar; state: PPointer; i: PNativeInt; bndl: PDouble; bndu: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlc = function(error_msg: PPAnsiChar; state: PPointer; c: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlcsparse = function(error_msg: PPAnsiChar; state: PPointer; c: PPointer; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlcmixed = function(error_msg: PPAnsiChar; state: PPointer; sparsec: PPointer; sparsect: px_vector; sparsek: PNativeInt; densec: px_matrix; densect: px_vector; densek: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlcmixedlegacy = function(error_msg: PPAnsiChar; state: PPointer; densec: px_matrix; densect: px_vector; densek: PNativeInt; sparsec: PPointer; sparsect: px_vector; sparsek: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlc2dense = function(error_msg: PPAnsiChar; state: PPointer; a: px_matrix; al: px_vector; au: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlc2 = function(error_msg: PPAnsiChar; state: PPointer; a: PPointer; al: px_vector; au: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminqpsetlc2mixed = function(error_msg: PPAnsiChar; state: PPointer; sparsea: PPointer; ksparse: PNativeInt; densea: px_matrix; kdense: PNativeInt; al: px_vector; au: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminqpaddlc2dense = function(error_msg: PPAnsiChar; state: PPointer; a: px_vector; al: PDouble; au: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminqpaddlc2 = function(error_msg: PPAnsiChar; state: PPointer; idxa: px_vector; vala: px_vector; nnz: PNativeInt; al: PDouble; au: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminqpoptimize = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminqpresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minqpreport; _xparams: UInt64):Int32T;cdecl;
    Tminqpresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minqpreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minlpstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minlpstate = procedure(x: Pointer);cdecl;

    x_minlpreport = record
         f: Double;
         y: x_vector;
         stats: x_vector;
         primalerror: Double;
         dualerror: Double;
         iterationscount: x_int;
         terminationtype: x_int;
    end;
    px_minlpreport = ^x_minlpreport;
    Tminlpcreate = function(error_msg: PPAnsiChar; n: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetcost = function(error_msg: PPAnsiChar; state: PPointer; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetbcall = function(error_msg: PPAnsiChar; state: PPointer; bndl: PDouble; bndu: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetbci = function(error_msg: PPAnsiChar; state: PPointer; i: PNativeInt; bndl: PDouble; bndu: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetlc = function(error_msg: PPAnsiChar; state: PPointer; a: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetlc2dense = function(error_msg: PPAnsiChar; state: PPointer; a: px_matrix; al: px_vector; au: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlpsetlc2 = function(error_msg: PPAnsiChar; state: PPointer; a: PPointer; al: px_vector; au: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlpaddlc2dense = function(error_msg: PPAnsiChar; state: PPointer; a: px_vector; al: PDouble; au: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlpaddlc2 = function(error_msg: PPAnsiChar; state: PPointer; idxa: px_vector; vala: px_vector; nnz: PNativeInt; al: PDouble; au: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlpoptimize = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlpresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minlpreport; _xparams: UInt64):Int32T;cdecl;
    Tminlpresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minlpreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minnlcstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minnlcstate = procedure(x: Pointer);cdecl;
    Tx_minnlcstate_get_needfi = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minnlcstate_set_needfi = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minnlcstate_get_needfij = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minnlcstate_set_needfij = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minnlcstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minnlcstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minnlcstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_minnlcstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_minnlcstate_get_fi = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minnlcstate_get_j = function(x: Pointer; dst: Px_matrix):Int32T;cdecl;
    Tx_minnlcstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_minnlcreport = record
         iterationscount: x_int;
         nfev: x_int;
         terminationtype: x_int;
         bcerr: Double;
         bcidx: x_int;
         lcerr: Double;
         lcidx: x_int;
         nlcerr: Double;
         nlcidx: x_int;
         dbgphase0its: x_int;
    end;
    px_minnlcreport = ^x_minnlcreport;
    Tminnlccreate = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlccreatef = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetlc = function(error_msg: PPAnsiChar; state: PPointer; c: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetnlc = function(error_msg: PPAnsiChar; state: PPointer; nlec: PNativeInt; nlic: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetprecinexact = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetprecexactlowrank = function(error_msg: PPAnsiChar; state: PPointer; updatefreq: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetprecexactrobust = function(error_msg: PPAnsiChar; state: PPointer; updatefreq: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetprecnone = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetalgoaul = function(error_msg: PPAnsiChar; state: PPointer; rho: PDouble; itscnt: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetalgoslp = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetalgosqp = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlcsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminnlciteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlcoptguardgradient = function(error_msg: PPAnsiChar; state: PPointer; teststep: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminnlcoptguardsmoothness = function(error_msg: PPAnsiChar; state: PPointer; level: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnlcoptguardresults = function(error_msg: PPAnsiChar; state: PPointer; rep: px_optguardreport; _xparams: UInt64):Int32T;cdecl;
    Tminnlcoptguardnonc1test0results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test0report; lngrep: px_optguardnonc1test0report; _xparams: UInt64):Int32T;cdecl;
    Tminnlcoptguardnonc1test1results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test1report; lngrep: px_optguardnonc1test1report; _xparams: UInt64):Int32T;cdecl;
    Tminnlcresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minnlcreport; _xparams: UInt64):Int32T;cdecl;
    Tminnlcresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minnlcreport; _xparams: UInt64):Int32T;cdecl;
    Tminnlcrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnlcrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minbcstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minbcstate = procedure(x: Pointer);cdecl;
    Tx_minbcstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minbcstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minbcstate_get_needfg = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minbcstate_set_needfg = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minbcstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minbcstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minbcstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_minbcstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_minbcstate_get_g = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minbcstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_minbcreport = record
         iterationscount: x_int;
         nfev: x_int;
         varidx: x_int;
         terminationtype: x_int;
    end;
    px_minbcreport = ^x_minbcreport;
    Tminbccreate = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbccreatef = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsg: PDouble; epsf: PDouble; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetprecdefault = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetprecdiag = function(error_msg: PPAnsiChar; state: PPointer; d: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetprecscale = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminbcsetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminbciteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminbcoptguardgradient = function(error_msg: PPAnsiChar; state: PPointer; teststep: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminbcoptguardsmoothness = function(error_msg: PPAnsiChar; state: PPointer; level: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminbcoptguardresults = function(error_msg: PPAnsiChar; state: PPointer; rep: px_optguardreport; _xparams: UInt64):Int32T;cdecl;
    Tminbcoptguardnonc1test0results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test0report; lngrep: px_optguardnonc1test0report; _xparams: UInt64):Int32T;cdecl;
    Tminbcoptguardnonc1test1results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test1report; lngrep: px_optguardnonc1test1report; _xparams: UInt64):Int32T;cdecl;
    Tminbcresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minbcreport; _xparams: UInt64):Int32T;cdecl;
    Tminbcresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minbcreport; _xparams: UInt64):Int32T;cdecl;
    Tminbcrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminbcrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minnsstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minnsstate = procedure(x: Pointer);cdecl;
    Tx_minnsstate_get_needfi = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minnsstate_set_needfi = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minnsstate_get_needfij = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minnsstate_set_needfij = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minnsstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minnsstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minnsstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_minnsstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_minnsstate_get_fi = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minnsstate_get_j = function(x: Pointer; dst: Px_matrix):Int32T;cdecl;
    Tx_minnsstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_minnsreport = record
         iterationscount: x_int;
         nfev: x_int;
         cerr: Double;
         lcerr: Double;
         nlcerr: Double;
         terminationtype: x_int;
         varidx: x_int;
         funcidx: x_int;
    end;
    px_minnsreport = ^x_minnsreport;
    Tminnscreate = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnscreatef = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnssetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminnssetlc = function(error_msg: PPAnsiChar; state: PPointer; c: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnssetnlc = function(error_msg: PPAnsiChar; state: PPointer; nlec: PNativeInt; nlic: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnssetcond = function(error_msg: PPAnsiChar; state: PPointer; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminnssetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminnssetalgoags = function(error_msg: PPAnsiChar; state: PPointer; radius: PDouble; penalty: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminnssetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminnsrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnsiteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminnsresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minnsreport; _xparams: UInt64):Int32T;cdecl;
    Tminnsresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minnsreport; _xparams: UInt64):Int32T;cdecl;
    Tminnsrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minasastate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minasastate = procedure(x: Pointer);cdecl;
    Tx_minasastate_get_needfg = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minasastate_set_needfg = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minasastate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minasastate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minasastate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_minasastate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_minasastate_get_g = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minasastate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_minasareport = record
         iterationscount: x_int;
         nfev: x_int;
         terminationtype: x_int;
         activeconstraints: x_int;
    end;
    px_minasareport = ^x_minasareport;
    Tminlbfgssetdefaultpreconditioner = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlbfgssetcholeskypreconditioner = function(error_msg: PPAnsiChar; state: PPointer; p: px_matrix; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetbarrierwidth = function(error_msg: PPAnsiChar; state: PPointer; mu: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminbleicsetbarrierdecay = function(error_msg: PPAnsiChar; state: PPointer; mudecay: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminasacreate = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; bndl: px_vector; bndu: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminasasetcond = function(error_msg: PPAnsiChar; state: PPointer; epsg: PDouble; epsf: PDouble; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminasasetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminasasetalgorithm = function(error_msg: PPAnsiChar; state: PPointer; algotype: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminasasetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminasaiteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminasaresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minasareport; _xparams: UInt64):Int32T;cdecl;
    Tminasaresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minasareport; _xparams: UInt64):Int32T;cdecl;
    Tminasarestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_mincgstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_mincgstate = procedure(x: Pointer);cdecl;
    Tx_mincgstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_mincgstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_mincgstate_get_needfg = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_mincgstate_set_needfg = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_mincgstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_mincgstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_mincgstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_mincgstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_mincgstate_get_g = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_mincgstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_mincgreport = record
         iterationscount: x_int;
         nfev: x_int;
         terminationtype: x_int;
    end;
    px_mincgreport = ^x_mincgreport;
    Tmincgcreate = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmincgcreatef = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsg: PDouble; epsf: PDouble; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetcgtype = function(error_msg: PPAnsiChar; state: PPointer; cgtype: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmincgsuggeststep = function(error_msg: PPAnsiChar; state: PPointer; stp: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetprecdefault = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetprecdiag = function(error_msg: PPAnsiChar; state: PPointer; d: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmincgsetprecscale = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmincgiteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmincgoptguardgradient = function(error_msg: PPAnsiChar; state: PPointer; teststep: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmincgoptguardsmoothness = function(error_msg: PPAnsiChar; state: PPointer; level: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmincgoptguardresults = function(error_msg: PPAnsiChar; state: PPointer; rep: px_optguardreport; _xparams: UInt64):Int32T;cdecl;
    Tmincgoptguardnonc1test0results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test0report; lngrep: px_optguardnonc1test0report; _xparams: UInt64):Int32T;cdecl;
    Tmincgoptguardnonc1test1results = function(error_msg: PPAnsiChar; state: PPointer; strrep: px_optguardnonc1test1report; lngrep: px_optguardnonc1test1report; _xparams: UInt64):Int32T;cdecl;
    Tmincgresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_mincgreport; _xparams: UInt64):Int32T;cdecl;
    Tmincgresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_mincgreport; _xparams: UInt64):Int32T;cdecl;
    Tmincgrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmincgrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_minlmstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_minlmstate = procedure(x: Pointer);cdecl;
    Tx_minlmstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlmstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlmstate_get_needfg = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlmstate_set_needfg = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlmstate_get_needfgh = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlmstate_set_needfgh = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlmstate_get_needfi = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlmstate_set_needfi = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlmstate_get_needfij = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlmstate_set_needfij = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlmstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_minlmstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_minlmstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_minlmstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_minlmstate_get_fi = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minlmstate_get_g = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_minlmstate_get_h = function(x: Pointer; dst: Px_matrix):Int32T;cdecl;
    Tx_minlmstate_get_j = function(x: Pointer; dst: Px_matrix):Int32T;cdecl;
    Tx_minlmstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_minlmreport = record
         iterationscount: x_int;
         terminationtype: x_int;
         nfunc: x_int;
         njac: x_int;
         ngrad: x_int;
         nhess: x_int;
         ncholesky: x_int;
    end;
    px_minlmreport = ^x_minlmreport;
    Tminlmcreatevj = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlmcreatev = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlmcreatefgh = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlmsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlmsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tminlmsetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlmsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlmsetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlmsetlc = function(error_msg: PPAnsiChar; state: PPointer; c: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlmsetacctype = function(error_msg: PPAnsiChar; state: PPointer; acctype: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tminlmiteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlmoptguardgradient = function(error_msg: PPAnsiChar; state: PPointer; teststep: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tminlmoptguardresults = function(error_msg: PPAnsiChar; state: PPointer; rep: px_optguardreport; _xparams: UInt64):Int32T;cdecl;
    Tminlmresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minlmreport; _xparams: UInt64):Int32T;cdecl;
    Tminlmresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_minlmreport; _xparams: UInt64):Int32T;cdecl;
    Tminlmrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tminlmrequesttermination = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlmcreatevgj = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlmcreatefgj = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tminlmcreatefj = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_eigsubspacestate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_eigsubspacestate = procedure(x: Pointer);cdecl;

    x_eigsubspacereport = record
         iterationscount: x_int;
    end;
    px_eigsubspacereport = ^x_eigsubspacereport;
    Teigsubspacecreate = function(error_msg: PPAnsiChar; n: PNativeInt; k: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Teigsubspacecreatebuf = function(error_msg: PPAnsiChar; n: PNativeInt; k: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Teigsubspacesetcond = function(error_msg: PPAnsiChar; state: PPointer; eps: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Teigsubspacesetwarmstart = function(error_msg: PPAnsiChar; state: PPointer; usewarmstart: PByte; _xparams: UInt64):Int32T;cdecl;
    Teigsubspaceoocstart = function(error_msg: PPAnsiChar; state: PPointer; mtype: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Teigsubspaceooccontinue = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Teigsubspaceoocgetrequestinfo = function(error_msg: PPAnsiChar; state: PPointer; requesttype: PNativeInt; requestsize: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Teigsubspaceoocgetrequestdata = function(error_msg: PPAnsiChar; state: PPointer; x: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Teigsubspaceoocsendresult = function(error_msg: PPAnsiChar; state: PPointer; ax: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Teigsubspaceoocstop = function(error_msg: PPAnsiChar; state: PPointer; w: px_vector; z: px_matrix; rep: px_eigsubspacereport; _xparams: UInt64):Int32T;cdecl;
    Teigsubspacesolvedenses = function(error_msg: PPAnsiChar; state: PPointer; a: px_matrix; isupper: PByte; w: px_vector; z: px_matrix; rep: px_eigsubspacereport; _xparams: UInt64):Int32T;cdecl;
    Teigsubspacesolvesparses = function(error_msg: PPAnsiChar; state: PPointer; a: PPointer; isupper: PByte; w: px_vector; z: px_matrix; rep: px_eigsubspacereport; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixevd = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; zneeded: PNativeInt; isupper: PByte; d: px_vector; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixevdr = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; zneeded: PNativeInt; isupper: PByte; b1: PDouble; b2: PDouble; m: PNativeInt; w: px_vector; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixevdi = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; zneeded: PNativeInt; isupper: PByte; i1: PNativeInt; i2: PNativeInt; w: px_vector; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thmatrixevd = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; zneeded: PNativeInt; isupper: PByte; d: px_vector; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thmatrixevdr = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; zneeded: PNativeInt; isupper: PByte; b1: PDouble; b2: PDouble; m: PNativeInt; w: px_vector; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Thmatrixevdi = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; zneeded: PNativeInt; isupper: PByte; i1: PNativeInt; i2: PNativeInt; w: px_vector; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixtdevd = function(error_msg: PPAnsiChar; result: PByte; d: px_vector; e: px_vector; n: PNativeInt; zneeded: PNativeInt; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixtdevdr = function(error_msg: PPAnsiChar; result: PByte; d: px_vector; e: px_vector; n: PNativeInt; zneeded: PNativeInt; a: PDouble; b: PDouble; m: PNativeInt; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixtdevdi = function(error_msg: PPAnsiChar; result: PByte; d: px_vector; e: px_vector; n: PNativeInt; zneeded: PNativeInt; i1: PNativeInt; i2: PNativeInt; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trmatrixevd = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; vneeded: PNativeInt; wr: px_vector; wi: px_vector; vl: px_matrix; vr: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsamplemoments = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; mean: PDouble; variance: PDouble; skewness: PDouble; kurtosis: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsamplemean = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsamplevariance = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsampleskewness = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsamplekurtosis = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tsampleadev = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; adev: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsamplemedian = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; median: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsamplepercentile = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; p: PDouble; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tcov2 = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; y: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tpearsoncorr2 = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; y: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspearmancorr2 = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; y: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcovm = function(error_msg: PPAnsiChar; x: px_matrix; n: PNativeInt; m: PNativeInt; c: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tpearsoncorrm = function(error_msg: PPAnsiChar; x: px_matrix; n: PNativeInt; m: PNativeInt; c: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspearmancorrm = function(error_msg: PPAnsiChar; x: px_matrix; n: PNativeInt; m: PNativeInt; c: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tcovm2 = function(error_msg: PPAnsiChar; x: px_matrix; y: px_matrix; n: PNativeInt; m1: PNativeInt; m2: PNativeInt; c: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tpearsoncorrm2 = function(error_msg: PPAnsiChar; x: px_matrix; y: px_matrix; n: PNativeInt; m1: PNativeInt; m2: PNativeInt; c: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspearmancorrm2 = function(error_msg: PPAnsiChar; x: px_matrix; y: px_matrix; n: PNativeInt; m1: PNativeInt; m2: PNativeInt; c: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trankdata = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nfeatures: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trankdatacentered = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nfeatures: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tpearsoncorrelation = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; y: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspearmanrankcorrelation = function(error_msg: PPAnsiChar; result: PDouble; x: px_vector; y: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tpcabuildbasis = function(error_msg: PPAnsiChar; x: px_matrix; npoints: PNativeInt; nvars: PNativeInt; info: PNativeInt; s2: px_vector; v: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tpcatruncatedsubspace = function(error_msg: PPAnsiChar; x: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nneeded: PNativeInt; eps: PDouble; maxits: PNativeInt; s2: px_vector; v: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tpcatruncatedsubspacesparse = function(error_msg: PPAnsiChar; x: PPointer; npoints: PNativeInt; nvars: PNativeInt; nneeded: PNativeInt; eps: PDouble; maxits: PNativeInt; s2: px_vector; v: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tdsoptimalsplit2 = function(error_msg: PPAnsiChar; a: px_vector; c: px_vector; n: PNativeInt; info: PNativeInt; threshold: PDouble; pal: PDouble; pbl: PDouble; par: PDouble; pbr: PDouble; cve: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tdsoptimalsplit2fast = function(error_msg: PPAnsiChar; a: px_vector; c: px_vector; tiesbuf: px_vector; cntbuf: px_vector; bufr: px_vector; bufi: px_vector; n: PNativeInt; nc: PNativeInt; alpha: PDouble; info: PNativeInt; threshold: PDouble; rms: PDouble; cvrms: PDouble; _xparams: UInt64):Int32T;cdecl;

    x_modelerrors = record
         relclserror: Double;
         avgce: Double;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
    end;
    px_modelerrors = ^x_modelerrors;
    Tx_obj_copy_multilayerperceptron = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_multilayerperceptron = procedure(x: Pointer);cdecl;
    Tmlpserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Tmlpunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Tmlpserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Tmlpunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Tmlpcreate0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreate1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreate2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreateb0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; b: PDouble; d: PDouble; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreateb1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; b: PDouble; d: PDouble; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreateb2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; b: PDouble; d: PDouble; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreater0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; a: PDouble; b: PDouble; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreater1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; a: PDouble; b: PDouble; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreater2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; a: PDouble; b: PDouble; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreatec0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreatec1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreatec2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcopy = function(error_msg: PPAnsiChar; network1: PPointer; network2: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcopytunableparameters = function(error_msg: PPAnsiChar; network1: PPointer; network2: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlprandomize = function(error_msg: PPAnsiChar; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlprandomizefull = function(error_msg: PPAnsiChar; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpinitpreprocessor = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; ssize: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpproperties = function(error_msg: PPAnsiChar; network: PPointer; nin: PNativeInt; nout: PNativeInt; wcount: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetinputscount = function(error_msg: PPAnsiChar; result: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetoutputscount = function(error_msg: PPAnsiChar; result: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetweightscount = function(error_msg: PPAnsiChar; result: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpissoftmax = function(error_msg: PPAnsiChar; result: PByte; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetlayerscount = function(error_msg: PPAnsiChar; result: PNativeInt; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetlayersize = function(error_msg: PPAnsiChar; result: PNativeInt; network: PPointer; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetinputscaling = function(error_msg: PPAnsiChar; network: PPointer; i: PNativeInt; mean: PDouble; sigma: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetoutputscaling = function(error_msg: PPAnsiChar; network: PPointer; i: PNativeInt; mean: PDouble; sigma: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetneuroninfo = function(error_msg: PPAnsiChar; network: PPointer; k: PNativeInt; i: PNativeInt; fkind: PNativeInt; threshold: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpgetweight = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; k0: PNativeInt; i0: PNativeInt; k1: PNativeInt; i1: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetinputscaling = function(error_msg: PPAnsiChar; network: PPointer; i: PNativeInt; mean: PDouble; sigma: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetoutputscaling = function(error_msg: PPAnsiChar; network: PPointer; i: PNativeInt; mean: PDouble; sigma: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetneuroninfo = function(error_msg: PPAnsiChar; network: PPointer; k: PNativeInt; i: PNativeInt; fkind: PNativeInt; threshold: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetweight = function(error_msg: PPAnsiChar; network: PPointer; k0: PNativeInt; i0: PNativeInt; k1: PNativeInt; i1: PNativeInt; w: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpactivationfunction = function(error_msg: PPAnsiChar; net: PDouble; k: PNativeInt; f: PDouble; df: PDouble; d2f: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpprocess = function(error_msg: PPAnsiChar; network: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpprocessi = function(error_msg: PPAnsiChar; network: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlperror = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlperrorsparse = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: PPointer; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlperrorn = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; ssize: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpclserror = function(error_msg: PPAnsiChar; result: PNativeInt; network: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlprelclserror = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlprelclserrorsparse = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: PPointer; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpavgce = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpavgcesparse = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: PPointer; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlprmserror = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlprmserrorsparse = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: PPointer; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpavgerror = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpavgerrorsparse = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: PPointer; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpavgrelerror = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpavgrelerrorsparse = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: PPointer; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpgrad = function(error_msg: PPAnsiChar; network: PPointer; x: px_vector; desiredy: px_vector; e: PDouble; grad: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpgradn = function(error_msg: PPAnsiChar; network: PPointer; x: px_vector; desiredy: px_vector; e: PDouble; grad: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpgradbatch = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; ssize: PNativeInt; e: PDouble; grad: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpgradbatchsparse = function(error_msg: PPAnsiChar; network: PPointer; xy: PPointer; ssize: PNativeInt; e: PDouble; grad: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpgradbatchsubset = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; setsize: PNativeInt; idx: px_vector; subsetsize: PNativeInt; e: PDouble; grad: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpgradbatchsparsesubset = function(error_msg: PPAnsiChar; network: PPointer; xy: PPointer; setsize: PNativeInt; idx: px_vector; subsetsize: PNativeInt; e: PDouble; grad: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpgradnbatch = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; ssize: PNativeInt; e: PDouble; grad: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlphessiannbatch = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; ssize: PNativeInt; e: PDouble; grad: px_vector; h: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tmlphessianbatch = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; ssize: PNativeInt; e: PDouble; grad: px_vector; h: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tmlpallerrorssubset = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; setsize: PNativeInt; subset: px_vector; subsetsize: PNativeInt; rep: px_modelerrors; _xparams: UInt64):Int32T;cdecl;
    Tmlpallerrorssparsesubset = function(error_msg: PPAnsiChar; network: PPointer; xy: PPointer; setsize: PNativeInt; subset: px_vector; subsetsize: PNativeInt; rep: px_modelerrors; _xparams: UInt64):Int32T;cdecl;
    Tmlperrorsubset = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: px_matrix; setsize: PNativeInt; subset: px_vector; subsetsize: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlperrorsparsesubset = function(error_msg: PPAnsiChar; result: PDouble; network: PPointer; xy: PPointer; setsize: PNativeInt; subset: px_vector; subsetsize: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tfisherlda = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nclasses: PNativeInt; info: PNativeInt; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tfisherldan = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nclasses: PNativeInt; info: PNativeInt; w: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_ssamodel = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_ssamodel = procedure(x: Pointer);cdecl;
    Tssacreate = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tssasetwindow = function(error_msg: PPAnsiChar; s: PPointer; windowwidth: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssasetseed = function(error_msg: PPAnsiChar; s: PPointer; seed: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssasetpoweruplength = function(error_msg: PPAnsiChar; s: PPointer; pwlen: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssasetmemorylimit = function(error_msg: PPAnsiChar; s: PPointer; memlimit: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssaaddsequence = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssaappendpointandupdate = function(error_msg: PPAnsiChar; s: PPointer; x: PDouble; updateits: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tssaappendsequenceandupdate = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; nticks: PNativeInt; updateits: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tssasetalgoprecomputed = function(error_msg: PPAnsiChar; s: PPointer; a: px_matrix; windowwidth: PNativeInt; nbasis: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssasetalgotopkdirect = function(error_msg: PPAnsiChar; s: PPointer; topk: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssasetalgotopkrealtime = function(error_msg: PPAnsiChar; s: PPointer; topk: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssacleardata = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tssagetbasis = function(error_msg: PPAnsiChar; s: PPointer; a: px_matrix; sv: px_vector; windowwidth: PNativeInt; nbasis: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssagetlrr = function(error_msg: PPAnsiChar; s: PPointer; a: px_vector; windowwidth: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssaanalyzelastwindow = function(error_msg: PPAnsiChar; s: PPointer; trend: px_vector; noise: px_vector; nticks: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tssaanalyzelast = function(error_msg: PPAnsiChar; s: PPointer; nticks: PNativeInt; trend: px_vector; noise: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tssaanalyzesequence = function(error_msg: PPAnsiChar; s: PPointer; data: px_vector; nticks: PNativeInt; trend: px_vector; noise: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tssaforecastlast = function(error_msg: PPAnsiChar; s: PPointer; nticks: PNativeInt; trend: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tssaforecastsequence = function(error_msg: PPAnsiChar; s: PPointer; data: px_vector; datalen: PNativeInt; forecastlen: PNativeInt; applysmoothing: PByte; trend: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tssaforecastavglast = function(error_msg: PPAnsiChar; s: PPointer; m: PNativeInt; nticks: PNativeInt; trend: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tssaforecastavgsequence = function(error_msg: PPAnsiChar; s: PPointer; data: px_vector; datalen: PNativeInt; m: PNativeInt; forecastlen: PNativeInt; applysmoothing: PByte; trend: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgammafunction = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlngamma = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; sgngam: PDouble; _xparams: UInt64):Int32T;cdecl;
    Terrorfunction = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Terrorfunctionc = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tnormaldistribution = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tnormalpdf = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tnormalcdf = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinverf = function(error_msg: PPAnsiChar; result: PDouble; e: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvnormaldistribution = function(error_msg: PPAnsiChar; result: PDouble; y0: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvnormalcdf = function(error_msg: PPAnsiChar; result: PDouble; y0: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbivariatenormalpdf = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; y: PDouble; rho: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbivariatenormalcdf = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; y: PDouble; rho: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tincompletegamma = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tincompletegammac = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvincompletegammac = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; y0: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_linearmodel = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_linearmodel = procedure(x: Pointer);cdecl;

    x_lrreport = record
         c: x_matrix;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
         cvrmserror: Double;
         cvavgerror: Double;
         cvavgrelerror: Double;
         ncvdefects: x_int;
         cvdefects: x_vector;
    end;
    px_lrreport = ^x_lrreport;
    Tlrbuild = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; info: PNativeInt; lm: PPointer; ar: px_lrreport; _xparams: UInt64):Int32T;cdecl;
    Tlrbuilds = function(error_msg: PPAnsiChar; xy: px_matrix; s: px_vector; npoints: PNativeInt; nvars: PNativeInt; info: PNativeInt; lm: PPointer; ar: px_lrreport; _xparams: UInt64):Int32T;cdecl;
    Tlrbuildzs = function(error_msg: PPAnsiChar; xy: px_matrix; s: px_vector; npoints: PNativeInt; nvars: PNativeInt; info: PNativeInt; lm: PPointer; ar: px_lrreport; _xparams: UInt64):Int32T;cdecl;
    Tlrbuildz = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; info: PNativeInt; lm: PPointer; ar: px_lrreport; _xparams: UInt64):Int32T;cdecl;
    Tlrunpack = function(error_msg: PPAnsiChar; lm: PPointer; v: px_vector; nvars: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlrpack = function(error_msg: PPAnsiChar; v: px_vector; nvars: PNativeInt; lm: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlrprocess = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tlrrmserror = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlravgerror = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlravgrelerror = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tfiltersma = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tfilterema = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; alpha: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfilterlrma = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_logitmodel = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_logitmodel = procedure(x: Pointer);cdecl;

    x_mnlreport = record
         ngrad: x_int;
         nhess: x_int;
    end;
    px_mnlreport = ^x_mnlreport;
    Tmnltrainh = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nclasses: PNativeInt; info: PNativeInt; lm: PPointer; rep: px_mnlreport; _xparams: UInt64):Int32T;cdecl;
    Tmnlprocess = function(error_msg: PPAnsiChar; lm: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmnlprocessi = function(error_msg: PPAnsiChar; lm: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmnlunpack = function(error_msg: PPAnsiChar; lm: PPointer; a: px_matrix; nvars: PNativeInt; nclasses: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmnlpack = function(error_msg: PPAnsiChar; a: px_matrix; nvars: PNativeInt; nclasses: PNativeInt; lm: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmnlavgce = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmnlrelclserror = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmnlrmserror = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmnlavgerror = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmnlavgrelerror = function(error_msg: PPAnsiChar; result: PDouble; lm: PPointer; xy: px_matrix; ssize: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmnlclserror = function(error_msg: PPAnsiChar; result: PNativeInt; lm: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_mcpdstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_mcpdstate = procedure(x: Pointer);cdecl;

    x_mcpdreport = record
         inneriterationscount: x_int;
         outeriterationscount: x_int;
         nfev: x_int;
         terminationtype: x_int;
    end;
    px_mcpdreport = ^x_mcpdreport;
    Tmcpdcreate = function(error_msg: PPAnsiChar; n: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmcpdcreateentry = function(error_msg: PPAnsiChar; n: PNativeInt; entrystate: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmcpdcreateexit = function(error_msg: PPAnsiChar; n: PNativeInt; exitstate: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmcpdcreateentryexit = function(error_msg: PPAnsiChar; n: PNativeInt; entrystate: PNativeInt; exitstate: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmcpdaddtrack = function(error_msg: PPAnsiChar; s: PPointer; xy: px_matrix; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmcpdsetec = function(error_msg: PPAnsiChar; s: PPointer; ec: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tmcpdaddec = function(error_msg: PPAnsiChar; s: PPointer; i: PNativeInt; j: PNativeInt; c: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmcpdsetbc = function(error_msg: PPAnsiChar; s: PPointer; bndl: px_matrix; bndu: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tmcpdaddbc = function(error_msg: PPAnsiChar; s: PPointer; i: PNativeInt; j: PNativeInt; bndl: PDouble; bndu: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmcpdsetlc = function(error_msg: PPAnsiChar; s: PPointer; c: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmcpdsettikhonovregularizer = function(error_msg: PPAnsiChar; s: PPointer; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmcpdsetprior = function(error_msg: PPAnsiChar; s: PPointer; pp: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tmcpdsetpredictionweights = function(error_msg: PPAnsiChar; s: PPointer; pw: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmcpdsolve = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmcpdresults = function(error_msg: PPAnsiChar; s: PPointer; p: px_matrix; rep: px_mcpdreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_mlpensemble = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_mlpensemble = procedure(x: Pointer);cdecl;
    Tmlpeserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Tmlpeunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Tmlpeserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Tmlpeunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Tmlpecreate0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreate1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreate2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreateb0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; b: PDouble; d: PDouble; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreateb1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; b: PDouble; d: PDouble; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreateb2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; b: PDouble; d: PDouble; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreater0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; a: PDouble; b: PDouble; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreater1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; a: PDouble; b: PDouble; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreater2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; a: PDouble; b: PDouble; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreatec0 = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreatec1 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid: PNativeInt; nout: PNativeInt; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreatec2 = function(error_msg: PPAnsiChar; nin: PNativeInt; nhid1: PNativeInt; nhid2: PNativeInt; nout: PNativeInt; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpecreatefromnetwork = function(error_msg: PPAnsiChar; network: PPointer; ensemblesize: PNativeInt; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlperandomize = function(error_msg: PPAnsiChar; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpeproperties = function(error_msg: PPAnsiChar; ensemble: PPointer; nin: PNativeInt; nout: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpeissoftmax = function(error_msg: PPAnsiChar; result: PByte; ensemble: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpeprocess = function(error_msg: PPAnsiChar; ensemble: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlpeprocessi = function(error_msg: PPAnsiChar; ensemble: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tmlperelclserror = function(error_msg: PPAnsiChar; result: PDouble; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpeavgce = function(error_msg: PPAnsiChar; result: PDouble; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpermserror = function(error_msg: PPAnsiChar; result: PDouble; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpeavgerror = function(error_msg: PPAnsiChar; result: PDouble; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpeavgrelerror = function(error_msg: PPAnsiChar; result: PDouble; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;

    x_mlpreport = record
         relclserror: Double;
         avgce: Double;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
         ngrad: x_int;
         nhess: x_int;
         ncholesky: x_int;
    end;
    px_mlpreport = ^x_mlpreport;

    x_mlpcvreport = record
         relclserror: Double;
         avgce: Double;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
    end;
    px_mlpcvreport = ^x_mlpcvreport;
    Tx_obj_copy_mlptrainer = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_mlptrainer = procedure(x: Pointer);cdecl;
    Tmlptrainlm = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; npoints: PNativeInt; decay: PDouble; restarts: PNativeInt; info: PNativeInt; rep: px_mlpreport; _xparams: UInt64):Int32T;cdecl;
    Tmlptrainlbfgs = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; npoints: PNativeInt; decay: PDouble; restarts: PNativeInt; wstep: PDouble; maxits: PNativeInt; info: PNativeInt; rep: px_mlpreport; _xparams: UInt64):Int32T;cdecl;
    Tmlptraines = function(error_msg: PPAnsiChar; network: PPointer; trnxy: px_matrix; trnsize: PNativeInt; valxy: px_matrix; valsize: PNativeInt; decay: PDouble; restarts: PNativeInt; info: PNativeInt; rep: px_mlpreport; _xparams: UInt64):Int32T;cdecl;
    Tmlpkfoldcvlbfgs = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; npoints: PNativeInt; decay: PDouble; restarts: PNativeInt; wstep: PDouble; maxits: PNativeInt; foldscount: PNativeInt; info: PNativeInt; rep: px_mlpreport; cvrep: px_mlpcvreport; _xparams: UInt64):Int32T;cdecl;
    Tmlpkfoldcvlm = function(error_msg: PPAnsiChar; network: PPointer; xy: px_matrix; npoints: PNativeInt; decay: PDouble; restarts: PNativeInt; foldscount: PNativeInt; info: PNativeInt; rep: px_mlpreport; cvrep: px_mlpcvreport; _xparams: UInt64):Int32T;cdecl;
    Tmlpkfoldcv = function(error_msg: PPAnsiChar; s: PPointer; network: PPointer; nrestarts: PNativeInt; foldscount: PNativeInt; rep: px_mlpreport; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreatetrainer = function(error_msg: PPAnsiChar; nin: PNativeInt; nout: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpcreatetrainercls = function(error_msg: PPAnsiChar; nin: PNativeInt; nclasses: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetdataset = function(error_msg: PPAnsiChar; s: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetsparsedataset = function(error_msg: PPAnsiChar; s: PPointer; xy: PPointer; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetdecay = function(error_msg: PPAnsiChar; s: PPointer; decay: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetcond = function(error_msg: PPAnsiChar; s: PPointer; wstep: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tmlpsetalgobatch = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlptrainnetwork = function(error_msg: PPAnsiChar; s: PPointer; network: PPointer; nrestarts: PNativeInt; rep: px_mlpreport; _xparams: UInt64):Int32T;cdecl;
    Tmlpstarttraining = function(error_msg: PPAnsiChar; s: PPointer; network: PPointer; randomstart: PByte; _xparams: UInt64):Int32T;cdecl;
    Tmlpcontinuetraining = function(error_msg: PPAnsiChar; result: PByte; s: PPointer; network: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tmlpebagginglm = function(error_msg: PPAnsiChar; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; decay: PDouble; restarts: PNativeInt; info: PNativeInt; rep: px_mlpreport; ooberrors: px_mlpcvreport; _xparams: UInt64):Int32T;cdecl;
    Tmlpebagginglbfgs = function(error_msg: PPAnsiChar; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; decay: PDouble; restarts: PNativeInt; wstep: PDouble; maxits: PNativeInt; info: PNativeInt; rep: px_mlpreport; ooberrors: px_mlpcvreport; _xparams: UInt64):Int32T;cdecl;
    Tmlpetraines = function(error_msg: PPAnsiChar; ensemble: PPointer; xy: px_matrix; npoints: PNativeInt; decay: PDouble; restarts: PNativeInt; info: PNativeInt; rep: px_mlpreport; _xparams: UInt64):Int32T;cdecl;
    Tmlptrainensemblees = function(error_msg: PPAnsiChar; s: PPointer; ensemble: PPointer; nrestarts: PNativeInt; rep: px_mlpreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_clusterizerstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_clusterizerstate = procedure(x: Pointer);cdecl;

    x_ahcreport = record
         terminationtype: x_int;
         npoints: x_int;
         p: x_vector;
         z: x_matrix;
         pz: x_matrix;
         pm: x_matrix;
         mergedist: x_vector;
    end;
    px_ahcreport = ^x_ahcreport;

    x_kmeansreport = record
         npoints: x_int;
         nfeatures: x_int;
         terminationtype: x_int;
         iterationscount: x_int;
         energy: Double;
         k: x_int;
         c: x_matrix;
         cidx: x_vector;
    end;
    px_kmeansreport = ^x_kmeansreport;
    Tclusterizercreate = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tclusterizersetpoints = function(error_msg: PPAnsiChar; s: PPointer; xy: px_matrix; npoints: PNativeInt; nfeatures: PNativeInt; disttype: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tclusterizersetdistances = function(error_msg: PPAnsiChar; s: PPointer; d: px_matrix; npoints: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;
    Tclusterizersetahcalgo = function(error_msg: PPAnsiChar; s: PPointer; algo: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tclusterizersetkmeanslimits = function(error_msg: PPAnsiChar; s: PPointer; restarts: PNativeInt; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tclusterizersetkmeansinit = function(error_msg: PPAnsiChar; s: PPointer; initalgo: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tclusterizersetseed = function(error_msg: PPAnsiChar; s: PPointer; seed: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tclusterizerrunahc = function(error_msg: PPAnsiChar; s: PPointer; rep: px_ahcreport; _xparams: UInt64):Int32T;cdecl;
    Tclusterizerrunkmeans = function(error_msg: PPAnsiChar; s: PPointer; k: PNativeInt; rep: px_kmeansreport; _xparams: UInt64):Int32T;cdecl;
    Tclusterizergetdistances = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nfeatures: PNativeInt; disttype: PNativeInt; d: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tclusterizergetkclusters = function(error_msg: PPAnsiChar; rep: px_ahcreport; k: PNativeInt; cidx: px_vector; cz: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tclusterizerseparatedbydist = function(error_msg: PPAnsiChar; rep: px_ahcreport; r: PDouble; k: PNativeInt; cidx: px_vector; cz: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tclusterizerseparatedbycorr = function(error_msg: PPAnsiChar; rep: px_ahcreport; r: PDouble; k: PNativeInt; cidx: px_vector; cz: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_decisionforestbuilder = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_decisionforestbuilder = procedure(x: Pointer);cdecl;
    Tx_obj_copy_decisionforestbuffer = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_decisionforestbuffer = procedure(x: Pointer);cdecl;
    Tx_obj_copy_decisionforest = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_decisionforest = procedure(x: Pointer);cdecl;

    x_dfreport = record
         relclserror: Double;
         avgce: Double;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
         oobrelclserror: Double;
         oobavgce: Double;
         oobrmserror: Double;
         oobavgerror: Double;
         oobavgrelerror: Double;
         topvars: x_vector;
         varimportances: x_vector;
    end;
    px_dfreport = ^x_dfreport;
    Tdfserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Tdfunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Tdfserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Tdfunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Tdfcreatebuffer = function(error_msg: PPAnsiChar; model: PPointer; buf: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildercreate = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetdataset = function(error_msg: PPAnsiChar; s: PPointer; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nclasses: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetrndvars = function(error_msg: PPAnsiChar; s: PPointer; rndvars: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetrndvarsratio = function(error_msg: PPAnsiChar; s: PPointer; f: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetrndvarsauto = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetsubsampleratio = function(error_msg: PPAnsiChar; s: PPointer; f: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetseed = function(error_msg: PPAnsiChar; s: PPointer; seedval: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetrdfalgo = function(error_msg: PPAnsiChar; s: PPointer; algotype: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetrdfsplitstrength = function(error_msg: PPAnsiChar; s: PPointer; splitstrength: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetimportancetrngini = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetimportanceoobgini = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetimportancepermutation = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildersetimportancenone = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildergetprogress = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuilderpeekprogress = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfbuilderbuildrandomforest = function(error_msg: PPAnsiChar; s: PPointer; ntrees: PNativeInt; df: PPointer; rep: px_dfreport; _xparams: UInt64):Int32T;cdecl;
    Tdfbinarycompression = function(error_msg: PPAnsiChar; result: PDouble; df: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tdfprocess = function(error_msg: PPAnsiChar; df: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tdfprocessi = function(error_msg: PPAnsiChar; df: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tdfprocess0 = function(error_msg: PPAnsiChar; result: PDouble; model: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tdfclassify = function(error_msg: PPAnsiChar; result: PNativeInt; model: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tdftsprocess = function(error_msg: PPAnsiChar; df: PPointer; buf: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tdfrelclserror = function(error_msg: PPAnsiChar; result: PDouble; df: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfavgce = function(error_msg: PPAnsiChar; result: PDouble; df: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfrmserror = function(error_msg: PPAnsiChar; result: PDouble; df: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfavgerror = function(error_msg: PPAnsiChar; result: PDouble; df: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfavgrelerror = function(error_msg: PPAnsiChar; result: PDouble; df: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildrandomdecisionforest = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nclasses: PNativeInt; ntrees: PNativeInt; r: PDouble; info: PNativeInt; df: PPointer; rep: px_dfreport; _xparams: UInt64):Int32T;cdecl;
    Tdfbuildrandomdecisionforestx1 = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nclasses: PNativeInt; ntrees: PNativeInt; nrndvars: PNativeInt; r: PDouble; info: PNativeInt; df: PPointer; rep: px_dfreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_knnbuffer = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_knnbuffer = procedure(x: Pointer);cdecl;
    Tx_obj_copy_knnbuilder = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_knnbuilder = procedure(x: Pointer);cdecl;
    Tx_obj_copy_knnmodel = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_knnmodel = procedure(x: Pointer);cdecl;

    x_knnreport = record
         relclserror: Double;
         avgce: Double;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
    end;
    px_knnreport = ^x_knnreport;
    Tknnserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Tknnunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Tknnserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Tknnunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Tknncreatebuffer = function(error_msg: PPAnsiChar; model: PPointer; buf: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tknnbuildercreate = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tknnbuildersetdatasetreg = function(error_msg: PPAnsiChar; s: PPointer; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nout: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnbuildersetdatasetcls = function(error_msg: PPAnsiChar; s: PPointer; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; nclasses: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnbuildersetnorm = function(error_msg: PPAnsiChar; s: PPointer; nrmtype: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnbuilderbuildknnmodel = function(error_msg: PPAnsiChar; s: PPointer; k: PNativeInt; eps: PDouble; model: PPointer; rep: px_knnreport; _xparams: UInt64):Int32T;cdecl;
    Tknnrewritekeps = function(error_msg: PPAnsiChar; model: PPointer; k: PNativeInt; eps: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tknnprocess = function(error_msg: PPAnsiChar; model: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tknnprocess0 = function(error_msg: PPAnsiChar; result: PDouble; model: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tknnclassify = function(error_msg: PPAnsiChar; result: PNativeInt; model: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tknnprocessi = function(error_msg: PPAnsiChar; model: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tknntsprocess = function(error_msg: PPAnsiChar; model: PPointer; buf: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tknnrelclserror = function(error_msg: PPAnsiChar; result: PDouble; model: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnavgce = function(error_msg: PPAnsiChar; result: PDouble; model: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnrmserror = function(error_msg: PPAnsiChar; result: PDouble; model: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnavgerror = function(error_msg: PPAnsiChar; result: PDouble; model: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnavgrelerror = function(error_msg: PPAnsiChar; result: PDouble; model: PPointer; xy: px_matrix; npoints: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tknnallerrors = function(error_msg: PPAnsiChar; model: PPointer; xy: px_matrix; npoints: PNativeInt; rep: px_knnreport; _xparams: UInt64):Int32T;cdecl;
    Tkmeansgenerate = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nvars: PNativeInt; k: PNativeInt; restarts: PNativeInt; info: PNativeInt; c: px_matrix; xyc: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgqgeneraterec = function(error_msg: PPAnsiChar; alpha: px_vector; beta: px_vector; mu0: PDouble; n: PNativeInt; info: PNativeInt; x: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgqgenerategausslobattorec = function(error_msg: PPAnsiChar; alpha: px_vector; beta: px_vector; mu0: PDouble; a: PDouble; b: PDouble; n: PNativeInt; info: PNativeInt; x: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgqgenerategaussradaurec = function(error_msg: PPAnsiChar; alpha: px_vector; beta: px_vector; mu0: PDouble; a: PDouble; n: PNativeInt; info: PNativeInt; x: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgqgenerategausslegendre = function(error_msg: PPAnsiChar; n: PNativeInt; info: PNativeInt; x: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgqgenerategaussjacobi = function(error_msg: PPAnsiChar; n: PNativeInt; alpha: PDouble; beta: PDouble; info: PNativeInt; x: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgqgenerategausslaguerre = function(error_msg: PPAnsiChar; n: PNativeInt; alpha: PDouble; info: PNativeInt; x: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgqgenerategausshermite = function(error_msg: PPAnsiChar; n: PNativeInt; info: PNativeInt; x: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgkqgeneraterec = function(error_msg: PPAnsiChar; alpha: px_vector; beta: px_vector; mu0: PDouble; n: PNativeInt; info: PNativeInt; x: px_vector; wkronrod: px_vector; wgauss: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgkqgenerategausslegendre = function(error_msg: PPAnsiChar; n: PNativeInt; info: PNativeInt; x: px_vector; wkronrod: px_vector; wgauss: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgkqgenerategaussjacobi = function(error_msg: PPAnsiChar; n: PNativeInt; alpha: PDouble; beta: PDouble; info: PNativeInt; x: px_vector; wkronrod: px_vector; wgauss: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgkqlegendrecalc = function(error_msg: PPAnsiChar; n: PNativeInt; info: PNativeInt; x: px_vector; wkronrod: px_vector; wgauss: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tgkqlegendretbl = function(error_msg: PPAnsiChar; n: PNativeInt; x: px_vector; wkronrod: px_vector; wgauss: px_vector; eps: PDouble; _xparams: UInt64):Int32T;cdecl;

    x_autogkreport = record
         terminationtype: x_int;
         nfev: x_int;
         nintervals: x_int;
    end;
    px_autogkreport = ^x_autogkreport;
    Tx_obj_copy_autogkstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_autogkstate = procedure(x: Pointer);cdecl;
    Tx_autogkstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_autogkstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_autogkstate_get_x = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_autogkstate_set_x = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_autogkstate_get_xminusa = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_autogkstate_set_xminusa = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_autogkstate_get_bminusx = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_autogkstate_set_bminusx = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_autogkstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_autogkstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tautogksmooth = function(error_msg: PPAnsiChar; a: PDouble; b: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tautogksmoothw = function(error_msg: PPAnsiChar; a: PDouble; b: PDouble; xwidth: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tautogksingular = function(error_msg: PPAnsiChar; a: PDouble; b: PDouble; alpha: PDouble; beta: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tautogkiteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tautogkresults = function(error_msg: PPAnsiChar; state: PPointer; v: PDouble; rep: px_autogkreport; _xparams: UInt64):Int32T;cdecl;
    Tfftc1d = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tfftc1dinv = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tfftr1d = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; f: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tfftr1dinv = function(error_msg: PPAnsiChar; f: px_vector; n: PNativeInt; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tfhtr1d = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tfhtr1dinv = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tconvc1d = function(error_msg: PPAnsiChar; a: px_vector; m: PNativeInt; b: px_vector; n: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tconvc1dinv = function(error_msg: PPAnsiChar; a: px_vector; m: PNativeInt; b: px_vector; n: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tconvc1dcircular = function(error_msg: PPAnsiChar; s: px_vector; m: PNativeInt; r: px_vector; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tconvc1dcircularinv = function(error_msg: PPAnsiChar; a: px_vector; m: PNativeInt; b: px_vector; n: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tconvr1d = function(error_msg: PPAnsiChar; a: px_vector; m: PNativeInt; b: px_vector; n: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tconvr1dinv = function(error_msg: PPAnsiChar; a: px_vector; m: PNativeInt; b: px_vector; n: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tconvr1dcircular = function(error_msg: PPAnsiChar; s: px_vector; m: PNativeInt; r: px_vector; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tconvr1dcircularinv = function(error_msg: PPAnsiChar; a: px_vector; m: PNativeInt; b: px_vector; n: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcorrc1d = function(error_msg: PPAnsiChar; signal: px_vector; n: PNativeInt; pattern: px_vector; m: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcorrc1dcircular = function(error_msg: PPAnsiChar; signal: px_vector; m: PNativeInt; pattern: px_vector; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcorrr1d = function(error_msg: PPAnsiChar; signal: px_vector; n: PNativeInt; pattern: px_vector; m: PNativeInt; r: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tcorrr1dcircular = function(error_msg: PPAnsiChar; signal: px_vector; m: PNativeInt; pattern: px_vector; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_idwcalcbuffer = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_idwcalcbuffer = procedure(x: Pointer);cdecl;
    Tx_obj_copy_idwmodel = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_idwmodel = procedure(x: Pointer);cdecl;
    Tx_obj_copy_idwbuilder = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_idwbuilder = procedure(x: Pointer);cdecl;

    x_idwreport = record
         rmserror: Double;
         avgerror: Double;
         maxerror: Double;
         r2: Double;
    end;
    px_idwreport = ^x_idwreport;
    Tidwserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Tidwunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Tidwserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Tidwunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Tidwcreatecalcbuffer = function(error_msg: PPAnsiChar; s: PPointer; buf: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildercreate = function(error_msg: PPAnsiChar; nx: PNativeInt; ny: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetnlayers = function(error_msg: PPAnsiChar; state: PPointer; nlayers: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetpoints = function(error_msg: PPAnsiChar; state: PPointer; xy: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetalgomstab = function(error_msg: PPAnsiChar; state: PPointer; srad: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetalgotextbookshepard = function(error_msg: PPAnsiChar; state: PPointer; p: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetalgotextbookmodshepard = function(error_msg: PPAnsiChar; state: PPointer; r: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetuserterm = function(error_msg: PPAnsiChar; state: PPointer; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetconstterm = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tidwbuildersetzeroterm = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tidwcalc1 = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; x0: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tidwcalc2 = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; x0: PDouble; x1: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tidwcalc3 = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; x0: PDouble; x1: PDouble; x2: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tidwcalc = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tidwcalcbuf = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tidwtscalcbuf = function(error_msg: PPAnsiChar; s: PPointer; buf: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tidwfit = function(error_msg: PPAnsiChar; state: PPointer; model: PPointer; rep: px_idwreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_barycentricinterpolant = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_barycentricinterpolant = procedure(x: Pointer);cdecl;
    Tbarycentriccalc = function(error_msg: PPAnsiChar; result: PDouble; b: PPointer; t: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbarycentricdiff1 = function(error_msg: PPAnsiChar; b: PPointer; t: PDouble; f: PDouble; df: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbarycentricdiff2 = function(error_msg: PPAnsiChar; b: PPointer; t: PDouble; f: PDouble; df: PDouble; d2f: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbarycentriclintransx = function(error_msg: PPAnsiChar; b: PPointer; ca: PDouble; cb: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbarycentriclintransy = function(error_msg: PPAnsiChar; b: PPointer; ca: PDouble; cb: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbarycentricunpack = function(error_msg: PPAnsiChar; b: PPointer; n: PNativeInt; x: px_vector; y: px_vector; w: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tbarycentricbuildxyw = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; w: px_vector; n: PNativeInt; b: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tbarycentricbuildfloaterhormann = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; d: PNativeInt; b: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tfitspherels = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; cx: px_vector; r: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfitspheremc = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; cx: px_vector; rhi: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfitspheremi = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; cx: px_vector; rlo: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfitspheremz = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; cx: px_vector; rlo: PDouble; rhi: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfitspherex = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; problemtype: PNativeInt; epsx: PDouble; aulits: PNativeInt; penalty: PDouble; cx: px_vector; rlo: PDouble; rhi: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_spline1dinterpolant = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_spline1dinterpolant = procedure(x: Pointer);cdecl;

    x_spline1dfitreport = record
         taskrcond: Double;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
         maxerror: Double;
    end;
    px_spline1dfitreport = ^x_spline1dfitreport;
    Tspline1dbuildlinear = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline1dbuildcubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; boundltype: PNativeInt; boundl: PDouble; boundrtype: PNativeInt; boundr: PDouble; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline1dgriddiffcubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; boundltype: PNativeInt; boundl: PDouble; boundrtype: PNativeInt; boundr: PDouble; d: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline1dgriddiff2cubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; boundltype: PNativeInt; boundl: PDouble; boundrtype: PNativeInt; boundr: PDouble; d1: px_vector; d2: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline1dconvcubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; boundltype: PNativeInt; boundl: PDouble; boundrtype: PNativeInt; boundr: PDouble; x2: px_vector; n2: PNativeInt; y2: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline1dconvdiffcubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; boundltype: PNativeInt; boundl: PDouble; boundrtype: PNativeInt; boundr: PDouble; x2: px_vector; n2: PNativeInt; y2: px_vector; d2: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline1dconvdiff2cubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; boundltype: PNativeInt; boundl: PDouble; boundrtype: PNativeInt; boundr: PDouble; x2: px_vector; n2: PNativeInt; y2: px_vector; d2: px_vector; dd2: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline1dbuildcatmullrom = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; boundtype: PNativeInt; tension: PDouble; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline1dbuildhermite = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; d: px_vector; n: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline1dbuildakima = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline1dcalc = function(error_msg: PPAnsiChar; result: PDouble; c: PPointer; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline1ddiff = function(error_msg: PPAnsiChar; c: PPointer; x: PDouble; s: PDouble; ds: PDouble; d2s: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline1dunpack = function(error_msg: PPAnsiChar; c: PPointer; n: PNativeInt; tbl: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspline1dlintransx = function(error_msg: PPAnsiChar; c: PPointer; a: PDouble; b: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline1dlintransy = function(error_msg: PPAnsiChar; c: PPointer; a: PDouble; b: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline1dintegrate = function(error_msg: PPAnsiChar; result: PDouble; c: PPointer; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline1dfit = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; m: PNativeInt; lambdans: PDouble; s: PPointer; rep: px_spline1dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tspline1dbuildmonotone = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_pspline2interpolant = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_pspline2interpolant = procedure(x: Pointer);cdecl;
    Tx_obj_copy_pspline3interpolant = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_pspline3interpolant = procedure(x: Pointer);cdecl;
    Tpspline2build = function(error_msg: PPAnsiChar; xy: px_matrix; n: PNativeInt; st: PNativeInt; pt: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpspline3build = function(error_msg: PPAnsiChar; xy: px_matrix; n: PNativeInt; st: PNativeInt; pt: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpspline2buildperiodic = function(error_msg: PPAnsiChar; xy: px_matrix; n: PNativeInt; st: PNativeInt; pt: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpspline3buildperiodic = function(error_msg: PPAnsiChar; xy: px_matrix; n: PNativeInt; st: PNativeInt; pt: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpspline2parametervalues = function(error_msg: PPAnsiChar; p: PPointer; n: PNativeInt; t: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tpspline3parametervalues = function(error_msg: PPAnsiChar; p: PPointer; n: PNativeInt; t: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tpspline2calc = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline3calc = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; y: PDouble; z: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline2tangent = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline3tangent = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; y: PDouble; z: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline2diff = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; dx: PDouble; y: PDouble; dy: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline3diff = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; dx: PDouble; y: PDouble; dy: PDouble; z: PDouble; dz: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline2diff2 = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; dx: PDouble; d2x: PDouble; y: PDouble; dy: PDouble; d2y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline3diff2 = function(error_msg: PPAnsiChar; p: PPointer; t: PDouble; x: PDouble; dx: PDouble; d2x: PDouble; y: PDouble; dy: PDouble; d2y: PDouble; z: PDouble; dz: PDouble; d2z: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline2arclength = function(error_msg: PPAnsiChar; result: PDouble; p: PPointer; a: PDouble; b: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpspline3arclength = function(error_msg: PPAnsiChar; result: PDouble; p: PPointer; a: PDouble; b: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tparametricrdpfixed = function(error_msg: PPAnsiChar; x: px_matrix; n: PNativeInt; d: PNativeInt; stopm: PNativeInt; stopeps: PDouble; x2: px_matrix; idx2: px_vector; nsections: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_spline3dinterpolant = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_spline3dinterpolant = procedure(x: Pointer);cdecl;
    Tspline3dcalc = function(error_msg: PPAnsiChar; result: PDouble; c: PPointer; x: PDouble; y: PDouble; z: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline3dlintransxyz = function(error_msg: PPAnsiChar; c: PPointer; ax: PDouble; bx: PDouble; ay: PDouble; by: PDouble; az: PDouble; bz: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline3dlintransf = function(error_msg: PPAnsiChar; c: PPointer; a: PDouble; b: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline3dresampletrilinear = function(error_msg: PPAnsiChar; a: px_vector; oldzcount: PNativeInt; oldycount: PNativeInt; oldxcount: PNativeInt; newzcount: PNativeInt; newycount: PNativeInt; newxcount: PNativeInt; b: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline3dbuildtrilinearv = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; y: px_vector; m: PNativeInt; z: px_vector; l: PNativeInt; f: px_vector; d: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline3dcalcvbuf = function(error_msg: PPAnsiChar; c: PPointer; x: PDouble; y: PDouble; z: PDouble; f: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline3dcalcv = function(error_msg: PPAnsiChar; c: PPointer; x: PDouble; y: PDouble; z: PDouble; f: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline3dunpackv = function(error_msg: PPAnsiChar; c: PPointer; n: PNativeInt; m: PNativeInt; l: PNativeInt; d: PNativeInt; stype: PNativeInt; tbl: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialbar2cheb = function(error_msg: PPAnsiChar; p: PPointer; a: PDouble; b: PDouble; t: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialcheb2bar = function(error_msg: PPAnsiChar; t: px_vector; n: PNativeInt; a: PDouble; b: PDouble; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialbar2pow = function(error_msg: PPAnsiChar; p: PPointer; c: PDouble; s: PDouble; a: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialpow2bar = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; c: PDouble; s: PDouble; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialbuild = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialbuildeqdist = function(error_msg: PPAnsiChar; a: PDouble; b: PDouble; y: px_vector; n: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialbuildcheb1 = function(error_msg: PPAnsiChar; a: PDouble; b: PDouble; y: px_vector; n: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialbuildcheb2 = function(error_msg: PPAnsiChar; a: PDouble; b: PDouble; y: px_vector; n: PNativeInt; p: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialcalceqdist = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; b: PDouble; f: px_vector; n: PNativeInt; t: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialcalccheb1 = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; b: PDouble; f: px_vector; n: PNativeInt; t: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialcalccheb2 = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; b: PDouble; f: px_vector; n: PNativeInt; t: PDouble; _xparams: UInt64):Int32T;cdecl;

    x_polynomialfitreport = record
         taskrcond: Double;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
         maxerror: Double;
    end;
    px_polynomialfitreport = ^x_polynomialfitreport;

    x_barycentricfitreport = record
         taskrcond: Double;
         dbest: x_int;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
         maxerror: Double;
    end;
    px_barycentricfitreport = ^x_barycentricfitreport;

    x_lsfitreport = record
         taskrcond: Double;
         iterationscount: x_int;
         varidx: x_int;
         rmserror: Double;
         avgerror: Double;
         avgrelerror: Double;
         maxerror: Double;
         wrmserror: Double;
         covpar: x_matrix;
         errpar: x_vector;
         errcurve: x_vector;
         noise: x_vector;
         r2: Double;
    end;
    px_lsfitreport = ^x_lsfitreport;
    Tx_obj_copy_lsfitstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_lsfitstate = procedure(x: Pointer);cdecl;
    Tx_lsfitstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_lsfitstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_lsfitstate_get_needfg = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_lsfitstate_set_needfg = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_lsfitstate_get_needfgh = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_lsfitstate_set_needfgh = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_lsfitstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_lsfitstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_lsfitstate_get_c = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_lsfitstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_lsfitstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_lsfitstate_get_g = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_lsfitstate_get_h = function(x: Pointer; dst: Px_matrix):Int32T;cdecl;
    Tx_lsfitstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tlstfitpiecewiselinearrdpfixed = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; m: PNativeInt; x2: px_vector; y2: px_vector; nsections: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlstfitpiecewiselinearrdp = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; eps: PDouble; x2: px_vector; y2: px_vector; nsections: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialfit = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; m: PNativeInt; info: PNativeInt; p: PPointer; rep: px_polynomialfitreport; _xparams: UInt64):Int32T;cdecl;
    Tpolynomialfitwc = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; w: px_vector; n: PNativeInt; xc: px_vector; yc: px_vector; dc: px_vector; k: PNativeInt; m: PNativeInt; info: PNativeInt; p: PPointer; rep: px_polynomialfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlogisticcalc4 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; a: PDouble; b: PDouble; c: PDouble; d: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlogisticcalc5 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; a: PDouble; b: PDouble; c: PDouble; d: PDouble; g: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlogisticfit4 = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; a: PDouble; b: PDouble; c: PDouble; d: PDouble; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlogisticfit4ec = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; cnstrleft: PDouble; cnstrright: PDouble; a: PDouble; b: PDouble; c: PDouble; d: PDouble; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlogisticfit5 = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; a: PDouble; b: PDouble; c: PDouble; d: PDouble; g: PDouble; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlogisticfit5ec = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; cnstrleft: PDouble; cnstrright: PDouble; a: PDouble; b: PDouble; c: PDouble; d: PDouble; g: PDouble; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlogisticfit45x = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; cnstrleft: PDouble; cnstrright: PDouble; is4pl: PByte; lambdav: PDouble; epsx: PDouble; rscnt: PNativeInt; a: PDouble; b: PDouble; c: PDouble; d: PDouble; g: PDouble; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tbarycentricfitfloaterhormannwc = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; w: px_vector; n: PNativeInt; xc: px_vector; yc: px_vector; dc: px_vector; k: PNativeInt; m: PNativeInt; info: PNativeInt; b: PPointer; rep: px_barycentricfitreport; _xparams: UInt64):Int32T;cdecl;
    Tbarycentricfitfloaterhormann = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; m: PNativeInt; info: PNativeInt; b: PPointer; rep: px_barycentricfitreport; _xparams: UInt64):Int32T;cdecl;
    Tspline1dfitcubicwc = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; w: px_vector; n: PNativeInt; xc: px_vector; yc: px_vector; dc: px_vector; k: PNativeInt; m: PNativeInt; info: PNativeInt; s: PPointer; rep: px_spline1dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tspline1dfithermitewc = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; w: px_vector; n: PNativeInt; xc: px_vector; yc: px_vector; dc: px_vector; k: PNativeInt; m: PNativeInt; info: PNativeInt; s: PPointer; rep: px_spline1dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tspline1dfitcubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; m: PNativeInt; info: PNativeInt; s: PPointer; rep: px_spline1dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tspline1dfithermite = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; m: PNativeInt; info: PNativeInt; s: PPointer; rep: px_spline1dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlsfitlinearw = function(error_msg: PPAnsiChar; y: px_vector; w: px_vector; fmatrix: px_matrix; n: PNativeInt; m: PNativeInt; info: PNativeInt; c: px_vector; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlsfitlinearwc = function(error_msg: PPAnsiChar; y: px_vector; w: px_vector; fmatrix: px_matrix; cmatrix: px_matrix; n: PNativeInt; m: PNativeInt; k: PNativeInt; info: PNativeInt; c: px_vector; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlsfitlinear = function(error_msg: PPAnsiChar; y: px_vector; fmatrix: px_matrix; n: PNativeInt; m: PNativeInt; info: PNativeInt; c: px_vector; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlsfitlinearc = function(error_msg: PPAnsiChar; y: px_vector; fmatrix: px_matrix; cmatrix: px_matrix; n: PNativeInt; m: PNativeInt; k: PNativeInt; info: PNativeInt; c: px_vector; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlsfitcreatewf = function(error_msg: PPAnsiChar; x: px_matrix; y: px_vector; w: px_vector; c: px_vector; n: PNativeInt; m: PNativeInt; k: PNativeInt; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlsfitcreatef = function(error_msg: PPAnsiChar; x: px_matrix; y: px_vector; c: px_vector; n: PNativeInt; m: PNativeInt; k: PNativeInt; diffstep: PDouble; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlsfitcreatewfg = function(error_msg: PPAnsiChar; x: px_matrix; y: px_vector; w: px_vector; c: px_vector; n: PNativeInt; m: PNativeInt; k: PNativeInt; cheapfg: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlsfitcreatefg = function(error_msg: PPAnsiChar; x: px_matrix; y: px_vector; c: px_vector; n: PNativeInt; m: PNativeInt; k: PNativeInt; cheapfg: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlsfitcreatewfgh = function(error_msg: PPAnsiChar; x: px_matrix; y: px_vector; w: px_vector; c: px_vector; n: PNativeInt; m: PNativeInt; k: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlsfitcreatefgh = function(error_msg: PPAnsiChar; x: px_matrix; y: px_vector; c: px_vector; n: PNativeInt; m: PNativeInt; k: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlsfitsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsx: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlsfitsetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlsfitsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tlsfitsetscale = function(error_msg: PPAnsiChar; state: PPointer; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tlsfitsetbc = function(error_msg: PPAnsiChar; state: PPointer; bndl: px_vector; bndu: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tlsfitsetlc = function(error_msg: PPAnsiChar; state: PPointer; c: px_matrix; ct: px_vector; k: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlsfititeration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlsfitresults = function(error_msg: PPAnsiChar; state: PPointer; info: PNativeInt; c: px_vector; rep: px_lsfitreport; _xparams: UInt64):Int32T;cdecl;
    Tlsfitsetgradientcheck = function(error_msg: PPAnsiChar; state: PPointer; teststep: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_spline2dinterpolant = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_spline2dinterpolant = procedure(x: Pointer);cdecl;
    Tx_obj_copy_spline2dbuilder = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_spline2dbuilder = procedure(x: Pointer);cdecl;

    x_spline2dfitreport = record
         rmserror: Double;
         avgerror: Double;
         maxerror: Double;
         r2: Double;
    end;
    px_spline2dfitreport = ^x_spline2dfitreport;
    Tspline2dserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Tspline2dunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Tspline2dserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Tspline2dunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Tspline2dcalc = function(error_msg: PPAnsiChar; result: PDouble; c: PPointer; x: PDouble; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2ddiff = function(error_msg: PPAnsiChar; c: PPointer; x: PDouble; y: PDouble; f: PDouble; fx: PDouble; fy: PDouble; fxy: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dcalcvbuf = function(error_msg: PPAnsiChar; c: PPointer; x: PDouble; y: PDouble; f: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline2dcalcvi = function(error_msg: PPAnsiChar; result: PDouble; c: PPointer; x: PDouble; y: PDouble; i: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspline2dcalcv = function(error_msg: PPAnsiChar; c: PPointer; x: PDouble; y: PDouble; f: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tspline2ddiffvi = function(error_msg: PPAnsiChar; c: PPointer; x: PDouble; y: PDouble; i: PNativeInt; f: PDouble; fx: PDouble; fy: PDouble; fxy: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dlintransxy = function(error_msg: PPAnsiChar; c: PPointer; ax: PDouble; bx: PDouble; ay: PDouble; by: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dlintransf = function(error_msg: PPAnsiChar; c: PPointer; a: PDouble; b: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dcopy = function(error_msg: PPAnsiChar; c: PPointer; cc: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dresamplebicubic = function(error_msg: PPAnsiChar; a: px_matrix; oldheight: PNativeInt; oldwidth: PNativeInt; b: px_matrix; newheight: PNativeInt; newwidth: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspline2dresamplebilinear = function(error_msg: PPAnsiChar; a: px_matrix; oldheight: PNativeInt; oldwidth: PNativeInt; b: px_matrix; newheight: PNativeInt; newwidth: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildbilinearv = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; y: px_vector; m: PNativeInt; f: px_vector; d: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildbicubicv = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; y: px_vector; m: PNativeInt; f: px_vector; d: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dunpackv = function(error_msg: PPAnsiChar; c: PPointer; m: PNativeInt; n: PNativeInt; d: PNativeInt; tbl: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildbilinear = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; f: px_matrix; m: PNativeInt; n: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildbicubic = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; f: px_matrix; m: PNativeInt; n: PNativeInt; c: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dunpack = function(error_msg: PPAnsiChar; c: PPointer; m: PNativeInt; n: PNativeInt; tbl: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildercreate = function(error_msg: PPAnsiChar; d: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetuserterm = function(error_msg: PPAnsiChar; state: PPointer; v: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetlinterm = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetconstterm = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetzeroterm = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetpoints = function(error_msg: PPAnsiChar; state: PPointer; xy: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetareaauto = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetarea = function(error_msg: PPAnsiChar; state: PPointer; xa: PDouble; xb: PDouble; ya: PDouble; yb: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetgrid = function(error_msg: PPAnsiChar; state: PPointer; kx: PNativeInt; ky: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetalgofastddm = function(error_msg: PPAnsiChar; state: PPointer; nlayers: PNativeInt; lambdav: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetalgoblocklls = function(error_msg: PPAnsiChar; state: PPointer; lambdans: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dbuildersetalgonaivells = function(error_msg: PPAnsiChar; state: PPointer; lambdans: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline2dfit = function(error_msg: PPAnsiChar; state: PPointer; s: PPointer; rep: px_spline2dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_rbfcalcbuffer = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_rbfcalcbuffer = procedure(x: Pointer);cdecl;
    Tx_obj_copy_rbfmodel = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_rbfmodel = procedure(x: Pointer);cdecl;

    x_rbfreport = record
         rmserror: Double;
         maxerror: Double;
         arows: x_int;
         acols: x_int;
         annz: x_int;
         iterationscount: x_int;
         nmv: x_int;
         terminationtype: x_int;
    end;
    px_rbfreport = ^x_rbfreport;
    Trbfserialize   = function(error_msg: PPAnsiChar; x: PPointer; Dst: PPAnsiChar):Int32T;cdecl;
    Trbfunserialize = function(error_msg: PPAnsiChar; Src: PPAnsiChar; x: PPointer):Int32T;cdecl;
    Trbfserialize_stream = function(error_msg: PPAnsiChar; x: PPointer; StreamWriter: NativeInt; Obj: NativeInt):Int32T;cdecl;
    Trbfunserialize_stream = function(error_msg: PPAnsiChar; StreamReader: NativeInt; Obj: NativeInt; x: PPointer):Int32T;cdecl;
    Trbfcreate = function(error_msg: PPAnsiChar; nx: PNativeInt; ny: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Trbfcreatecalcbuffer = function(error_msg: PPAnsiChar; s: PPointer; buf: PPointer; _xparams: UInt64):Int32T;cdecl;
    Trbfsetpoints = function(error_msg: PPAnsiChar; s: PPointer; xy: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trbfsetpointsandscales = function(error_msg: PPAnsiChar; r: PPointer; xy: px_matrix; n: PNativeInt; s: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbfsetalgoqnn = function(error_msg: PPAnsiChar; s: PPointer; q: PDouble; z: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trbfsetalgomultilayer = function(error_msg: PPAnsiChar; s: PPointer; rbase: PDouble; nlayers: PNativeInt; lambdav: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trbfsetalgohierarchical = function(error_msg: PPAnsiChar; s: PPointer; rbase: PDouble; nlayers: PNativeInt; lambdans: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trbfsetlinterm = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Trbfsetconstterm = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Trbfsetzeroterm = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Trbfsetv2bf = function(error_msg: PPAnsiChar; s: PPointer; bf: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trbfsetv2its = function(error_msg: PPAnsiChar; s: PPointer; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trbfsetv2supportr = function(error_msg: PPAnsiChar; s: PPointer; r: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trbfbuildmodel = function(error_msg: PPAnsiChar; s: PPointer; rep: px_rbfreport; _xparams: UInt64):Int32T;cdecl;
    Trbfcalc1 = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; x0: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trbfcalc2 = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; x0: PDouble; x1: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trbfcalc3 = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; x0: PDouble; x1: PDouble; x2: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trbfcalc = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbfcalcbuf = function(error_msg: PPAnsiChar; s: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbftscalcbuf = function(error_msg: PPAnsiChar; s: PPointer; buf: PPointer; x: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbfgridcalc2 = function(error_msg: PPAnsiChar; s: PPointer; x0: px_vector; n0: PNativeInt; x1: px_vector; n1: PNativeInt; y: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Trbfgridcalc2v = function(error_msg: PPAnsiChar; s: PPointer; x0: px_vector; n0: PNativeInt; x1: px_vector; n1: PNativeInt; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbfgridcalc2vsubset = function(error_msg: PPAnsiChar; s: PPointer; x0: px_vector; n0: PNativeInt; x1: px_vector; n1: PNativeInt; flagy: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbfgridcalc3v = function(error_msg: PPAnsiChar; s: PPointer; x0: px_vector; n0: PNativeInt; x1: px_vector; n1: PNativeInt; x2: px_vector; n2: PNativeInt; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbfgridcalc3vsubset = function(error_msg: PPAnsiChar; s: PPointer; x0: px_vector; n0: PNativeInt; x1: px_vector; n1: PNativeInt; x2: px_vector; n2: PNativeInt; flagy: px_vector; y: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trbfunpack = function(error_msg: PPAnsiChar; s: PPointer; nx: PNativeInt; ny: PNativeInt; xwr: px_matrix; nc: PNativeInt; v: px_matrix; modelversion: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trbfgetmodelversion = function(error_msg: PPAnsiChar; result: PNativeInt; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Trbfpeekprogress = function(error_msg: PPAnsiChar; result: PDouble; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Trbfrequesttermination = function(error_msg: PPAnsiChar; s: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tnsfitspheremcc = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; cx: px_vector; rhi: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tnsfitspheremic = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; cx: px_vector; rlo: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tnsfitspheremzc = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; cx: px_vector; rlo: PDouble; rhi: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tnsfitspherex = function(error_msg: PPAnsiChar; xy: px_matrix; npoints: PNativeInt; nx: PNativeInt; problemtype: PNativeInt; epsx: PDouble; aulits: PNativeInt; penalty: PDouble; cx: px_vector; rlo: PDouble; rhi: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspline1dfitpenalized = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; n: PNativeInt; m: PNativeInt; rho: PDouble; info: PNativeInt; s: PPointer; rep: px_spline1dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tspline1dfitpenalizedw = function(error_msg: PPAnsiChar; x: px_vector; y: px_vector; w: px_vector; n: PNativeInt; m: PNativeInt; rho: PDouble; info: PNativeInt; s: PPointer; rep: px_spline1dfitreport; _xparams: UInt64):Int32T;cdecl;
    Tellipticintegralk = function(error_msg: PPAnsiChar; result: PDouble; m: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tellipticintegralkhighprecision = function(error_msg: PPAnsiChar; result: PDouble; m1: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tincompleteellipticintegralk = function(error_msg: PPAnsiChar; result: PDouble; phi: PDouble; m: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tellipticintegrale = function(error_msg: PPAnsiChar; result: PDouble; m: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tincompleteellipticintegrale = function(error_msg: PPAnsiChar; result: PDouble; phi: PDouble; m: PDouble; _xparams: UInt64):Int32T;cdecl;
    Thermitecalculate = function(error_msg: PPAnsiChar; result: PDouble; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Thermitesum = function(error_msg: PPAnsiChar; result: PDouble; c: px_vector; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Thermitecoefficients = function(error_msg: PPAnsiChar; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tdawsonintegral = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tsinecosineintegrals = function(error_msg: PPAnsiChar; x: PDouble; si: PDouble; ci: PDouble; _xparams: UInt64):Int32T;cdecl;
    Thyperbolicsinecosineintegrals = function(error_msg: PPAnsiChar; x: PDouble; shi: PDouble; chi: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpoissondistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; m: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpoissoncdistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; m: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvpoissondistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesselj0 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesselj1 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesseljn = function(error_msg: PPAnsiChar; result: PDouble; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbessely0 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbessely1 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesselyn = function(error_msg: PPAnsiChar; result: PDouble; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesseli0 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesseli1 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesselk0 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesselk1 = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbesselkn = function(error_msg: PPAnsiChar; result: PDouble; nn: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tincompletebeta = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; b: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvincompletebeta = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; b: PDouble; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfdistribution = function(error_msg: PPAnsiChar; result: PDouble; a: PNativeInt; b: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfcdistribution = function(error_msg: PPAnsiChar; result: PDouble; a: PNativeInt; b: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvfdistribution = function(error_msg: PPAnsiChar; result: PDouble; a: PNativeInt; b: PNativeInt; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tfresnelintegral = function(error_msg: PPAnsiChar; x: PDouble; c: PDouble; s: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tjacobianellipticfunctions = function(error_msg: PPAnsiChar; u: PDouble; m: PDouble; sn: PDouble; cn: PDouble; dn: PDouble; ph: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpsi = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Texponentialintegralei = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Texponentialintegralen = function(error_msg: PPAnsiChar; result: PDouble; x: PDouble; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlaguerrecalculate = function(error_msg: PPAnsiChar; result: PDouble; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlaguerresum = function(error_msg: PPAnsiChar; result: PDouble; c: px_vector; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlaguerrecoefficients = function(error_msg: PPAnsiChar; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tchisquaredistribution = function(error_msg: PPAnsiChar; result: PDouble; v: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tchisquarecdistribution = function(error_msg: PPAnsiChar; result: PDouble; v: PDouble; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvchisquaredistribution = function(error_msg: PPAnsiChar; result: PDouble; v: PDouble; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlegendrecalculate = function(error_msg: PPAnsiChar; result: PDouble; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlegendresum = function(error_msg: PPAnsiChar; result: PDouble; c: px_vector; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tlegendrecoefficients = function(error_msg: PPAnsiChar; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tbeta = function(error_msg: PPAnsiChar; result: PDouble; a: PDouble; b: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tchebyshevcalculate = function(error_msg: PPAnsiChar; result: PDouble; r: PNativeInt; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tchebyshevsum = function(error_msg: PPAnsiChar; result: PDouble; c: px_vector; r: PNativeInt; n: PNativeInt; x: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tchebyshevcoefficients = function(error_msg: PPAnsiChar; n: PNativeInt; c: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tfromchebyshev = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; b: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tstudenttdistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; t: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvstudenttdistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; p: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbinomialdistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; n: PNativeInt; p: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tbinomialcdistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; n: PNativeInt; p: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tinvbinomialdistribution = function(error_msg: PPAnsiChar; result: PDouble; k: PNativeInt; n: PNativeInt; y: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tairy = function(error_msg: PPAnsiChar; x: PDouble; ai: PDouble; aip: PDouble; bi: PDouble; bip: PDouble; _xparams: UInt64):Int32T;cdecl;
    Twilcoxonsignedranktest = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; e: PDouble; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tonesamplesigntest = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; median: PDouble; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tpearsoncorrelationsignificance = function(error_msg: PPAnsiChar; r: PDouble; n: PNativeInt; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tspearmanrankcorrelationsignificance = function(error_msg: PPAnsiChar; r: PDouble; n: PNativeInt; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tstudentttest1 = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; mean: PDouble; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tstudentttest2 = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; y: px_vector; m: PNativeInt; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tunequalvariancettest = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; y: px_vector; m: PNativeInt; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tmannwhitneyutest = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; y: px_vector; m: PNativeInt; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tjarqueberatest = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; p: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tftest = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; y: px_vector; m: PNativeInt; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tonesamplevariancetest = function(error_msg: PPAnsiChar; x: px_vector; n: PNativeInt; variance: PDouble; bothtails: PDouble; lefttail: PDouble; righttail: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trmatrixschur = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; s: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixgevd = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; isuppera: PByte; b: px_matrix; isupperb: PByte; zneeded: PNativeInt; problemtype: PNativeInt; d: px_vector; z: px_matrix; _xparams: UInt64):Int32T;cdecl;
    Tsmatrixgevdreduce = function(error_msg: PPAnsiChar; result: PByte; a: px_matrix; n: PNativeInt; isuppera: PByte; b: px_matrix; isupperb: PByte; problemtype: PNativeInt; r: px_matrix; isupperr: PByte; _xparams: UInt64):Int32T;cdecl;
    Trmatrixinvupdatesimple = function(error_msg: PPAnsiChar; inva: px_matrix; n: PNativeInt; updrow: PNativeInt; updcolumn: PNativeInt; updval: PDouble; _xparams: UInt64):Int32T;cdecl;
    Trmatrixinvupdaterow = function(error_msg: PPAnsiChar; inva: px_matrix; n: PNativeInt; updrow: PNativeInt; v: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixinvupdatecolumn = function(error_msg: PPAnsiChar; inva: px_matrix; n: PNativeInt; updcolumn: PNativeInt; u: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixinvupdateuv = function(error_msg: PPAnsiChar; inva: px_matrix; n: PNativeInt; u: px_vector; v: px_vector; _xparams: UInt64):Int32T;cdecl;
    Trmatrixludet = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; pivots: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Trmatrixdet = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixludet = function(error_msg: PPAnsiChar; result: PComplex; a: px_matrix; pivots: px_vector; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tcmatrixdet = function(error_msg: PPAnsiChar; result: PComplex; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixcholeskydet = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tspdmatrixdet = function(error_msg: PPAnsiChar; result: PDouble; a: px_matrix; n: PNativeInt; isupper: PByte; _xparams: UInt64):Int32T;cdecl;

    x_polynomialsolverreport = record
         maxerr: Double;
    end;
    px_polynomialsolverreport = ^x_polynomialsolverreport;
    Tpolynomialsolve = function(error_msg: PPAnsiChar; a: px_vector; n: PNativeInt; x: px_vector; rep: px_polynomialsolverreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_nleqstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_nleqstate = procedure(x: Pointer);cdecl;
    Tx_nleqstate_get_needf = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_nleqstate_set_needf = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_nleqstate_get_needfij = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_nleqstate_set_needfij = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_nleqstate_get_xupdated = function(x: Pointer; dst: PByte):Int32T;cdecl;
    Tx_nleqstate_set_xupdated = function(x: Pointer; src: PByte):Int32T;cdecl;
    Tx_nleqstate_get_f = function(x: Pointer; dst: PDouble):Int32T;cdecl;
    Tx_nleqstate_set_f = function(x: Pointer; src: PDouble):Int32T;cdecl;
    Tx_nleqstate_get_fi = function(x: Pointer; dst: Px_vector):Int32T;cdecl;
    Tx_nleqstate_get_j = function(x: Pointer; dst: Px_matrix):Int32T;cdecl;
    Tx_nleqstate_get_x = function(x: Pointer; dst: Px_vector):Int32T;cdecl;

    x_nleqreport = record
         iterationscount: x_int;
         nfunc: x_int;
         njac: x_int;
         terminationtype: x_int;
    end;
    px_nleqreport = ^x_nleqreport;
    Tnleqcreatelm = function(error_msg: PPAnsiChar; n: PNativeInt; m: PNativeInt; x: px_vector; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tnleqsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsf: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tnleqsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;
    Tnleqsetstpmax = function(error_msg: PPAnsiChar; state: PPointer; stpmax: PDouble; _xparams: UInt64):Int32T;cdecl;
    Tnleqiteration = function(error_msg: PPAnsiChar; result: PByte; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tnleqresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_nleqreport; _xparams: UInt64):Int32T;cdecl;
    Tnleqresultsbuf = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_nleqreport; _xparams: UInt64):Int32T;cdecl;
    Tnleqrestartfrom = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;

    x_sparsesolverreport = record
         terminationtype: x_int;
    end;
    px_sparsesolverreport = ^x_sparsesolverreport;
    Tsparsesolvesks = function(error_msg: PPAnsiChar; a: PPointer; n: PNativeInt; isupper: PByte; b: px_vector; rep: px_sparsesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsecholeskysolvesks = function(error_msg: PPAnsiChar; a: PPointer; n: PNativeInt; isupper: PByte; b: px_vector; rep: px_sparsesolverreport; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tsparsesolve = function(error_msg: PPAnsiChar; a: PPointer; n: PNativeInt; b: px_vector; x: px_vector; rep: px_sparsesolverreport; _xparams: UInt64):Int32T;cdecl;
    Tsparselusolve = function(error_msg: PPAnsiChar; a: PPointer; p: px_vector; q: px_vector; n: PNativeInt; b: px_vector; x: px_vector; rep: px_sparsesolverreport; _xparams: UInt64):Int32T;cdecl;
    Tx_obj_copy_lincgstate = function(x: Pointer):Pointer;cdecl;
    Tx_obj_free_lincgstate = procedure(x: Pointer);cdecl;

    x_lincgreport = record
         iterationscount: x_int;
         nmv: x_int;
         terminationtype: x_int;
         r2: Double;
    end;
    px_lincgreport = ^x_lincgreport;
    Tlincgcreate = function(error_msg: PPAnsiChar; n: PNativeInt; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlincgsetstartingpoint = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tlincgsetprecunit = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlincgsetprecdiag = function(error_msg: PPAnsiChar; state: PPointer; _xparams: UInt64):Int32T;cdecl;
    Tlincgsetcond = function(error_msg: PPAnsiChar; state: PPointer; epsf: PDouble; maxits: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlincgsolvesparse = function(error_msg: PPAnsiChar; state: PPointer; a: PPointer; isupper: PByte; b: px_vector; _xparams: UInt64):Int32T;cdecl;
    Tlincgresults = function(error_msg: PPAnsiChar; state: PPointer; x: px_vector; rep: px_lincgreport; _xparams: UInt64):Int32T;cdecl;
    Tlincgsetrestartfreq = function(error_msg: PPAnsiChar; state: PPointer; srf: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlincgsetrupdatefreq = function(error_msg: PPAnsiChar; state: PPointer; freq: PNativeInt; _xparams: UInt64):Int32T;cdecl;
    Tlincgsetxrep = function(error_msg: PPAnsiChar; state: PPointer; needxrep: PByte; _xparams: UInt64):Int32T;cdecl;


const
{$IFDEF FPC}
    xMaskAllExceptions : XExceptionMask = [exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision];
{$ELSE}
    xMaskAllExceptions : XExceptionMask = exAllArithmeticExceptions;
{$ENDIF}
    MaxSystemPathLen = 1024;
{$IFDEF MSWINDOWS}
    PathSeparator : XCharType = '\';
    PlatformLibSuffix : XStringType = '.dll';
{$ELSE}
    PlatformLibSuffix : XStringType = '.so';
{$ENDIF}
    X_OK = 0;
    X_ASSERTION_FAILED = 5;
    
    X_SET     = 1; // data are copied into x-vector/matrix; previous contents of x-structure is freed
    X_CREATE  = 2; // x-vector/matrix is created, its previous contents is ignored
    X_REWRITE = 3; // data are copied into x-structure; size of Python structure must be equal to the x-structure size

    // actions performed by ALGLIB core under arrays
    ACT_UNCHANGED     = 1;
    ACT_SAME_LOCATION = 2;
    ACT_NEW_LOCATION  = 3;

    DT_BOOL = 1;
    DT_INT = 2;
    DT_REAL = 3;
    DT_COMPLEX = 4;

    OWN_CALLER = 1;
    OWN_AE = 2;

    _ALGLIB_SET_GLOBAL_THREADING    = 1001;
    
    _ALGLIB_GET_CORES_COUNT         = 1000;
    _ALGLIB_GET_GLOBAL_THREADING    = 1001;
    _ALGLIB_GET_NWORKERS            = 1002;

var
    // environment properties, set in the initialization section
    XDecimalSeparator: AnsiChar = '.';
{$IFDEF FPC}
{$ELSE}
    XDefFS: TFormatSettings;
{$ENDIF}
    
    // Library-related info
    _lib_alglib:            TSharedLibHandle = 0;
    _shared_lib_filename:   XStringType;
    _shared_lib_name:       XStringType;
{$IFDEF MSWINDOWS}
    WindowsPath:            array [0..MaxSystemPathLen] of XCharType;
{$ENDIF}

    // service functions
    XActivateCoreFunc:      TXActivateCoreFunc;
    XMallocFunc:            TXMallocFunc;
    XFreeFunc:              TXFreeFunc;
    XSetNWorkersFunc:       TXSetNWorkersFunc;
    XSetDbgFlag:            TXSetDbgFlag;
    XGetDbgValue:           TXGetDbgValue;
    XAllocCounterFunc:      TXAllocCounterFunc;
    XAllocCounterActivateFunc:TXAllocCounterActivateFunc;
    XFreeDisposedItemsFunc:   TXFreeDisposedItemsFunc;
    
    // function pointers
    x_obj_copy_kdtreerequestbuffer: Tx_obj_copy_kdtreerequestbuffer = nil;
    x_obj_free_kdtreerequestbuffer : Tx_obj_free_kdtreerequestbuffer = nil;
    x_obj_copy_kdtree: Tx_obj_copy_kdtree = nil;
    x_obj_free_kdtree : Tx_obj_free_kdtree = nil;
    x_kdtreeserialize:   Tkdtreeserialize   = nil;
    x_kdtreeunserialize: Tkdtreeunserialize = nil;
    x_kdtreeserialize_stream:   Tkdtreeserialize_stream   = nil;
    x_kdtreeunserialize_stream: Tkdtreeunserialize_stream = nil;
    x_xv2_kdtreebuild: Tkdtreebuild = nil;
    x_xv2_kdtreebuildtagged: Tkdtreebuildtagged = nil;
    x_xv2_kdtreecreaterequestbuffer: Tkdtreecreaterequestbuffer = nil;
    x_xv2_kdtreequeryknn: Tkdtreequeryknn = nil;
    x_xv2_kdtreetsqueryknn: Tkdtreetsqueryknn = nil;
    x_xv2_kdtreequeryrnn: Tkdtreequeryrnn = nil;
    x_xv2_kdtreequeryrnnu: Tkdtreequeryrnnu = nil;
    x_xv2_kdtreetsqueryrnn: Tkdtreetsqueryrnn = nil;
    x_xv2_kdtreetsqueryrnnu: Tkdtreetsqueryrnnu = nil;
    x_xv2_kdtreequeryaknn: Tkdtreequeryaknn = nil;
    x_xv2_kdtreetsqueryaknn: Tkdtreetsqueryaknn = nil;
    x_xv2_kdtreequerybox: Tkdtreequerybox = nil;
    x_xv2_kdtreetsquerybox: Tkdtreetsquerybox = nil;
    x_xv2_kdtreequeryresultsx: Tkdtreequeryresultsx = nil;
    x_xv2_kdtreequeryresultsxy: Tkdtreequeryresultsxy = nil;
    x_xv2_kdtreequeryresultstags: Tkdtreequeryresultstags = nil;
    x_xv2_kdtreequeryresultsdistances: Tkdtreequeryresultsdistances = nil;
    x_xv2_kdtreetsqueryresultsx: Tkdtreetsqueryresultsx = nil;
    x_xv2_kdtreetsqueryresultsxy: Tkdtreetsqueryresultsxy = nil;
    x_xv2_kdtreetsqueryresultstags: Tkdtreetsqueryresultstags = nil;
    x_xv2_kdtreetsqueryresultsdistances: Tkdtreetsqueryresultsdistances = nil;
    x_xv2_kdtreequeryresultsxi: Tkdtreequeryresultsxi = nil;
    x_xv2_kdtreequeryresultsxyi: Tkdtreequeryresultsxyi = nil;
    x_xv2_kdtreequeryresultstagsi: Tkdtreequeryresultstagsi = nil;
    x_xv2_kdtreequeryresultsdistancesi: Tkdtreequeryresultsdistancesi = nil;
    x_obj_copy_hqrndstate: Tx_obj_copy_hqrndstate = nil;
    x_obj_free_hqrndstate : Tx_obj_free_hqrndstate = nil;
    x_xv2_hqrndrandomize: Thqrndrandomize = nil;
    x_xv2_hqrndseed: Thqrndseed = nil;
    x_xv2_hqrnduniformr: Thqrnduniformr = nil;
    x_xv2_hqrnduniformi: Thqrnduniformi = nil;
    x_xv2_hqrndnormal: Thqrndnormal = nil;
    x_xv2_hqrndunit2: Thqrndunit2 = nil;
    x_xv2_hqrndnormal2: Thqrndnormal2 = nil;
    x_xv2_hqrndexponential: Thqrndexponential = nil;
    x_xv2_hqrnddiscrete: Thqrnddiscrete = nil;
    x_xv2_hqrndcontinuous: Thqrndcontinuous = nil;
    x_xv2_xdebuginitrecord1: Txdebuginitrecord1 = nil;
    x_xv2_xdebugb1count: Txdebugb1count = nil;
    x_xv2_xdebugb1not: Txdebugb1not = nil;
    x_xv2_xdebugb1appendcopy: Txdebugb1appendcopy = nil;
    x_xv2_xdebugb1outeven: Txdebugb1outeven = nil;
    x_xv2_xdebugi1sum: Txdebugi1sum = nil;
    x_xv2_xdebugi1neg: Txdebugi1neg = nil;
    x_xv2_xdebugi1appendcopy: Txdebugi1appendcopy = nil;
    x_xv2_xdebugi1outeven: Txdebugi1outeven = nil;
    x_xv2_xdebugr1sum: Txdebugr1sum = nil;
    x_xv2_xdebugr1neg: Txdebugr1neg = nil;
    x_xv2_xdebugr1appendcopy: Txdebugr1appendcopy = nil;
    x_xv2_xdebugr1outeven: Txdebugr1outeven = nil;
    x_xv2_xdebugc1sum: Txdebugc1sum = nil;
    x_xv2_xdebugc1neg: Txdebugc1neg = nil;
    x_xv2_xdebugc1appendcopy: Txdebugc1appendcopy = nil;
    x_xv2_xdebugc1outeven: Txdebugc1outeven = nil;
    x_xv2_xdebugb2count: Txdebugb2count = nil;
    x_xv2_xdebugb2not: Txdebugb2not = nil;
    x_xv2_xdebugb2transpose: Txdebugb2transpose = nil;
    x_xv2_xdebugb2outsin: Txdebugb2outsin = nil;
    x_xv2_xdebugi2sum: Txdebugi2sum = nil;
    x_xv2_xdebugi2neg: Txdebugi2neg = nil;
    x_xv2_xdebugi2transpose: Txdebugi2transpose = nil;
    x_xv2_xdebugi2outsin: Txdebugi2outsin = nil;
    x_xv2_xdebugr2sum: Txdebugr2sum = nil;
    x_xv2_xdebugr2neg: Txdebugr2neg = nil;
    x_xv2_xdebugr2transpose: Txdebugr2transpose = nil;
    x_xv2_xdebugr2outsin: Txdebugr2outsin = nil;
    x_xv2_xdebugc2sum: Txdebugc2sum = nil;
    x_xv2_xdebugc2neg: Txdebugc2neg = nil;
    x_xv2_xdebugc2transpose: Txdebugc2transpose = nil;
    x_xv2_xdebugc2outsincos: Txdebugc2outsincos = nil;
    x_xv2_xdebugmaskedbiasedproductsum: Txdebugmaskedbiasedproductsum = nil;
    x_obj_copy_odesolverstate: Tx_obj_copy_odesolverstate = nil;
    x_obj_free_odesolverstate : Tx_obj_free_odesolverstate = nil;
    x_odesolverstate_get_needdy : Tx_odesolverstate_get_needdy = nil;
    x_odesolverstate_set_needdy : Tx_odesolverstate_set_needdy = nil;
    x_odesolverstate_get_y : Tx_odesolverstate_get_y = nil;
    x_odesolverstate_get_dy : Tx_odesolverstate_get_dy = nil;
    x_odesolverstate_get_x : Tx_odesolverstate_get_x = nil;
    x_odesolverstate_set_x : Tx_odesolverstate_set_x = nil;
    x_xv2_odesolverrkck: Todesolverrkck = nil;
    x_xv2_odesolveriteration: Todesolveriteration = nil;
    x_xv2_odesolverresults: Todesolverresults = nil;
    x_obj_copy_sparsematrix: Tx_obj_copy_sparsematrix = nil;
    x_obj_free_sparsematrix : Tx_obj_free_sparsematrix = nil;
    x_obj_copy_sparsebuffers: Tx_obj_copy_sparsebuffers = nil;
    x_obj_free_sparsebuffers : Tx_obj_free_sparsebuffers = nil;
    x_xv2_sparsecreate: Tsparsecreate = nil;
    x_xv2_sparsecreatebuf: Tsparsecreatebuf = nil;
    x_xv2_sparsecreatecrs: Tsparsecreatecrs = nil;
    x_xv2_sparsecreatecrsbuf: Tsparsecreatecrsbuf = nil;
    x_xv2_sparsecreatesks: Tsparsecreatesks = nil;
    x_xv2_sparsecreatesksbuf: Tsparsecreatesksbuf = nil;
    x_xv2_sparsecreatesksband: Tsparsecreatesksband = nil;
    x_xv2_sparsecreatesksbandbuf: Tsparsecreatesksbandbuf = nil;
    x_xv2_sparsecopy: Tsparsecopy = nil;
    x_xv2_sparsecopybuf: Tsparsecopybuf = nil;
    x_xv2_sparseswap: Tsparseswap = nil;
    x_xv2_sparseadd: Tsparseadd = nil;
    x_xv2_sparseset: Tsparseset = nil;
    x_xv2_sparseget: Tsparseget = nil;
    x_xv2_sparsegetdiagonal: Tsparsegetdiagonal = nil;
    x_xv2_sparsemv: Tsparsemv = nil;
    x_xv2_sparsemtv: Tsparsemtv = nil;
    x_xv2_sparsegemv: Tsparsegemv = nil;
    x_xv2_sparsemv2: Tsparsemv2 = nil;
    x_xv2_sparsesmv: Tsparsesmv = nil;
    x_xv2_sparsevsmv: Tsparsevsmv = nil;
    x_xv2_sparsemm: Tsparsemm = nil;
    x_xv2_sparsemtm: Tsparsemtm = nil;
    x_xv2_sparsemm2: Tsparsemm2 = nil;
    x_xv2_sparsesmm: Tsparsesmm = nil;
    x_xv2_sparsetrmv: Tsparsetrmv = nil;
    x_xv2_sparsetrsv: Tsparsetrsv = nil;
    x_xv2_sparseresizematrix: Tsparseresizematrix = nil;
    x_xv2_sparseenumerate: Tsparseenumerate = nil;
    x_xv2_sparserewriteexisting: Tsparserewriteexisting = nil;
    x_xv2_sparsegetrow: Tsparsegetrow = nil;
    x_xv2_sparsegetcompressedrow: Tsparsegetcompressedrow = nil;
    x_xv2_sparsetransposesks: Tsparsetransposesks = nil;
    x_xv2_sparsetransposecrs: Tsparsetransposecrs = nil;
    x_xv2_sparsecopytransposecrs: Tsparsecopytransposecrs = nil;
    x_xv2_sparsecopytransposecrsbuf: Tsparsecopytransposecrsbuf = nil;
    x_xv2_sparseconvertto: Tsparseconvertto = nil;
    x_xv2_sparsecopytobuf: Tsparsecopytobuf = nil;
    x_xv2_sparseconverttohash: Tsparseconverttohash = nil;
    x_xv2_sparsecopytohash: Tsparsecopytohash = nil;
    x_xv2_sparsecopytohashbuf: Tsparsecopytohashbuf = nil;
    x_xv2_sparseconverttocrs: Tsparseconverttocrs = nil;
    x_xv2_sparsecopytocrs: Tsparsecopytocrs = nil;
    x_xv2_sparsecopytocrsbuf: Tsparsecopytocrsbuf = nil;
    x_xv2_sparseconverttosks: Tsparseconverttosks = nil;
    x_xv2_sparsecopytosks: Tsparsecopytosks = nil;
    x_xv2_sparsecopytosksbuf: Tsparsecopytosksbuf = nil;
    x_xv2_sparsegetmatrixtype: Tsparsegetmatrixtype = nil;
    x_xv2_sparseishash: Tsparseishash = nil;
    x_xv2_sparseiscrs: Tsparseiscrs = nil;
    x_xv2_sparseissks: Tsparseissks = nil;
    x_xv2_sparsefree: Tsparsefree = nil;
    x_xv2_sparsegetnrows: Tsparsegetnrows = nil;
    x_xv2_sparsegetncols: Tsparsegetncols = nil;
    x_xv2_sparsegetuppercount: Tsparsegetuppercount = nil;
    x_xv2_sparsegetlowercount: Tsparsegetlowercount = nil;
    x_xv2_cmatrixtranspose: Tcmatrixtranspose = nil;
    x_xv2_rmatrixtranspose: Trmatrixtranspose = nil;
    x_xv2_rmatrixenforcesymmetricity: Trmatrixenforcesymmetricity = nil;
    x_xv2_cmatrixcopy: Tcmatrixcopy = nil;
    x_xv2_rvectorcopy: Trvectorcopy = nil;
    x_xv2_rmatrixcopy: Trmatrixcopy = nil;
    x_xv2_rmatrixgencopy: Trmatrixgencopy = nil;
    x_xv2_rmatrixger: Trmatrixger = nil;
    x_xv2_cmatrixrank1: Tcmatrixrank1 = nil;
    x_xv2_rmatrixrank1: Trmatrixrank1 = nil;
    x_xv2_rmatrixgemv: Trmatrixgemv = nil;
    x_xv2_cmatrixmv: Tcmatrixmv = nil;
    x_xv2_rmatrixmv: Trmatrixmv = nil;
    x_xv2_rmatrixsymv: Trmatrixsymv = nil;
    x_xv2_rmatrixsyvmv: Trmatrixsyvmv = nil;
    x_xv2_rmatrixtrsv: Trmatrixtrsv = nil;
    x_xv2_cmatrixrighttrsm: Tcmatrixrighttrsm = nil;
    x_xv2_cmatrixlefttrsm: Tcmatrixlefttrsm = nil;
    x_xv2_rmatrixrighttrsm: Trmatrixrighttrsm = nil;
    x_xv2_rmatrixlefttrsm: Trmatrixlefttrsm = nil;
    x_xv2_cmatrixherk: Tcmatrixherk = nil;
    x_xv2_rmatrixsyrk: Trmatrixsyrk = nil;
    x_xv2_cmatrixgemm: Tcmatrixgemm = nil;
    x_xv2_rmatrixgemm: Trmatrixgemm = nil;
    x_xv2_cmatrixsyrk: Tcmatrixsyrk = nil;
    x_xv2_rmatrixrndorthogonal: Trmatrixrndorthogonal = nil;
    x_xv2_rmatrixrndcond: Trmatrixrndcond = nil;
    x_xv2_cmatrixrndorthogonal: Tcmatrixrndorthogonal = nil;
    x_xv2_cmatrixrndcond: Tcmatrixrndcond = nil;
    x_xv2_smatrixrndcond: Tsmatrixrndcond = nil;
    x_xv2_spdmatrixrndcond: Tspdmatrixrndcond = nil;
    x_xv2_hmatrixrndcond: Thmatrixrndcond = nil;
    x_xv2_hpdmatrixrndcond: Thpdmatrixrndcond = nil;
    x_xv2_rmatrixrndorthogonalfromtheright: Trmatrixrndorthogonalfromtheright = nil;
    x_xv2_rmatrixrndorthogonalfromtheleft: Trmatrixrndorthogonalfromtheleft = nil;
    x_xv2_cmatrixrndorthogonalfromtheright: Tcmatrixrndorthogonalfromtheright = nil;
    x_xv2_cmatrixrndorthogonalfromtheleft: Tcmatrixrndorthogonalfromtheleft = nil;
    x_xv2_smatrixrndmultiply: Tsmatrixrndmultiply = nil;
    x_xv2_hmatrixrndmultiply: Thmatrixrndmultiply = nil;
    x_xv2_rmatrixlu: Trmatrixlu = nil;
    x_xv2_cmatrixlu: Tcmatrixlu = nil;
    x_xv2_hpdmatrixcholesky: Thpdmatrixcholesky = nil;
    x_xv2_spdmatrixcholesky: Tspdmatrixcholesky = nil;
    x_xv2_spdmatrixcholeskyupdateadd1: Tspdmatrixcholeskyupdateadd1 = nil;
    x_xv2_spdmatrixcholeskyupdatefix: Tspdmatrixcholeskyupdatefix = nil;
    x_xv2_spdmatrixcholeskyupdateadd1buf: Tspdmatrixcholeskyupdateadd1buf = nil;
    x_xv2_spdmatrixcholeskyupdatefixbuf: Tspdmatrixcholeskyupdatefixbuf = nil;
    x_xv2_sparselu: Tsparselu = nil;
    x_xv2_sparsecholeskyskyline: Tsparsecholeskyskyline = nil;
    x_xv2_rmatrixrcond1: Trmatrixrcond1 = nil;
    x_xv2_rmatrixrcondinf: Trmatrixrcondinf = nil;
    x_xv2_spdmatrixrcond: Tspdmatrixrcond = nil;
    x_xv2_rmatrixtrrcond1: Trmatrixtrrcond1 = nil;
    x_xv2_rmatrixtrrcondinf: Trmatrixtrrcondinf = nil;
    x_xv2_hpdmatrixrcond: Thpdmatrixrcond = nil;
    x_xv2_cmatrixrcond1: Tcmatrixrcond1 = nil;
    x_xv2_cmatrixrcondinf: Tcmatrixrcondinf = nil;
    x_xv2_rmatrixlurcond1: Trmatrixlurcond1 = nil;
    x_xv2_rmatrixlurcondinf: Trmatrixlurcondinf = nil;
    x_xv2_spdmatrixcholeskyrcond: Tspdmatrixcholeskyrcond = nil;
    x_xv2_hpdmatrixcholeskyrcond: Thpdmatrixcholeskyrcond = nil;
    x_xv2_cmatrixlurcond1: Tcmatrixlurcond1 = nil;
    x_xv2_cmatrixlurcondinf: Tcmatrixlurcondinf = nil;
    x_xv2_cmatrixtrrcond1: Tcmatrixtrrcond1 = nil;
    x_xv2_cmatrixtrrcondinf: Tcmatrixtrrcondinf = nil;
    x_xv2_rmatrixluinverse: Trmatrixluinverse = nil;
    x_xv2_rmatrixinverse: Trmatrixinverse = nil;
    x_xv2_cmatrixluinverse: Tcmatrixluinverse = nil;
    x_xv2_cmatrixinverse: Tcmatrixinverse = nil;
    x_xv2_spdmatrixcholeskyinverse: Tspdmatrixcholeskyinverse = nil;
    x_xv2_spdmatrixinverse: Tspdmatrixinverse = nil;
    x_xv2_hpdmatrixcholeskyinverse: Thpdmatrixcholeskyinverse = nil;
    x_xv2_hpdmatrixinverse: Thpdmatrixinverse = nil;
    x_xv2_rmatrixtrinverse: Trmatrixtrinverse = nil;
    x_xv2_cmatrixtrinverse: Tcmatrixtrinverse = nil;
    x_xv2_rmatrixqr: Trmatrixqr = nil;
    x_xv2_rmatrixlq: Trmatrixlq = nil;
    x_xv2_cmatrixqr: Tcmatrixqr = nil;
    x_xv2_cmatrixlq: Tcmatrixlq = nil;
    x_xv2_rmatrixqrunpackq: Trmatrixqrunpackq = nil;
    x_xv2_rmatrixqrunpackr: Trmatrixqrunpackr = nil;
    x_xv2_rmatrixlqunpackq: Trmatrixlqunpackq = nil;
    x_xv2_rmatrixlqunpackl: Trmatrixlqunpackl = nil;
    x_xv2_cmatrixqrunpackq: Tcmatrixqrunpackq = nil;
    x_xv2_cmatrixqrunpackr: Tcmatrixqrunpackr = nil;
    x_xv2_cmatrixlqunpackq: Tcmatrixlqunpackq = nil;
    x_xv2_cmatrixlqunpackl: Tcmatrixlqunpackl = nil;
    x_xv2_rmatrixbd: Trmatrixbd = nil;
    x_xv2_rmatrixbdunpackq: Trmatrixbdunpackq = nil;
    x_xv2_rmatrixbdmultiplybyq: Trmatrixbdmultiplybyq = nil;
    x_xv2_rmatrixbdunpackpt: Trmatrixbdunpackpt = nil;
    x_xv2_rmatrixbdmultiplybyp: Trmatrixbdmultiplybyp = nil;
    x_xv2_rmatrixbdunpackdiagonals: Trmatrixbdunpackdiagonals = nil;
    x_xv2_rmatrixhessenberg: Trmatrixhessenberg = nil;
    x_xv2_rmatrixhessenbergunpackq: Trmatrixhessenbergunpackq = nil;
    x_xv2_rmatrixhessenbergunpackh: Trmatrixhessenbergunpackh = nil;
    x_xv2_smatrixtd: Tsmatrixtd = nil;
    x_xv2_smatrixtdunpackq: Tsmatrixtdunpackq = nil;
    x_xv2_hmatrixtd: Thmatrixtd = nil;
    x_xv2_hmatrixtdunpackq: Thmatrixtdunpackq = nil;
    x_xv2_rmatrixbdsvd: Trmatrixbdsvd = nil;
    x_xv2_rmatrixsvd: Trmatrixsvd = nil;
    x_xv2_rmatrixsolve: Trmatrixsolve = nil;
    x_xv2_rmatrixsolvefast: Trmatrixsolvefast = nil;
    x_xv2_rmatrixsolvem: Trmatrixsolvem = nil;
    x_xv2_rmatrixsolvemfast: Trmatrixsolvemfast = nil;
    x_xv2_rmatrixlusolve: Trmatrixlusolve = nil;
    x_xv2_rmatrixlusolvefast: Trmatrixlusolvefast = nil;
    x_xv2_rmatrixlusolvem: Trmatrixlusolvem = nil;
    x_xv2_rmatrixlusolvemfast: Trmatrixlusolvemfast = nil;
    x_xv2_rmatrixmixedsolve: Trmatrixmixedsolve = nil;
    x_xv2_rmatrixmixedsolvem: Trmatrixmixedsolvem = nil;
    x_xv2_cmatrixsolvem: Tcmatrixsolvem = nil;
    x_xv2_cmatrixsolvemfast: Tcmatrixsolvemfast = nil;
    x_xv2_cmatrixsolve: Tcmatrixsolve = nil;
    x_xv2_cmatrixsolvefast: Tcmatrixsolvefast = nil;
    x_xv2_cmatrixlusolvem: Tcmatrixlusolvem = nil;
    x_xv2_cmatrixlusolvemfast: Tcmatrixlusolvemfast = nil;
    x_xv2_cmatrixlusolve: Tcmatrixlusolve = nil;
    x_xv2_cmatrixlusolvefast: Tcmatrixlusolvefast = nil;
    x_xv2_cmatrixmixedsolvem: Tcmatrixmixedsolvem = nil;
    x_xv2_cmatrixmixedsolve: Tcmatrixmixedsolve = nil;
    x_xv2_spdmatrixsolvem: Tspdmatrixsolvem = nil;
    x_xv2_spdmatrixsolvemfast: Tspdmatrixsolvemfast = nil;
    x_xv2_spdmatrixsolve: Tspdmatrixsolve = nil;
    x_xv2_spdmatrixsolvefast: Tspdmatrixsolvefast = nil;
    x_xv2_spdmatrixcholeskysolvem: Tspdmatrixcholeskysolvem = nil;
    x_xv2_spdmatrixcholeskysolvemfast: Tspdmatrixcholeskysolvemfast = nil;
    x_xv2_spdmatrixcholeskysolve: Tspdmatrixcholeskysolve = nil;
    x_xv2_spdmatrixcholeskysolvefast: Tspdmatrixcholeskysolvefast = nil;
    x_xv2_hpdmatrixsolvem: Thpdmatrixsolvem = nil;
    x_xv2_hpdmatrixsolvemfast: Thpdmatrixsolvemfast = nil;
    x_xv2_hpdmatrixsolve: Thpdmatrixsolve = nil;
    x_xv2_hpdmatrixsolvefast: Thpdmatrixsolvefast = nil;
    x_xv2_hpdmatrixcholeskysolvem: Thpdmatrixcholeskysolvem = nil;
    x_xv2_hpdmatrixcholeskysolvemfast: Thpdmatrixcholeskysolvemfast = nil;
    x_xv2_hpdmatrixcholeskysolve: Thpdmatrixcholeskysolve = nil;
    x_xv2_hpdmatrixcholeskysolvefast: Thpdmatrixcholeskysolvefast = nil;
    x_xv2_rmatrixsolvels: Trmatrixsolvels = nil;
    x_obj_copy_minlbfgsstate: Tx_obj_copy_minlbfgsstate = nil;
    x_obj_free_minlbfgsstate : Tx_obj_free_minlbfgsstate = nil;
    x_minlbfgsstate_get_needf : Tx_minlbfgsstate_get_needf = nil;
    x_minlbfgsstate_set_needf : Tx_minlbfgsstate_set_needf = nil;
    x_minlbfgsstate_get_needfg : Tx_minlbfgsstate_get_needfg = nil;
    x_minlbfgsstate_set_needfg : Tx_minlbfgsstate_set_needfg = nil;
    x_minlbfgsstate_get_xupdated : Tx_minlbfgsstate_get_xupdated = nil;
    x_minlbfgsstate_set_xupdated : Tx_minlbfgsstate_set_xupdated = nil;
    x_minlbfgsstate_get_f : Tx_minlbfgsstate_get_f = nil;
    x_minlbfgsstate_set_f : Tx_minlbfgsstate_set_f = nil;
    x_minlbfgsstate_get_g : Tx_minlbfgsstate_get_g = nil;
    x_minlbfgsstate_get_x : Tx_minlbfgsstate_get_x = nil;
    x_xv2_minlbfgscreate: Tminlbfgscreate = nil;
    x_xv2_minlbfgscreatef: Tminlbfgscreatef = nil;
    x_xv2_minlbfgssetcond: Tminlbfgssetcond = nil;
    x_xv2_minlbfgssetxrep: Tminlbfgssetxrep = nil;
    x_xv2_minlbfgssetstpmax: Tminlbfgssetstpmax = nil;
    x_xv2_minlbfgssetscale: Tminlbfgssetscale = nil;
    x_xv2_minlbfgssetprecdefault: Tminlbfgssetprecdefault = nil;
    x_xv2_minlbfgssetpreccholesky: Tminlbfgssetpreccholesky = nil;
    x_xv2_minlbfgssetprecdiag: Tminlbfgssetprecdiag = nil;
    x_xv2_minlbfgssetprecscale: Tminlbfgssetprecscale = nil;
    x_xv2_minlbfgsiteration: Tminlbfgsiteration = nil;
    x_xv2_minlbfgsoptguardgradient: Tminlbfgsoptguardgradient = nil;
    x_xv2_minlbfgsoptguardsmoothness: Tminlbfgsoptguardsmoothness = nil;
    x_xv2_minlbfgsoptguardresults: Tminlbfgsoptguardresults = nil;
    x_xv2_minlbfgsoptguardnonc1test0results: Tminlbfgsoptguardnonc1test0results = nil;
    x_xv2_minlbfgsoptguardnonc1test1results: Tminlbfgsoptguardnonc1test1results = nil;
    x_xv2_minlbfgsresults: Tminlbfgsresults = nil;
    x_xv2_minlbfgsresultsbuf: Tminlbfgsresultsbuf = nil;
    x_xv2_minlbfgsrestartfrom: Tminlbfgsrestartfrom = nil;
    x_xv2_minlbfgsrequesttermination: Tminlbfgsrequesttermination = nil;
    x_obj_copy_normestimatorstate: Tx_obj_copy_normestimatorstate = nil;
    x_obj_free_normestimatorstate : Tx_obj_free_normestimatorstate = nil;
    x_xv2_normestimatorcreate: Tnormestimatorcreate = nil;
    x_xv2_normestimatorsetseed: Tnormestimatorsetseed = nil;
    x_xv2_normestimatorestimatesparse: Tnormestimatorestimatesparse = nil;
    x_xv2_normestimatorresults: Tnormestimatorresults = nil;
    x_obj_copy_linlsqrstate: Tx_obj_copy_linlsqrstate = nil;
    x_obj_free_linlsqrstate : Tx_obj_free_linlsqrstate = nil;
    x_xv2_linlsqrcreate: Tlinlsqrcreate = nil;
    x_xv2_linlsqrcreatebuf: Tlinlsqrcreatebuf = nil;
    x_xv2_linlsqrsetprecunit: Tlinlsqrsetprecunit = nil;
    x_xv2_linlsqrsetprecdiag: Tlinlsqrsetprecdiag = nil;
    x_xv2_linlsqrsetlambdai: Tlinlsqrsetlambdai = nil;
    x_xv2_linlsqrsolvesparse: Tlinlsqrsolvesparse = nil;
    x_xv2_linlsqrsetcond: Tlinlsqrsetcond = nil;
    x_xv2_linlsqrresults: Tlinlsqrresults = nil;
    x_xv2_linlsqrsetxrep: Tlinlsqrsetxrep = nil;
    x_xv2_linlsqrpeekiterationscount: Tlinlsqrpeekiterationscount = nil;
    x_xv2_linlsqrrequesttermination: Tlinlsqrrequesttermination = nil;
    x_obj_copy_minbleicstate: Tx_obj_copy_minbleicstate = nil;
    x_obj_free_minbleicstate : Tx_obj_free_minbleicstate = nil;
    x_minbleicstate_get_needf : Tx_minbleicstate_get_needf = nil;
    x_minbleicstate_set_needf : Tx_minbleicstate_set_needf = nil;
    x_minbleicstate_get_needfg : Tx_minbleicstate_get_needfg = nil;
    x_minbleicstate_set_needfg : Tx_minbleicstate_set_needfg = nil;
    x_minbleicstate_get_xupdated : Tx_minbleicstate_get_xupdated = nil;
    x_minbleicstate_set_xupdated : Tx_minbleicstate_set_xupdated = nil;
    x_minbleicstate_get_f : Tx_minbleicstate_get_f = nil;
    x_minbleicstate_set_f : Tx_minbleicstate_set_f = nil;
    x_minbleicstate_get_g : Tx_minbleicstate_get_g = nil;
    x_minbleicstate_get_x : Tx_minbleicstate_get_x = nil;
    x_xv2_minbleiccreate: Tminbleiccreate = nil;
    x_xv2_minbleiccreatef: Tminbleiccreatef = nil;
    x_xv2_minbleicsetbc: Tminbleicsetbc = nil;
    x_xv2_minbleicsetlc: Tminbleicsetlc = nil;
    x_xv2_minbleicsetcond: Tminbleicsetcond = nil;
    x_xv2_minbleicsetscale: Tminbleicsetscale = nil;
    x_xv2_minbleicsetprecdefault: Tminbleicsetprecdefault = nil;
    x_xv2_minbleicsetprecdiag: Tminbleicsetprecdiag = nil;
    x_xv2_minbleicsetprecscale: Tminbleicsetprecscale = nil;
    x_xv2_minbleicsetxrep: Tminbleicsetxrep = nil;
    x_xv2_minbleicsetstpmax: Tminbleicsetstpmax = nil;
    x_xv2_minbleiciteration: Tminbleiciteration = nil;
    x_xv2_minbleicoptguardgradient: Tminbleicoptguardgradient = nil;
    x_xv2_minbleicoptguardsmoothness: Tminbleicoptguardsmoothness = nil;
    x_xv2_minbleicoptguardresults: Tminbleicoptguardresults = nil;
    x_xv2_minbleicoptguardnonc1test0results: Tminbleicoptguardnonc1test0results = nil;
    x_xv2_minbleicoptguardnonc1test1results: Tminbleicoptguardnonc1test1results = nil;
    x_xv2_minbleicresults: Tminbleicresults = nil;
    x_xv2_minbleicresultsbuf: Tminbleicresultsbuf = nil;
    x_xv2_minbleicrestartfrom: Tminbleicrestartfrom = nil;
    x_xv2_minbleicrequesttermination: Tminbleicrequesttermination = nil;
    x_obj_copy_minqpstate: Tx_obj_copy_minqpstate = nil;
    x_obj_free_minqpstate : Tx_obj_free_minqpstate = nil;
    x_xv2_minqpcreate: Tminqpcreate = nil;
    x_xv2_minqpsetlinearterm: Tminqpsetlinearterm = nil;
    x_xv2_minqpsetquadraticterm: Tminqpsetquadraticterm = nil;
    x_xv2_minqpsetquadratictermsparse: Tminqpsetquadratictermsparse = nil;
    x_xv2_minqpsetstartingpoint: Tminqpsetstartingpoint = nil;
    x_xv2_minqpsetorigin: Tminqpsetorigin = nil;
    x_xv2_minqpsetscale: Tminqpsetscale = nil;
    x_xv2_minqpsetscaleautodiag: Tminqpsetscaleautodiag = nil;
    x_xv2_minqpsetalgobleic: Tminqpsetalgobleic = nil;
    x_xv2_minqpsetalgodenseaul: Tminqpsetalgodenseaul = nil;
    x_xv2_minqpsetalgodenseipm: Tminqpsetalgodenseipm = nil;
    x_xv2_minqpsetalgosparseipm: Tminqpsetalgosparseipm = nil;
    x_xv2_minqpsetalgoquickqp: Tminqpsetalgoquickqp = nil;
    x_xv2_minqpsetbc: Tminqpsetbc = nil;
    x_xv2_minqpsetbcall: Tminqpsetbcall = nil;
    x_xv2_minqpsetbci: Tminqpsetbci = nil;
    x_xv2_minqpsetlc: Tminqpsetlc = nil;
    x_xv2_minqpsetlcsparse: Tminqpsetlcsparse = nil;
    x_xv2_minqpsetlcmixed: Tminqpsetlcmixed = nil;
    x_xv2_minqpsetlcmixedlegacy: Tminqpsetlcmixedlegacy = nil;
    x_xv2_minqpsetlc2dense: Tminqpsetlc2dense = nil;
    x_xv2_minqpsetlc2: Tminqpsetlc2 = nil;
    x_xv2_minqpsetlc2mixed: Tminqpsetlc2mixed = nil;
    x_xv2_minqpaddlc2dense: Tminqpaddlc2dense = nil;
    x_xv2_minqpaddlc2: Tminqpaddlc2 = nil;
    x_xv2_minqpoptimize: Tminqpoptimize = nil;
    x_xv2_minqpresults: Tminqpresults = nil;
    x_xv2_minqpresultsbuf: Tminqpresultsbuf = nil;
    x_obj_copy_minlpstate: Tx_obj_copy_minlpstate = nil;
    x_obj_free_minlpstate : Tx_obj_free_minlpstate = nil;
    x_xv2_minlpcreate: Tminlpcreate = nil;
    x_xv2_minlpsetcost: Tminlpsetcost = nil;
    x_xv2_minlpsetscale: Tminlpsetscale = nil;
    x_xv2_minlpsetbc: Tminlpsetbc = nil;
    x_xv2_minlpsetbcall: Tminlpsetbcall = nil;
    x_xv2_minlpsetbci: Tminlpsetbci = nil;
    x_xv2_minlpsetlc: Tminlpsetlc = nil;
    x_xv2_minlpsetlc2dense: Tminlpsetlc2dense = nil;
    x_xv2_minlpsetlc2: Tminlpsetlc2 = nil;
    x_xv2_minlpaddlc2dense: Tminlpaddlc2dense = nil;
    x_xv2_minlpaddlc2: Tminlpaddlc2 = nil;
    x_xv2_minlpoptimize: Tminlpoptimize = nil;
    x_xv2_minlpresults: Tminlpresults = nil;
    x_xv2_minlpresultsbuf: Tminlpresultsbuf = nil;
    x_obj_copy_minnlcstate: Tx_obj_copy_minnlcstate = nil;
    x_obj_free_minnlcstate : Tx_obj_free_minnlcstate = nil;
    x_minnlcstate_get_needfi : Tx_minnlcstate_get_needfi = nil;
    x_minnlcstate_set_needfi : Tx_minnlcstate_set_needfi = nil;
    x_minnlcstate_get_needfij : Tx_minnlcstate_get_needfij = nil;
    x_minnlcstate_set_needfij : Tx_minnlcstate_set_needfij = nil;
    x_minnlcstate_get_xupdated : Tx_minnlcstate_get_xupdated = nil;
    x_minnlcstate_set_xupdated : Tx_minnlcstate_set_xupdated = nil;
    x_minnlcstate_get_f : Tx_minnlcstate_get_f = nil;
    x_minnlcstate_set_f : Tx_minnlcstate_set_f = nil;
    x_minnlcstate_get_fi : Tx_minnlcstate_get_fi = nil;
    x_minnlcstate_get_j : Tx_minnlcstate_get_j = nil;
    x_minnlcstate_get_x : Tx_minnlcstate_get_x = nil;
    x_xv2_minnlccreate: Tminnlccreate = nil;
    x_xv2_minnlccreatef: Tminnlccreatef = nil;
    x_xv2_minnlcsetbc: Tminnlcsetbc = nil;
    x_xv2_minnlcsetlc: Tminnlcsetlc = nil;
    x_xv2_minnlcsetnlc: Tminnlcsetnlc = nil;
    x_xv2_minnlcsetcond: Tminnlcsetcond = nil;
    x_xv2_minnlcsetscale: Tminnlcsetscale = nil;
    x_xv2_minnlcsetprecinexact: Tminnlcsetprecinexact = nil;
    x_xv2_minnlcsetprecexactlowrank: Tminnlcsetprecexactlowrank = nil;
    x_xv2_minnlcsetprecexactrobust: Tminnlcsetprecexactrobust = nil;
    x_xv2_minnlcsetprecnone: Tminnlcsetprecnone = nil;
    x_xv2_minnlcsetstpmax: Tminnlcsetstpmax = nil;
    x_xv2_minnlcsetalgoaul: Tminnlcsetalgoaul = nil;
    x_xv2_minnlcsetalgoslp: Tminnlcsetalgoslp = nil;
    x_xv2_minnlcsetalgosqp: Tminnlcsetalgosqp = nil;
    x_xv2_minnlcsetxrep: Tminnlcsetxrep = nil;
    x_xv2_minnlciteration: Tminnlciteration = nil;
    x_xv2_minnlcoptguardgradient: Tminnlcoptguardgradient = nil;
    x_xv2_minnlcoptguardsmoothness: Tminnlcoptguardsmoothness = nil;
    x_xv2_minnlcoptguardresults: Tminnlcoptguardresults = nil;
    x_xv2_minnlcoptguardnonc1test0results: Tminnlcoptguardnonc1test0results = nil;
    x_xv2_minnlcoptguardnonc1test1results: Tminnlcoptguardnonc1test1results = nil;
    x_xv2_minnlcresults: Tminnlcresults = nil;
    x_xv2_minnlcresultsbuf: Tminnlcresultsbuf = nil;
    x_xv2_minnlcrequesttermination: Tminnlcrequesttermination = nil;
    x_xv2_minnlcrestartfrom: Tminnlcrestartfrom = nil;
    x_obj_copy_minbcstate: Tx_obj_copy_minbcstate = nil;
    x_obj_free_minbcstate : Tx_obj_free_minbcstate = nil;
    x_minbcstate_get_needf : Tx_minbcstate_get_needf = nil;
    x_minbcstate_set_needf : Tx_minbcstate_set_needf = nil;
    x_minbcstate_get_needfg : Tx_minbcstate_get_needfg = nil;
    x_minbcstate_set_needfg : Tx_minbcstate_set_needfg = nil;
    x_minbcstate_get_xupdated : Tx_minbcstate_get_xupdated = nil;
    x_minbcstate_set_xupdated : Tx_minbcstate_set_xupdated = nil;
    x_minbcstate_get_f : Tx_minbcstate_get_f = nil;
    x_minbcstate_set_f : Tx_minbcstate_set_f = nil;
    x_minbcstate_get_g : Tx_minbcstate_get_g = nil;
    x_minbcstate_get_x : Tx_minbcstate_get_x = nil;
    x_xv2_minbccreate: Tminbccreate = nil;
    x_xv2_minbccreatef: Tminbccreatef = nil;
    x_xv2_minbcsetbc: Tminbcsetbc = nil;
    x_xv2_minbcsetcond: Tminbcsetcond = nil;
    x_xv2_minbcsetscale: Tminbcsetscale = nil;
    x_xv2_minbcsetprecdefault: Tminbcsetprecdefault = nil;
    x_xv2_minbcsetprecdiag: Tminbcsetprecdiag = nil;
    x_xv2_minbcsetprecscale: Tminbcsetprecscale = nil;
    x_xv2_minbcsetxrep: Tminbcsetxrep = nil;
    x_xv2_minbcsetstpmax: Tminbcsetstpmax = nil;
    x_xv2_minbciteration: Tminbciteration = nil;
    x_xv2_minbcoptguardgradient: Tminbcoptguardgradient = nil;
    x_xv2_minbcoptguardsmoothness: Tminbcoptguardsmoothness = nil;
    x_xv2_minbcoptguardresults: Tminbcoptguardresults = nil;
    x_xv2_minbcoptguardnonc1test0results: Tminbcoptguardnonc1test0results = nil;
    x_xv2_minbcoptguardnonc1test1results: Tminbcoptguardnonc1test1results = nil;
    x_xv2_minbcresults: Tminbcresults = nil;
    x_xv2_minbcresultsbuf: Tminbcresultsbuf = nil;
    x_xv2_minbcrestartfrom: Tminbcrestartfrom = nil;
    x_xv2_minbcrequesttermination: Tminbcrequesttermination = nil;
    x_obj_copy_minnsstate: Tx_obj_copy_minnsstate = nil;
    x_obj_free_minnsstate : Tx_obj_free_minnsstate = nil;
    x_minnsstate_get_needfi : Tx_minnsstate_get_needfi = nil;
    x_minnsstate_set_needfi : Tx_minnsstate_set_needfi = nil;
    x_minnsstate_get_needfij : Tx_minnsstate_get_needfij = nil;
    x_minnsstate_set_needfij : Tx_minnsstate_set_needfij = nil;
    x_minnsstate_get_xupdated : Tx_minnsstate_get_xupdated = nil;
    x_minnsstate_set_xupdated : Tx_minnsstate_set_xupdated = nil;
    x_minnsstate_get_f : Tx_minnsstate_get_f = nil;
    x_minnsstate_set_f : Tx_minnsstate_set_f = nil;
    x_minnsstate_get_fi : Tx_minnsstate_get_fi = nil;
    x_minnsstate_get_j : Tx_minnsstate_get_j = nil;
    x_minnsstate_get_x : Tx_minnsstate_get_x = nil;
    x_xv2_minnscreate: Tminnscreate = nil;
    x_xv2_minnscreatef: Tminnscreatef = nil;
    x_xv2_minnssetbc: Tminnssetbc = nil;
    x_xv2_minnssetlc: Tminnssetlc = nil;
    x_xv2_minnssetnlc: Tminnssetnlc = nil;
    x_xv2_minnssetcond: Tminnssetcond = nil;
    x_xv2_minnssetscale: Tminnssetscale = nil;
    x_xv2_minnssetalgoags: Tminnssetalgoags = nil;
    x_xv2_minnssetxrep: Tminnssetxrep = nil;
    x_xv2_minnsrequesttermination: Tminnsrequesttermination = nil;
    x_xv2_minnsiteration: Tminnsiteration = nil;
    x_xv2_minnsresults: Tminnsresults = nil;
    x_xv2_minnsresultsbuf: Tminnsresultsbuf = nil;
    x_xv2_minnsrestartfrom: Tminnsrestartfrom = nil;
    x_obj_copy_minasastate: Tx_obj_copy_minasastate = nil;
    x_obj_free_minasastate : Tx_obj_free_minasastate = nil;
    x_minasastate_get_needfg : Tx_minasastate_get_needfg = nil;
    x_minasastate_set_needfg : Tx_minasastate_set_needfg = nil;
    x_minasastate_get_xupdated : Tx_minasastate_get_xupdated = nil;
    x_minasastate_set_xupdated : Tx_minasastate_set_xupdated = nil;
    x_minasastate_get_f : Tx_minasastate_get_f = nil;
    x_minasastate_set_f : Tx_minasastate_set_f = nil;
    x_minasastate_get_g : Tx_minasastate_get_g = nil;
    x_minasastate_get_x : Tx_minasastate_get_x = nil;
    x_xv2_minlbfgssetdefaultpreconditioner: Tminlbfgssetdefaultpreconditioner = nil;
    x_xv2_minlbfgssetcholeskypreconditioner: Tminlbfgssetcholeskypreconditioner = nil;
    x_xv2_minbleicsetbarrierwidth: Tminbleicsetbarrierwidth = nil;
    x_xv2_minbleicsetbarrierdecay: Tminbleicsetbarrierdecay = nil;
    x_xv2_minasacreate: Tminasacreate = nil;
    x_xv2_minasasetcond: Tminasasetcond = nil;
    x_xv2_minasasetxrep: Tminasasetxrep = nil;
    x_xv2_minasasetalgorithm: Tminasasetalgorithm = nil;
    x_xv2_minasasetstpmax: Tminasasetstpmax = nil;
    x_xv2_minasaiteration: Tminasaiteration = nil;
    x_xv2_minasaresults: Tminasaresults = nil;
    x_xv2_minasaresultsbuf: Tminasaresultsbuf = nil;
    x_xv2_minasarestartfrom: Tminasarestartfrom = nil;
    x_obj_copy_mincgstate: Tx_obj_copy_mincgstate = nil;
    x_obj_free_mincgstate : Tx_obj_free_mincgstate = nil;
    x_mincgstate_get_needf : Tx_mincgstate_get_needf = nil;
    x_mincgstate_set_needf : Tx_mincgstate_set_needf = nil;
    x_mincgstate_get_needfg : Tx_mincgstate_get_needfg = nil;
    x_mincgstate_set_needfg : Tx_mincgstate_set_needfg = nil;
    x_mincgstate_get_xupdated : Tx_mincgstate_get_xupdated = nil;
    x_mincgstate_set_xupdated : Tx_mincgstate_set_xupdated = nil;
    x_mincgstate_get_f : Tx_mincgstate_get_f = nil;
    x_mincgstate_set_f : Tx_mincgstate_set_f = nil;
    x_mincgstate_get_g : Tx_mincgstate_get_g = nil;
    x_mincgstate_get_x : Tx_mincgstate_get_x = nil;
    x_xv2_mincgcreate: Tmincgcreate = nil;
    x_xv2_mincgcreatef: Tmincgcreatef = nil;
    x_xv2_mincgsetcond: Tmincgsetcond = nil;
    x_xv2_mincgsetscale: Tmincgsetscale = nil;
    x_xv2_mincgsetxrep: Tmincgsetxrep = nil;
    x_xv2_mincgsetcgtype: Tmincgsetcgtype = nil;
    x_xv2_mincgsetstpmax: Tmincgsetstpmax = nil;
    x_xv2_mincgsuggeststep: Tmincgsuggeststep = nil;
    x_xv2_mincgsetprecdefault: Tmincgsetprecdefault = nil;
    x_xv2_mincgsetprecdiag: Tmincgsetprecdiag = nil;
    x_xv2_mincgsetprecscale: Tmincgsetprecscale = nil;
    x_xv2_mincgiteration: Tmincgiteration = nil;
    x_xv2_mincgoptguardgradient: Tmincgoptguardgradient = nil;
    x_xv2_mincgoptguardsmoothness: Tmincgoptguardsmoothness = nil;
    x_xv2_mincgoptguardresults: Tmincgoptguardresults = nil;
    x_xv2_mincgoptguardnonc1test0results: Tmincgoptguardnonc1test0results = nil;
    x_xv2_mincgoptguardnonc1test1results: Tmincgoptguardnonc1test1results = nil;
    x_xv2_mincgresults: Tmincgresults = nil;
    x_xv2_mincgresultsbuf: Tmincgresultsbuf = nil;
    x_xv2_mincgrestartfrom: Tmincgrestartfrom = nil;
    x_xv2_mincgrequesttermination: Tmincgrequesttermination = nil;
    x_obj_copy_minlmstate: Tx_obj_copy_minlmstate = nil;
    x_obj_free_minlmstate : Tx_obj_free_minlmstate = nil;
    x_minlmstate_get_needf : Tx_minlmstate_get_needf = nil;
    x_minlmstate_set_needf : Tx_minlmstate_set_needf = nil;
    x_minlmstate_get_needfg : Tx_minlmstate_get_needfg = nil;
    x_minlmstate_set_needfg : Tx_minlmstate_set_needfg = nil;
    x_minlmstate_get_needfgh : Tx_minlmstate_get_needfgh = nil;
    x_minlmstate_set_needfgh : Tx_minlmstate_set_needfgh = nil;
    x_minlmstate_get_needfi : Tx_minlmstate_get_needfi = nil;
    x_minlmstate_set_needfi : Tx_minlmstate_set_needfi = nil;
    x_minlmstate_get_needfij : Tx_minlmstate_get_needfij = nil;
    x_minlmstate_set_needfij : Tx_minlmstate_set_needfij = nil;
    x_minlmstate_get_xupdated : Tx_minlmstate_get_xupdated = nil;
    x_minlmstate_set_xupdated : Tx_minlmstate_set_xupdated = nil;
    x_minlmstate_get_f : Tx_minlmstate_get_f = nil;
    x_minlmstate_set_f : Tx_minlmstate_set_f = nil;
    x_minlmstate_get_fi : Tx_minlmstate_get_fi = nil;
    x_minlmstate_get_g : Tx_minlmstate_get_g = nil;
    x_minlmstate_get_h : Tx_minlmstate_get_h = nil;
    x_minlmstate_get_j : Tx_minlmstate_get_j = nil;
    x_minlmstate_get_x : Tx_minlmstate_get_x = nil;
    x_xv2_minlmcreatevj: Tminlmcreatevj = nil;
    x_xv2_minlmcreatev: Tminlmcreatev = nil;
    x_xv2_minlmcreatefgh: Tminlmcreatefgh = nil;
    x_xv2_minlmsetcond: Tminlmsetcond = nil;
    x_xv2_minlmsetxrep: Tminlmsetxrep = nil;
    x_xv2_minlmsetstpmax: Tminlmsetstpmax = nil;
    x_xv2_minlmsetscale: Tminlmsetscale = nil;
    x_xv2_minlmsetbc: Tminlmsetbc = nil;
    x_xv2_minlmsetlc: Tminlmsetlc = nil;
    x_xv2_minlmsetacctype: Tminlmsetacctype = nil;
    x_xv2_minlmiteration: Tminlmiteration = nil;
    x_xv2_minlmoptguardgradient: Tminlmoptguardgradient = nil;
    x_xv2_minlmoptguardresults: Tminlmoptguardresults = nil;
    x_xv2_minlmresults: Tminlmresults = nil;
    x_xv2_minlmresultsbuf: Tminlmresultsbuf = nil;
    x_xv2_minlmrestartfrom: Tminlmrestartfrom = nil;
    x_xv2_minlmrequesttermination: Tminlmrequesttermination = nil;
    x_xv2_minlmcreatevgj: Tminlmcreatevgj = nil;
    x_xv2_minlmcreatefgj: Tminlmcreatefgj = nil;
    x_xv2_minlmcreatefj: Tminlmcreatefj = nil;
    x_obj_copy_eigsubspacestate: Tx_obj_copy_eigsubspacestate = nil;
    x_obj_free_eigsubspacestate : Tx_obj_free_eigsubspacestate = nil;
    x_xv2_eigsubspacecreate: Teigsubspacecreate = nil;
    x_xv2_eigsubspacecreatebuf: Teigsubspacecreatebuf = nil;
    x_xv2_eigsubspacesetcond: Teigsubspacesetcond = nil;
    x_xv2_eigsubspacesetwarmstart: Teigsubspacesetwarmstart = nil;
    x_xv2_eigsubspaceoocstart: Teigsubspaceoocstart = nil;
    x_xv2_eigsubspaceooccontinue: Teigsubspaceooccontinue = nil;
    x_xv2_eigsubspaceoocgetrequestinfo: Teigsubspaceoocgetrequestinfo = nil;
    x_xv2_eigsubspaceoocgetrequestdata: Teigsubspaceoocgetrequestdata = nil;
    x_xv2_eigsubspaceoocsendresult: Teigsubspaceoocsendresult = nil;
    x_xv2_eigsubspaceoocstop: Teigsubspaceoocstop = nil;
    x_xv2_eigsubspacesolvedenses: Teigsubspacesolvedenses = nil;
    x_xv2_eigsubspacesolvesparses: Teigsubspacesolvesparses = nil;
    x_xv2_smatrixevd: Tsmatrixevd = nil;
    x_xv2_smatrixevdr: Tsmatrixevdr = nil;
    x_xv2_smatrixevdi: Tsmatrixevdi = nil;
    x_xv2_hmatrixevd: Thmatrixevd = nil;
    x_xv2_hmatrixevdr: Thmatrixevdr = nil;
    x_xv2_hmatrixevdi: Thmatrixevdi = nil;
    x_xv2_smatrixtdevd: Tsmatrixtdevd = nil;
    x_xv2_smatrixtdevdr: Tsmatrixtdevdr = nil;
    x_xv2_smatrixtdevdi: Tsmatrixtdevdi = nil;
    x_xv2_rmatrixevd: Trmatrixevd = nil;
    x_xv2_samplemoments: Tsamplemoments = nil;
    x_xv2_samplemean: Tsamplemean = nil;
    x_xv2_samplevariance: Tsamplevariance = nil;
    x_xv2_sampleskewness: Tsampleskewness = nil;
    x_xv2_samplekurtosis: Tsamplekurtosis = nil;
    x_xv2_sampleadev: Tsampleadev = nil;
    x_xv2_samplemedian: Tsamplemedian = nil;
    x_xv2_samplepercentile: Tsamplepercentile = nil;
    x_xv2_cov2: Tcov2 = nil;
    x_xv2_pearsoncorr2: Tpearsoncorr2 = nil;
    x_xv2_spearmancorr2: Tspearmancorr2 = nil;
    x_xv2_covm: Tcovm = nil;
    x_xv2_pearsoncorrm: Tpearsoncorrm = nil;
    x_xv2_spearmancorrm: Tspearmancorrm = nil;
    x_xv2_covm2: Tcovm2 = nil;
    x_xv2_pearsoncorrm2: Tpearsoncorrm2 = nil;
    x_xv2_spearmancorrm2: Tspearmancorrm2 = nil;
    x_xv2_rankdata: Trankdata = nil;
    x_xv2_rankdatacentered: Trankdatacentered = nil;
    x_xv2_pearsoncorrelation: Tpearsoncorrelation = nil;
    x_xv2_spearmanrankcorrelation: Tspearmanrankcorrelation = nil;
    x_xv2_pcabuildbasis: Tpcabuildbasis = nil;
    x_xv2_pcatruncatedsubspace: Tpcatruncatedsubspace = nil;
    x_xv2_pcatruncatedsubspacesparse: Tpcatruncatedsubspacesparse = nil;
    x_xv2_dsoptimalsplit2: Tdsoptimalsplit2 = nil;
    x_xv2_dsoptimalsplit2fast: Tdsoptimalsplit2fast = nil;
    x_obj_copy_multilayerperceptron: Tx_obj_copy_multilayerperceptron = nil;
    x_obj_free_multilayerperceptron : Tx_obj_free_multilayerperceptron = nil;
    x_mlpserialize:   Tmlpserialize   = nil;
    x_mlpunserialize: Tmlpunserialize = nil;
    x_mlpserialize_stream:   Tmlpserialize_stream   = nil;
    x_mlpunserialize_stream: Tmlpunserialize_stream = nil;
    x_xv2_mlpcreate0: Tmlpcreate0 = nil;
    x_xv2_mlpcreate1: Tmlpcreate1 = nil;
    x_xv2_mlpcreate2: Tmlpcreate2 = nil;
    x_xv2_mlpcreateb0: Tmlpcreateb0 = nil;
    x_xv2_mlpcreateb1: Tmlpcreateb1 = nil;
    x_xv2_mlpcreateb2: Tmlpcreateb2 = nil;
    x_xv2_mlpcreater0: Tmlpcreater0 = nil;
    x_xv2_mlpcreater1: Tmlpcreater1 = nil;
    x_xv2_mlpcreater2: Tmlpcreater2 = nil;
    x_xv2_mlpcreatec0: Tmlpcreatec0 = nil;
    x_xv2_mlpcreatec1: Tmlpcreatec1 = nil;
    x_xv2_mlpcreatec2: Tmlpcreatec2 = nil;
    x_xv2_mlpcopy: Tmlpcopy = nil;
    x_xv2_mlpcopytunableparameters: Tmlpcopytunableparameters = nil;
    x_xv2_mlprandomize: Tmlprandomize = nil;
    x_xv2_mlprandomizefull: Tmlprandomizefull = nil;
    x_xv2_mlpinitpreprocessor: Tmlpinitpreprocessor = nil;
    x_xv2_mlpproperties: Tmlpproperties = nil;
    x_xv2_mlpgetinputscount: Tmlpgetinputscount = nil;
    x_xv2_mlpgetoutputscount: Tmlpgetoutputscount = nil;
    x_xv2_mlpgetweightscount: Tmlpgetweightscount = nil;
    x_xv2_mlpissoftmax: Tmlpissoftmax = nil;
    x_xv2_mlpgetlayerscount: Tmlpgetlayerscount = nil;
    x_xv2_mlpgetlayersize: Tmlpgetlayersize = nil;
    x_xv2_mlpgetinputscaling: Tmlpgetinputscaling = nil;
    x_xv2_mlpgetoutputscaling: Tmlpgetoutputscaling = nil;
    x_xv2_mlpgetneuroninfo: Tmlpgetneuroninfo = nil;
    x_xv2_mlpgetweight: Tmlpgetweight = nil;
    x_xv2_mlpsetinputscaling: Tmlpsetinputscaling = nil;
    x_xv2_mlpsetoutputscaling: Tmlpsetoutputscaling = nil;
    x_xv2_mlpsetneuroninfo: Tmlpsetneuroninfo = nil;
    x_xv2_mlpsetweight: Tmlpsetweight = nil;
    x_xv2_mlpactivationfunction: Tmlpactivationfunction = nil;
    x_xv2_mlpprocess: Tmlpprocess = nil;
    x_xv2_mlpprocessi: Tmlpprocessi = nil;
    x_xv2_mlperror: Tmlperror = nil;
    x_xv2_mlperrorsparse: Tmlperrorsparse = nil;
    x_xv2_mlperrorn: Tmlperrorn = nil;
    x_xv2_mlpclserror: Tmlpclserror = nil;
    x_xv2_mlprelclserror: Tmlprelclserror = nil;
    x_xv2_mlprelclserrorsparse: Tmlprelclserrorsparse = nil;
    x_xv2_mlpavgce: Tmlpavgce = nil;
    x_xv2_mlpavgcesparse: Tmlpavgcesparse = nil;
    x_xv2_mlprmserror: Tmlprmserror = nil;
    x_xv2_mlprmserrorsparse: Tmlprmserrorsparse = nil;
    x_xv2_mlpavgerror: Tmlpavgerror = nil;
    x_xv2_mlpavgerrorsparse: Tmlpavgerrorsparse = nil;
    x_xv2_mlpavgrelerror: Tmlpavgrelerror = nil;
    x_xv2_mlpavgrelerrorsparse: Tmlpavgrelerrorsparse = nil;
    x_xv2_mlpgrad: Tmlpgrad = nil;
    x_xv2_mlpgradn: Tmlpgradn = nil;
    x_xv2_mlpgradbatch: Tmlpgradbatch = nil;
    x_xv2_mlpgradbatchsparse: Tmlpgradbatchsparse = nil;
    x_xv2_mlpgradbatchsubset: Tmlpgradbatchsubset = nil;
    x_xv2_mlpgradbatchsparsesubset: Tmlpgradbatchsparsesubset = nil;
    x_xv2_mlpgradnbatch: Tmlpgradnbatch = nil;
    x_xv2_mlphessiannbatch: Tmlphessiannbatch = nil;
    x_xv2_mlphessianbatch: Tmlphessianbatch = nil;
    x_xv2_mlpallerrorssubset: Tmlpallerrorssubset = nil;
    x_xv2_mlpallerrorssparsesubset: Tmlpallerrorssparsesubset = nil;
    x_xv2_mlperrorsubset: Tmlperrorsubset = nil;
    x_xv2_mlperrorsparsesubset: Tmlperrorsparsesubset = nil;
    x_xv2_fisherlda: Tfisherlda = nil;
    x_xv2_fisherldan: Tfisherldan = nil;
    x_obj_copy_ssamodel: Tx_obj_copy_ssamodel = nil;
    x_obj_free_ssamodel : Tx_obj_free_ssamodel = nil;
    x_xv2_ssacreate: Tssacreate = nil;
    x_xv2_ssasetwindow: Tssasetwindow = nil;
    x_xv2_ssasetseed: Tssasetseed = nil;
    x_xv2_ssasetpoweruplength: Tssasetpoweruplength = nil;
    x_xv2_ssasetmemorylimit: Tssasetmemorylimit = nil;
    x_xv2_ssaaddsequence: Tssaaddsequence = nil;
    x_xv2_ssaappendpointandupdate: Tssaappendpointandupdate = nil;
    x_xv2_ssaappendsequenceandupdate: Tssaappendsequenceandupdate = nil;
    x_xv2_ssasetalgoprecomputed: Tssasetalgoprecomputed = nil;
    x_xv2_ssasetalgotopkdirect: Tssasetalgotopkdirect = nil;
    x_xv2_ssasetalgotopkrealtime: Tssasetalgotopkrealtime = nil;
    x_xv2_ssacleardata: Tssacleardata = nil;
    x_xv2_ssagetbasis: Tssagetbasis = nil;
    x_xv2_ssagetlrr: Tssagetlrr = nil;
    x_xv2_ssaanalyzelastwindow: Tssaanalyzelastwindow = nil;
    x_xv2_ssaanalyzelast: Tssaanalyzelast = nil;
    x_xv2_ssaanalyzesequence: Tssaanalyzesequence = nil;
    x_xv2_ssaforecastlast: Tssaforecastlast = nil;
    x_xv2_ssaforecastsequence: Tssaforecastsequence = nil;
    x_xv2_ssaforecastavglast: Tssaforecastavglast = nil;
    x_xv2_ssaforecastavgsequence: Tssaforecastavgsequence = nil;
    x_xv2_gammafunction: Tgammafunction = nil;
    x_xv2_lngamma: Tlngamma = nil;
    x_xv2_errorfunction: Terrorfunction = nil;
    x_xv2_errorfunctionc: Terrorfunctionc = nil;
    x_xv2_normaldistribution: Tnormaldistribution = nil;
    x_xv2_normalpdf: Tnormalpdf = nil;
    x_xv2_normalcdf: Tnormalcdf = nil;
    x_xv2_inverf: Tinverf = nil;
    x_xv2_invnormaldistribution: Tinvnormaldistribution = nil;
    x_xv2_invnormalcdf: Tinvnormalcdf = nil;
    x_xv2_bivariatenormalpdf: Tbivariatenormalpdf = nil;
    x_xv2_bivariatenormalcdf: Tbivariatenormalcdf = nil;
    x_xv2_incompletegamma: Tincompletegamma = nil;
    x_xv2_incompletegammac: Tincompletegammac = nil;
    x_xv2_invincompletegammac: Tinvincompletegammac = nil;
    x_obj_copy_linearmodel: Tx_obj_copy_linearmodel = nil;
    x_obj_free_linearmodel : Tx_obj_free_linearmodel = nil;
    x_xv2_lrbuild: Tlrbuild = nil;
    x_xv2_lrbuilds: Tlrbuilds = nil;
    x_xv2_lrbuildzs: Tlrbuildzs = nil;
    x_xv2_lrbuildz: Tlrbuildz = nil;
    x_xv2_lrunpack: Tlrunpack = nil;
    x_xv2_lrpack: Tlrpack = nil;
    x_xv2_lrprocess: Tlrprocess = nil;
    x_xv2_lrrmserror: Tlrrmserror = nil;
    x_xv2_lravgerror: Tlravgerror = nil;
    x_xv2_lravgrelerror: Tlravgrelerror = nil;
    x_xv2_filtersma: Tfiltersma = nil;
    x_xv2_filterema: Tfilterema = nil;
    x_xv2_filterlrma: Tfilterlrma = nil;
    x_obj_copy_logitmodel: Tx_obj_copy_logitmodel = nil;
    x_obj_free_logitmodel : Tx_obj_free_logitmodel = nil;
    x_xv2_mnltrainh: Tmnltrainh = nil;
    x_xv2_mnlprocess: Tmnlprocess = nil;
    x_xv2_mnlprocessi: Tmnlprocessi = nil;
    x_xv2_mnlunpack: Tmnlunpack = nil;
    x_xv2_mnlpack: Tmnlpack = nil;
    x_xv2_mnlavgce: Tmnlavgce = nil;
    x_xv2_mnlrelclserror: Tmnlrelclserror = nil;
    x_xv2_mnlrmserror: Tmnlrmserror = nil;
    x_xv2_mnlavgerror: Tmnlavgerror = nil;
    x_xv2_mnlavgrelerror: Tmnlavgrelerror = nil;
    x_xv2_mnlclserror: Tmnlclserror = nil;
    x_obj_copy_mcpdstate: Tx_obj_copy_mcpdstate = nil;
    x_obj_free_mcpdstate : Tx_obj_free_mcpdstate = nil;
    x_xv2_mcpdcreate: Tmcpdcreate = nil;
    x_xv2_mcpdcreateentry: Tmcpdcreateentry = nil;
    x_xv2_mcpdcreateexit: Tmcpdcreateexit = nil;
    x_xv2_mcpdcreateentryexit: Tmcpdcreateentryexit = nil;
    x_xv2_mcpdaddtrack: Tmcpdaddtrack = nil;
    x_xv2_mcpdsetec: Tmcpdsetec = nil;
    x_xv2_mcpdaddec: Tmcpdaddec = nil;
    x_xv2_mcpdsetbc: Tmcpdsetbc = nil;
    x_xv2_mcpdaddbc: Tmcpdaddbc = nil;
    x_xv2_mcpdsetlc: Tmcpdsetlc = nil;
    x_xv2_mcpdsettikhonovregularizer: Tmcpdsettikhonovregularizer = nil;
    x_xv2_mcpdsetprior: Tmcpdsetprior = nil;
    x_xv2_mcpdsetpredictionweights: Tmcpdsetpredictionweights = nil;
    x_xv2_mcpdsolve: Tmcpdsolve = nil;
    x_xv2_mcpdresults: Tmcpdresults = nil;
    x_obj_copy_mlpensemble: Tx_obj_copy_mlpensemble = nil;
    x_obj_free_mlpensemble : Tx_obj_free_mlpensemble = nil;
    x_mlpeserialize:   Tmlpeserialize   = nil;
    x_mlpeunserialize: Tmlpeunserialize = nil;
    x_mlpeserialize_stream:   Tmlpeserialize_stream   = nil;
    x_mlpeunserialize_stream: Tmlpeunserialize_stream = nil;
    x_xv2_mlpecreate0: Tmlpecreate0 = nil;
    x_xv2_mlpecreate1: Tmlpecreate1 = nil;
    x_xv2_mlpecreate2: Tmlpecreate2 = nil;
    x_xv2_mlpecreateb0: Tmlpecreateb0 = nil;
    x_xv2_mlpecreateb1: Tmlpecreateb1 = nil;
    x_xv2_mlpecreateb2: Tmlpecreateb2 = nil;
    x_xv2_mlpecreater0: Tmlpecreater0 = nil;
    x_xv2_mlpecreater1: Tmlpecreater1 = nil;
    x_xv2_mlpecreater2: Tmlpecreater2 = nil;
    x_xv2_mlpecreatec0: Tmlpecreatec0 = nil;
    x_xv2_mlpecreatec1: Tmlpecreatec1 = nil;
    x_xv2_mlpecreatec2: Tmlpecreatec2 = nil;
    x_xv2_mlpecreatefromnetwork: Tmlpecreatefromnetwork = nil;
    x_xv2_mlperandomize: Tmlperandomize = nil;
    x_xv2_mlpeproperties: Tmlpeproperties = nil;
    x_xv2_mlpeissoftmax: Tmlpeissoftmax = nil;
    x_xv2_mlpeprocess: Tmlpeprocess = nil;
    x_xv2_mlpeprocessi: Tmlpeprocessi = nil;
    x_xv2_mlperelclserror: Tmlperelclserror = nil;
    x_xv2_mlpeavgce: Tmlpeavgce = nil;
    x_xv2_mlpermserror: Tmlpermserror = nil;
    x_xv2_mlpeavgerror: Tmlpeavgerror = nil;
    x_xv2_mlpeavgrelerror: Tmlpeavgrelerror = nil;
    x_obj_copy_mlptrainer: Tx_obj_copy_mlptrainer = nil;
    x_obj_free_mlptrainer : Tx_obj_free_mlptrainer = nil;
    x_xv2_mlptrainlm: Tmlptrainlm = nil;
    x_xv2_mlptrainlbfgs: Tmlptrainlbfgs = nil;
    x_xv2_mlptraines: Tmlptraines = nil;
    x_xv2_mlpkfoldcvlbfgs: Tmlpkfoldcvlbfgs = nil;
    x_xv2_mlpkfoldcvlm: Tmlpkfoldcvlm = nil;
    x_xv2_mlpkfoldcv: Tmlpkfoldcv = nil;
    x_xv2_mlpcreatetrainer: Tmlpcreatetrainer = nil;
    x_xv2_mlpcreatetrainercls: Tmlpcreatetrainercls = nil;
    x_xv2_mlpsetdataset: Tmlpsetdataset = nil;
    x_xv2_mlpsetsparsedataset: Tmlpsetsparsedataset = nil;
    x_xv2_mlpsetdecay: Tmlpsetdecay = nil;
    x_xv2_mlpsetcond: Tmlpsetcond = nil;
    x_xv2_mlpsetalgobatch: Tmlpsetalgobatch = nil;
    x_xv2_mlptrainnetwork: Tmlptrainnetwork = nil;
    x_xv2_mlpstarttraining: Tmlpstarttraining = nil;
    x_xv2_mlpcontinuetraining: Tmlpcontinuetraining = nil;
    x_xv2_mlpebagginglm: Tmlpebagginglm = nil;
    x_xv2_mlpebagginglbfgs: Tmlpebagginglbfgs = nil;
    x_xv2_mlpetraines: Tmlpetraines = nil;
    x_xv2_mlptrainensemblees: Tmlptrainensemblees = nil;
    x_obj_copy_clusterizerstate: Tx_obj_copy_clusterizerstate = nil;
    x_obj_free_clusterizerstate : Tx_obj_free_clusterizerstate = nil;
    x_xv2_clusterizercreate: Tclusterizercreate = nil;
    x_xv2_clusterizersetpoints: Tclusterizersetpoints = nil;
    x_xv2_clusterizersetdistances: Tclusterizersetdistances = nil;
    x_xv2_clusterizersetahcalgo: Tclusterizersetahcalgo = nil;
    x_xv2_clusterizersetkmeanslimits: Tclusterizersetkmeanslimits = nil;
    x_xv2_clusterizersetkmeansinit: Tclusterizersetkmeansinit = nil;
    x_xv2_clusterizersetseed: Tclusterizersetseed = nil;
    x_xv2_clusterizerrunahc: Tclusterizerrunahc = nil;
    x_xv2_clusterizerrunkmeans: Tclusterizerrunkmeans = nil;
    x_xv2_clusterizergetdistances: Tclusterizergetdistances = nil;
    x_xv2_clusterizergetkclusters: Tclusterizergetkclusters = nil;
    x_xv2_clusterizerseparatedbydist: Tclusterizerseparatedbydist = nil;
    x_xv2_clusterizerseparatedbycorr: Tclusterizerseparatedbycorr = nil;
    x_obj_copy_decisionforestbuilder: Tx_obj_copy_decisionforestbuilder = nil;
    x_obj_free_decisionforestbuilder : Tx_obj_free_decisionforestbuilder = nil;
    x_obj_copy_decisionforestbuffer: Tx_obj_copy_decisionforestbuffer = nil;
    x_obj_free_decisionforestbuffer : Tx_obj_free_decisionforestbuffer = nil;
    x_obj_copy_decisionforest: Tx_obj_copy_decisionforest = nil;
    x_obj_free_decisionforest : Tx_obj_free_decisionforest = nil;
    x_dfserialize:   Tdfserialize   = nil;
    x_dfunserialize: Tdfunserialize = nil;
    x_dfserialize_stream:   Tdfserialize_stream   = nil;
    x_dfunserialize_stream: Tdfunserialize_stream = nil;
    x_xv2_dfcreatebuffer: Tdfcreatebuffer = nil;
    x_xv2_dfbuildercreate: Tdfbuildercreate = nil;
    x_xv2_dfbuildersetdataset: Tdfbuildersetdataset = nil;
    x_xv2_dfbuildersetrndvars: Tdfbuildersetrndvars = nil;
    x_xv2_dfbuildersetrndvarsratio: Tdfbuildersetrndvarsratio = nil;
    x_xv2_dfbuildersetrndvarsauto: Tdfbuildersetrndvarsauto = nil;
    x_xv2_dfbuildersetsubsampleratio: Tdfbuildersetsubsampleratio = nil;
    x_xv2_dfbuildersetseed: Tdfbuildersetseed = nil;
    x_xv2_dfbuildersetrdfalgo: Tdfbuildersetrdfalgo = nil;
    x_xv2_dfbuildersetrdfsplitstrength: Tdfbuildersetrdfsplitstrength = nil;
    x_xv2_dfbuildersetimportancetrngini: Tdfbuildersetimportancetrngini = nil;
    x_xv2_dfbuildersetimportanceoobgini: Tdfbuildersetimportanceoobgini = nil;
    x_xv2_dfbuildersetimportancepermutation: Tdfbuildersetimportancepermutation = nil;
    x_xv2_dfbuildersetimportancenone: Tdfbuildersetimportancenone = nil;
    x_xv2_dfbuildergetprogress: Tdfbuildergetprogress = nil;
    x_xv2_dfbuilderpeekprogress: Tdfbuilderpeekprogress = nil;
    x_xv2_dfbuilderbuildrandomforest: Tdfbuilderbuildrandomforest = nil;
    x_xv2_dfbinarycompression: Tdfbinarycompression = nil;
    x_xv2_dfprocess: Tdfprocess = nil;
    x_xv2_dfprocessi: Tdfprocessi = nil;
    x_xv2_dfprocess0: Tdfprocess0 = nil;
    x_xv2_dfclassify: Tdfclassify = nil;
    x_xv2_dftsprocess: Tdftsprocess = nil;
    x_xv2_dfrelclserror: Tdfrelclserror = nil;
    x_xv2_dfavgce: Tdfavgce = nil;
    x_xv2_dfrmserror: Tdfrmserror = nil;
    x_xv2_dfavgerror: Tdfavgerror = nil;
    x_xv2_dfavgrelerror: Tdfavgrelerror = nil;
    x_xv2_dfbuildrandomdecisionforest: Tdfbuildrandomdecisionforest = nil;
    x_xv2_dfbuildrandomdecisionforestx1: Tdfbuildrandomdecisionforestx1 = nil;
    x_obj_copy_knnbuffer: Tx_obj_copy_knnbuffer = nil;
    x_obj_free_knnbuffer : Tx_obj_free_knnbuffer = nil;
    x_obj_copy_knnbuilder: Tx_obj_copy_knnbuilder = nil;
    x_obj_free_knnbuilder : Tx_obj_free_knnbuilder = nil;
    x_obj_copy_knnmodel: Tx_obj_copy_knnmodel = nil;
    x_obj_free_knnmodel : Tx_obj_free_knnmodel = nil;
    x_knnserialize:   Tknnserialize   = nil;
    x_knnunserialize: Tknnunserialize = nil;
    x_knnserialize_stream:   Tknnserialize_stream   = nil;
    x_knnunserialize_stream: Tknnunserialize_stream = nil;
    x_xv2_knncreatebuffer: Tknncreatebuffer = nil;
    x_xv2_knnbuildercreate: Tknnbuildercreate = nil;
    x_xv2_knnbuildersetdatasetreg: Tknnbuildersetdatasetreg = nil;
    x_xv2_knnbuildersetdatasetcls: Tknnbuildersetdatasetcls = nil;
    x_xv2_knnbuildersetnorm: Tknnbuildersetnorm = nil;
    x_xv2_knnbuilderbuildknnmodel: Tknnbuilderbuildknnmodel = nil;
    x_xv2_knnrewritekeps: Tknnrewritekeps = nil;
    x_xv2_knnprocess: Tknnprocess = nil;
    x_xv2_knnprocess0: Tknnprocess0 = nil;
    x_xv2_knnclassify: Tknnclassify = nil;
    x_xv2_knnprocessi: Tknnprocessi = nil;
    x_xv2_knntsprocess: Tknntsprocess = nil;
    x_xv2_knnrelclserror: Tknnrelclserror = nil;
    x_xv2_knnavgce: Tknnavgce = nil;
    x_xv2_knnrmserror: Tknnrmserror = nil;
    x_xv2_knnavgerror: Tknnavgerror = nil;
    x_xv2_knnavgrelerror: Tknnavgrelerror = nil;
    x_xv2_knnallerrors: Tknnallerrors = nil;
    x_xv2_kmeansgenerate: Tkmeansgenerate = nil;
    x_xv2_gqgeneraterec: Tgqgeneraterec = nil;
    x_xv2_gqgenerategausslobattorec: Tgqgenerategausslobattorec = nil;
    x_xv2_gqgenerategaussradaurec: Tgqgenerategaussradaurec = nil;
    x_xv2_gqgenerategausslegendre: Tgqgenerategausslegendre = nil;
    x_xv2_gqgenerategaussjacobi: Tgqgenerategaussjacobi = nil;
    x_xv2_gqgenerategausslaguerre: Tgqgenerategausslaguerre = nil;
    x_xv2_gqgenerategausshermite: Tgqgenerategausshermite = nil;
    x_xv2_gkqgeneraterec: Tgkqgeneraterec = nil;
    x_xv2_gkqgenerategausslegendre: Tgkqgenerategausslegendre = nil;
    x_xv2_gkqgenerategaussjacobi: Tgkqgenerategaussjacobi = nil;
    x_xv2_gkqlegendrecalc: Tgkqlegendrecalc = nil;
    x_xv2_gkqlegendretbl: Tgkqlegendretbl = nil;
    x_obj_copy_autogkstate: Tx_obj_copy_autogkstate = nil;
    x_obj_free_autogkstate : Tx_obj_free_autogkstate = nil;
    x_autogkstate_get_needf : Tx_autogkstate_get_needf = nil;
    x_autogkstate_set_needf : Tx_autogkstate_set_needf = nil;
    x_autogkstate_get_x : Tx_autogkstate_get_x = nil;
    x_autogkstate_set_x : Tx_autogkstate_set_x = nil;
    x_autogkstate_get_xminusa : Tx_autogkstate_get_xminusa = nil;
    x_autogkstate_set_xminusa : Tx_autogkstate_set_xminusa = nil;
    x_autogkstate_get_bminusx : Tx_autogkstate_get_bminusx = nil;
    x_autogkstate_set_bminusx : Tx_autogkstate_set_bminusx = nil;
    x_autogkstate_get_f : Tx_autogkstate_get_f = nil;
    x_autogkstate_set_f : Tx_autogkstate_set_f = nil;
    x_xv2_autogksmooth: Tautogksmooth = nil;
    x_xv2_autogksmoothw: Tautogksmoothw = nil;
    x_xv2_autogksingular: Tautogksingular = nil;
    x_xv2_autogkiteration: Tautogkiteration = nil;
    x_xv2_autogkresults: Tautogkresults = nil;
    x_xv2_fftc1d: Tfftc1d = nil;
    x_xv2_fftc1dinv: Tfftc1dinv = nil;
    x_xv2_fftr1d: Tfftr1d = nil;
    x_xv2_fftr1dinv: Tfftr1dinv = nil;
    x_xv2_fhtr1d: Tfhtr1d = nil;
    x_xv2_fhtr1dinv: Tfhtr1dinv = nil;
    x_xv2_convc1d: Tconvc1d = nil;
    x_xv2_convc1dinv: Tconvc1dinv = nil;
    x_xv2_convc1dcircular: Tconvc1dcircular = nil;
    x_xv2_convc1dcircularinv: Tconvc1dcircularinv = nil;
    x_xv2_convr1d: Tconvr1d = nil;
    x_xv2_convr1dinv: Tconvr1dinv = nil;
    x_xv2_convr1dcircular: Tconvr1dcircular = nil;
    x_xv2_convr1dcircularinv: Tconvr1dcircularinv = nil;
    x_xv2_corrc1d: Tcorrc1d = nil;
    x_xv2_corrc1dcircular: Tcorrc1dcircular = nil;
    x_xv2_corrr1d: Tcorrr1d = nil;
    x_xv2_corrr1dcircular: Tcorrr1dcircular = nil;
    x_obj_copy_idwcalcbuffer: Tx_obj_copy_idwcalcbuffer = nil;
    x_obj_free_idwcalcbuffer : Tx_obj_free_idwcalcbuffer = nil;
    x_obj_copy_idwmodel: Tx_obj_copy_idwmodel = nil;
    x_obj_free_idwmodel : Tx_obj_free_idwmodel = nil;
    x_obj_copy_idwbuilder: Tx_obj_copy_idwbuilder = nil;
    x_obj_free_idwbuilder : Tx_obj_free_idwbuilder = nil;
    x_idwserialize:   Tidwserialize   = nil;
    x_idwunserialize: Tidwunserialize = nil;
    x_idwserialize_stream:   Tidwserialize_stream   = nil;
    x_idwunserialize_stream: Tidwunserialize_stream = nil;
    x_xv2_idwcreatecalcbuffer: Tidwcreatecalcbuffer = nil;
    x_xv2_idwbuildercreate: Tidwbuildercreate = nil;
    x_xv2_idwbuildersetnlayers: Tidwbuildersetnlayers = nil;
    x_xv2_idwbuildersetpoints: Tidwbuildersetpoints = nil;
    x_xv2_idwbuildersetalgomstab: Tidwbuildersetalgomstab = nil;
    x_xv2_idwbuildersetalgotextbookshepard: Tidwbuildersetalgotextbookshepard = nil;
    x_xv2_idwbuildersetalgotextbookmodshepard: Tidwbuildersetalgotextbookmodshepard = nil;
    x_xv2_idwbuildersetuserterm: Tidwbuildersetuserterm = nil;
    x_xv2_idwbuildersetconstterm: Tidwbuildersetconstterm = nil;
    x_xv2_idwbuildersetzeroterm: Tidwbuildersetzeroterm = nil;
    x_xv2_idwcalc1: Tidwcalc1 = nil;
    x_xv2_idwcalc2: Tidwcalc2 = nil;
    x_xv2_idwcalc3: Tidwcalc3 = nil;
    x_xv2_idwcalc: Tidwcalc = nil;
    x_xv2_idwcalcbuf: Tidwcalcbuf = nil;
    x_xv2_idwtscalcbuf: Tidwtscalcbuf = nil;
    x_xv2_idwfit: Tidwfit = nil;
    x_obj_copy_barycentricinterpolant: Tx_obj_copy_barycentricinterpolant = nil;
    x_obj_free_barycentricinterpolant : Tx_obj_free_barycentricinterpolant = nil;
    x_xv2_barycentriccalc: Tbarycentriccalc = nil;
    x_xv2_barycentricdiff1: Tbarycentricdiff1 = nil;
    x_xv2_barycentricdiff2: Tbarycentricdiff2 = nil;
    x_xv2_barycentriclintransx: Tbarycentriclintransx = nil;
    x_xv2_barycentriclintransy: Tbarycentriclintransy = nil;
    x_xv2_barycentricunpack: Tbarycentricunpack = nil;
    x_xv2_barycentricbuildxyw: Tbarycentricbuildxyw = nil;
    x_xv2_barycentricbuildfloaterhormann: Tbarycentricbuildfloaterhormann = nil;
    x_xv2_fitspherels: Tfitspherels = nil;
    x_xv2_fitspheremc: Tfitspheremc = nil;
    x_xv2_fitspheremi: Tfitspheremi = nil;
    x_xv2_fitspheremz: Tfitspheremz = nil;
    x_xv2_fitspherex: Tfitspherex = nil;
    x_obj_copy_spline1dinterpolant: Tx_obj_copy_spline1dinterpolant = nil;
    x_obj_free_spline1dinterpolant : Tx_obj_free_spline1dinterpolant = nil;
    x_xv2_spline1dbuildlinear: Tspline1dbuildlinear = nil;
    x_xv2_spline1dbuildcubic: Tspline1dbuildcubic = nil;
    x_xv2_spline1dgriddiffcubic: Tspline1dgriddiffcubic = nil;
    x_xv2_spline1dgriddiff2cubic: Tspline1dgriddiff2cubic = nil;
    x_xv2_spline1dconvcubic: Tspline1dconvcubic = nil;
    x_xv2_spline1dconvdiffcubic: Tspline1dconvdiffcubic = nil;
    x_xv2_spline1dconvdiff2cubic: Tspline1dconvdiff2cubic = nil;
    x_xv2_spline1dbuildcatmullrom: Tspline1dbuildcatmullrom = nil;
    x_xv2_spline1dbuildhermite: Tspline1dbuildhermite = nil;
    x_xv2_spline1dbuildakima: Tspline1dbuildakima = nil;
    x_xv2_spline1dcalc: Tspline1dcalc = nil;
    x_xv2_spline1ddiff: Tspline1ddiff = nil;
    x_xv2_spline1dunpack: Tspline1dunpack = nil;
    x_xv2_spline1dlintransx: Tspline1dlintransx = nil;
    x_xv2_spline1dlintransy: Tspline1dlintransy = nil;
    x_xv2_spline1dintegrate: Tspline1dintegrate = nil;
    x_xv2_spline1dfit: Tspline1dfit = nil;
    x_xv2_spline1dbuildmonotone: Tspline1dbuildmonotone = nil;
    x_obj_copy_pspline2interpolant: Tx_obj_copy_pspline2interpolant = nil;
    x_obj_free_pspline2interpolant : Tx_obj_free_pspline2interpolant = nil;
    x_obj_copy_pspline3interpolant: Tx_obj_copy_pspline3interpolant = nil;
    x_obj_free_pspline3interpolant : Tx_obj_free_pspline3interpolant = nil;
    x_xv2_pspline2build: Tpspline2build = nil;
    x_xv2_pspline3build: Tpspline3build = nil;
    x_xv2_pspline2buildperiodic: Tpspline2buildperiodic = nil;
    x_xv2_pspline3buildperiodic: Tpspline3buildperiodic = nil;
    x_xv2_pspline2parametervalues: Tpspline2parametervalues = nil;
    x_xv2_pspline3parametervalues: Tpspline3parametervalues = nil;
    x_xv2_pspline2calc: Tpspline2calc = nil;
    x_xv2_pspline3calc: Tpspline3calc = nil;
    x_xv2_pspline2tangent: Tpspline2tangent = nil;
    x_xv2_pspline3tangent: Tpspline3tangent = nil;
    x_xv2_pspline2diff: Tpspline2diff = nil;
    x_xv2_pspline3diff: Tpspline3diff = nil;
    x_xv2_pspline2diff2: Tpspline2diff2 = nil;
    x_xv2_pspline3diff2: Tpspline3diff2 = nil;
    x_xv2_pspline2arclength: Tpspline2arclength = nil;
    x_xv2_pspline3arclength: Tpspline3arclength = nil;
    x_xv2_parametricrdpfixed: Tparametricrdpfixed = nil;
    x_obj_copy_spline3dinterpolant: Tx_obj_copy_spline3dinterpolant = nil;
    x_obj_free_spline3dinterpolant : Tx_obj_free_spline3dinterpolant = nil;
    x_xv2_spline3dcalc: Tspline3dcalc = nil;
    x_xv2_spline3dlintransxyz: Tspline3dlintransxyz = nil;
    x_xv2_spline3dlintransf: Tspline3dlintransf = nil;
    x_xv2_spline3dresampletrilinear: Tspline3dresampletrilinear = nil;
    x_xv2_spline3dbuildtrilinearv: Tspline3dbuildtrilinearv = nil;
    x_xv2_spline3dcalcvbuf: Tspline3dcalcvbuf = nil;
    x_xv2_spline3dcalcv: Tspline3dcalcv = nil;
    x_xv2_spline3dunpackv: Tspline3dunpackv = nil;
    x_xv2_polynomialbar2cheb: Tpolynomialbar2cheb = nil;
    x_xv2_polynomialcheb2bar: Tpolynomialcheb2bar = nil;
    x_xv2_polynomialbar2pow: Tpolynomialbar2pow = nil;
    x_xv2_polynomialpow2bar: Tpolynomialpow2bar = nil;
    x_xv2_polynomialbuild: Tpolynomialbuild = nil;
    x_xv2_polynomialbuildeqdist: Tpolynomialbuildeqdist = nil;
    x_xv2_polynomialbuildcheb1: Tpolynomialbuildcheb1 = nil;
    x_xv2_polynomialbuildcheb2: Tpolynomialbuildcheb2 = nil;
    x_xv2_polynomialcalceqdist: Tpolynomialcalceqdist = nil;
    x_xv2_polynomialcalccheb1: Tpolynomialcalccheb1 = nil;
    x_xv2_polynomialcalccheb2: Tpolynomialcalccheb2 = nil;
    x_obj_copy_lsfitstate: Tx_obj_copy_lsfitstate = nil;
    x_obj_free_lsfitstate : Tx_obj_free_lsfitstate = nil;
    x_lsfitstate_get_needf : Tx_lsfitstate_get_needf = nil;
    x_lsfitstate_set_needf : Tx_lsfitstate_set_needf = nil;
    x_lsfitstate_get_needfg : Tx_lsfitstate_get_needfg = nil;
    x_lsfitstate_set_needfg : Tx_lsfitstate_set_needfg = nil;
    x_lsfitstate_get_needfgh : Tx_lsfitstate_get_needfgh = nil;
    x_lsfitstate_set_needfgh : Tx_lsfitstate_set_needfgh = nil;
    x_lsfitstate_get_xupdated : Tx_lsfitstate_get_xupdated = nil;
    x_lsfitstate_set_xupdated : Tx_lsfitstate_set_xupdated = nil;
    x_lsfitstate_get_c : Tx_lsfitstate_get_c = nil;
    x_lsfitstate_get_f : Tx_lsfitstate_get_f = nil;
    x_lsfitstate_set_f : Tx_lsfitstate_set_f = nil;
    x_lsfitstate_get_g : Tx_lsfitstate_get_g = nil;
    x_lsfitstate_get_h : Tx_lsfitstate_get_h = nil;
    x_lsfitstate_get_x : Tx_lsfitstate_get_x = nil;
    x_xv2_lstfitpiecewiselinearrdpfixed: Tlstfitpiecewiselinearrdpfixed = nil;
    x_xv2_lstfitpiecewiselinearrdp: Tlstfitpiecewiselinearrdp = nil;
    x_xv2_polynomialfit: Tpolynomialfit = nil;
    x_xv2_polynomialfitwc: Tpolynomialfitwc = nil;
    x_xv2_logisticcalc4: Tlogisticcalc4 = nil;
    x_xv2_logisticcalc5: Tlogisticcalc5 = nil;
    x_xv2_logisticfit4: Tlogisticfit4 = nil;
    x_xv2_logisticfit4ec: Tlogisticfit4ec = nil;
    x_xv2_logisticfit5: Tlogisticfit5 = nil;
    x_xv2_logisticfit5ec: Tlogisticfit5ec = nil;
    x_xv2_logisticfit45x: Tlogisticfit45x = nil;
    x_xv2_barycentricfitfloaterhormannwc: Tbarycentricfitfloaterhormannwc = nil;
    x_xv2_barycentricfitfloaterhormann: Tbarycentricfitfloaterhormann = nil;
    x_xv2_spline1dfitcubicwc: Tspline1dfitcubicwc = nil;
    x_xv2_spline1dfithermitewc: Tspline1dfithermitewc = nil;
    x_xv2_spline1dfitcubic: Tspline1dfitcubic = nil;
    x_xv2_spline1dfithermite: Tspline1dfithermite = nil;
    x_xv2_lsfitlinearw: Tlsfitlinearw = nil;
    x_xv2_lsfitlinearwc: Tlsfitlinearwc = nil;
    x_xv2_lsfitlinear: Tlsfitlinear = nil;
    x_xv2_lsfitlinearc: Tlsfitlinearc = nil;
    x_xv2_lsfitcreatewf: Tlsfitcreatewf = nil;
    x_xv2_lsfitcreatef: Tlsfitcreatef = nil;
    x_xv2_lsfitcreatewfg: Tlsfitcreatewfg = nil;
    x_xv2_lsfitcreatefg: Tlsfitcreatefg = nil;
    x_xv2_lsfitcreatewfgh: Tlsfitcreatewfgh = nil;
    x_xv2_lsfitcreatefgh: Tlsfitcreatefgh = nil;
    x_xv2_lsfitsetcond: Tlsfitsetcond = nil;
    x_xv2_lsfitsetstpmax: Tlsfitsetstpmax = nil;
    x_xv2_lsfitsetxrep: Tlsfitsetxrep = nil;
    x_xv2_lsfitsetscale: Tlsfitsetscale = nil;
    x_xv2_lsfitsetbc: Tlsfitsetbc = nil;
    x_xv2_lsfitsetlc: Tlsfitsetlc = nil;
    x_xv2_lsfititeration: Tlsfititeration = nil;
    x_xv2_lsfitresults: Tlsfitresults = nil;
    x_xv2_lsfitsetgradientcheck: Tlsfitsetgradientcheck = nil;
    x_obj_copy_spline2dinterpolant: Tx_obj_copy_spline2dinterpolant = nil;
    x_obj_free_spline2dinterpolant : Tx_obj_free_spline2dinterpolant = nil;
    x_obj_copy_spline2dbuilder: Tx_obj_copy_spline2dbuilder = nil;
    x_obj_free_spline2dbuilder : Tx_obj_free_spline2dbuilder = nil;
    x_spline2dserialize:   Tspline2dserialize   = nil;
    x_spline2dunserialize: Tspline2dunserialize = nil;
    x_spline2dserialize_stream:   Tspline2dserialize_stream   = nil;
    x_spline2dunserialize_stream: Tspline2dunserialize_stream = nil;
    x_xv2_spline2dcalc: Tspline2dcalc = nil;
    x_xv2_spline2ddiff: Tspline2ddiff = nil;
    x_xv2_spline2dcalcvbuf: Tspline2dcalcvbuf = nil;
    x_xv2_spline2dcalcvi: Tspline2dcalcvi = nil;
    x_xv2_spline2dcalcv: Tspline2dcalcv = nil;
    x_xv2_spline2ddiffvi: Tspline2ddiffvi = nil;
    x_xv2_spline2dlintransxy: Tspline2dlintransxy = nil;
    x_xv2_spline2dlintransf: Tspline2dlintransf = nil;
    x_xv2_spline2dcopy: Tspline2dcopy = nil;
    x_xv2_spline2dresamplebicubic: Tspline2dresamplebicubic = nil;
    x_xv2_spline2dresamplebilinear: Tspline2dresamplebilinear = nil;
    x_xv2_spline2dbuildbilinearv: Tspline2dbuildbilinearv = nil;
    x_xv2_spline2dbuildbicubicv: Tspline2dbuildbicubicv = nil;
    x_xv2_spline2dunpackv: Tspline2dunpackv = nil;
    x_xv2_spline2dbuildbilinear: Tspline2dbuildbilinear = nil;
    x_xv2_spline2dbuildbicubic: Tspline2dbuildbicubic = nil;
    x_xv2_spline2dunpack: Tspline2dunpack = nil;
    x_xv2_spline2dbuildercreate: Tspline2dbuildercreate = nil;
    x_xv2_spline2dbuildersetuserterm: Tspline2dbuildersetuserterm = nil;
    x_xv2_spline2dbuildersetlinterm: Tspline2dbuildersetlinterm = nil;
    x_xv2_spline2dbuildersetconstterm: Tspline2dbuildersetconstterm = nil;
    x_xv2_spline2dbuildersetzeroterm: Tspline2dbuildersetzeroterm = nil;
    x_xv2_spline2dbuildersetpoints: Tspline2dbuildersetpoints = nil;
    x_xv2_spline2dbuildersetareaauto: Tspline2dbuildersetareaauto = nil;
    x_xv2_spline2dbuildersetarea: Tspline2dbuildersetarea = nil;
    x_xv2_spline2dbuildersetgrid: Tspline2dbuildersetgrid = nil;
    x_xv2_spline2dbuildersetalgofastddm: Tspline2dbuildersetalgofastddm = nil;
    x_xv2_spline2dbuildersetalgoblocklls: Tspline2dbuildersetalgoblocklls = nil;
    x_xv2_spline2dbuildersetalgonaivells: Tspline2dbuildersetalgonaivells = nil;
    x_xv2_spline2dfit: Tspline2dfit = nil;
    x_obj_copy_rbfcalcbuffer: Tx_obj_copy_rbfcalcbuffer = nil;
    x_obj_free_rbfcalcbuffer : Tx_obj_free_rbfcalcbuffer = nil;
    x_obj_copy_rbfmodel: Tx_obj_copy_rbfmodel = nil;
    x_obj_free_rbfmodel : Tx_obj_free_rbfmodel = nil;
    x_rbfserialize:   Trbfserialize   = nil;
    x_rbfunserialize: Trbfunserialize = nil;
    x_rbfserialize_stream:   Trbfserialize_stream   = nil;
    x_rbfunserialize_stream: Trbfunserialize_stream = nil;
    x_xv2_rbfcreate: Trbfcreate = nil;
    x_xv2_rbfcreatecalcbuffer: Trbfcreatecalcbuffer = nil;
    x_xv2_rbfsetpoints: Trbfsetpoints = nil;
    x_xv2_rbfsetpointsandscales: Trbfsetpointsandscales = nil;
    x_xv2_rbfsetalgoqnn: Trbfsetalgoqnn = nil;
    x_xv2_rbfsetalgomultilayer: Trbfsetalgomultilayer = nil;
    x_xv2_rbfsetalgohierarchical: Trbfsetalgohierarchical = nil;
    x_xv2_rbfsetlinterm: Trbfsetlinterm = nil;
    x_xv2_rbfsetconstterm: Trbfsetconstterm = nil;
    x_xv2_rbfsetzeroterm: Trbfsetzeroterm = nil;
    x_xv2_rbfsetv2bf: Trbfsetv2bf = nil;
    x_xv2_rbfsetv2its: Trbfsetv2its = nil;
    x_xv2_rbfsetv2supportr: Trbfsetv2supportr = nil;
    x_xv2_rbfbuildmodel: Trbfbuildmodel = nil;
    x_xv2_rbfcalc1: Trbfcalc1 = nil;
    x_xv2_rbfcalc2: Trbfcalc2 = nil;
    x_xv2_rbfcalc3: Trbfcalc3 = nil;
    x_xv2_rbfcalc: Trbfcalc = nil;
    x_xv2_rbfcalcbuf: Trbfcalcbuf = nil;
    x_xv2_rbftscalcbuf: Trbftscalcbuf = nil;
    x_xv2_rbfgridcalc2: Trbfgridcalc2 = nil;
    x_xv2_rbfgridcalc2v: Trbfgridcalc2v = nil;
    x_xv2_rbfgridcalc2vsubset: Trbfgridcalc2vsubset = nil;
    x_xv2_rbfgridcalc3v: Trbfgridcalc3v = nil;
    x_xv2_rbfgridcalc3vsubset: Trbfgridcalc3vsubset = nil;
    x_xv2_rbfunpack: Trbfunpack = nil;
    x_xv2_rbfgetmodelversion: Trbfgetmodelversion = nil;
    x_xv2_rbfpeekprogress: Trbfpeekprogress = nil;
    x_xv2_rbfrequesttermination: Trbfrequesttermination = nil;
    x_xv2_nsfitspheremcc: Tnsfitspheremcc = nil;
    x_xv2_nsfitspheremic: Tnsfitspheremic = nil;
    x_xv2_nsfitspheremzc: Tnsfitspheremzc = nil;
    x_xv2_nsfitspherex: Tnsfitspherex = nil;
    x_xv2_spline1dfitpenalized: Tspline1dfitpenalized = nil;
    x_xv2_spline1dfitpenalizedw: Tspline1dfitpenalizedw = nil;
    x_xv2_ellipticintegralk: Tellipticintegralk = nil;
    x_xv2_ellipticintegralkhighprecision: Tellipticintegralkhighprecision = nil;
    x_xv2_incompleteellipticintegralk: Tincompleteellipticintegralk = nil;
    x_xv2_ellipticintegrale: Tellipticintegrale = nil;
    x_xv2_incompleteellipticintegrale: Tincompleteellipticintegrale = nil;
    x_xv2_hermitecalculate: Thermitecalculate = nil;
    x_xv2_hermitesum: Thermitesum = nil;
    x_xv2_hermitecoefficients: Thermitecoefficients = nil;
    x_xv2_dawsonintegral: Tdawsonintegral = nil;
    x_xv2_sinecosineintegrals: Tsinecosineintegrals = nil;
    x_xv2_hyperbolicsinecosineintegrals: Thyperbolicsinecosineintegrals = nil;
    x_xv2_poissondistribution: Tpoissondistribution = nil;
    x_xv2_poissoncdistribution: Tpoissoncdistribution = nil;
    x_xv2_invpoissondistribution: Tinvpoissondistribution = nil;
    x_xv2_besselj0: Tbesselj0 = nil;
    x_xv2_besselj1: Tbesselj1 = nil;
    x_xv2_besseljn: Tbesseljn = nil;
    x_xv2_bessely0: Tbessely0 = nil;
    x_xv2_bessely1: Tbessely1 = nil;
    x_xv2_besselyn: Tbesselyn = nil;
    x_xv2_besseli0: Tbesseli0 = nil;
    x_xv2_besseli1: Tbesseli1 = nil;
    x_xv2_besselk0: Tbesselk0 = nil;
    x_xv2_besselk1: Tbesselk1 = nil;
    x_xv2_besselkn: Tbesselkn = nil;
    x_xv2_incompletebeta: Tincompletebeta = nil;
    x_xv2_invincompletebeta: Tinvincompletebeta = nil;
    x_xv2_fdistribution: Tfdistribution = nil;
    x_xv2_fcdistribution: Tfcdistribution = nil;
    x_xv2_invfdistribution: Tinvfdistribution = nil;
    x_xv2_fresnelintegral: Tfresnelintegral = nil;
    x_xv2_jacobianellipticfunctions: Tjacobianellipticfunctions = nil;
    x_xv2_psi: Tpsi = nil;
    x_xv2_exponentialintegralei: Texponentialintegralei = nil;
    x_xv2_exponentialintegralen: Texponentialintegralen = nil;
    x_xv2_laguerrecalculate: Tlaguerrecalculate = nil;
    x_xv2_laguerresum: Tlaguerresum = nil;
    x_xv2_laguerrecoefficients: Tlaguerrecoefficients = nil;
    x_xv2_chisquaredistribution: Tchisquaredistribution = nil;
    x_xv2_chisquarecdistribution: Tchisquarecdistribution = nil;
    x_xv2_invchisquaredistribution: Tinvchisquaredistribution = nil;
    x_xv2_legendrecalculate: Tlegendrecalculate = nil;
    x_xv2_legendresum: Tlegendresum = nil;
    x_xv2_legendrecoefficients: Tlegendrecoefficients = nil;
    x_xv2_beta: Tbeta = nil;
    x_xv2_chebyshevcalculate: Tchebyshevcalculate = nil;
    x_xv2_chebyshevsum: Tchebyshevsum = nil;
    x_xv2_chebyshevcoefficients: Tchebyshevcoefficients = nil;
    x_xv2_fromchebyshev: Tfromchebyshev = nil;
    x_xv2_studenttdistribution: Tstudenttdistribution = nil;
    x_xv2_invstudenttdistribution: Tinvstudenttdistribution = nil;
    x_xv2_binomialdistribution: Tbinomialdistribution = nil;
    x_xv2_binomialcdistribution: Tbinomialcdistribution = nil;
    x_xv2_invbinomialdistribution: Tinvbinomialdistribution = nil;
    x_xv2_airy: Tairy = nil;
    x_xv2_wilcoxonsignedranktest: Twilcoxonsignedranktest = nil;
    x_xv2_onesamplesigntest: Tonesamplesigntest = nil;
    x_xv2_pearsoncorrelationsignificance: Tpearsoncorrelationsignificance = nil;
    x_xv2_spearmanrankcorrelationsignificance: Tspearmanrankcorrelationsignificance = nil;
    x_xv2_studentttest1: Tstudentttest1 = nil;
    x_xv2_studentttest2: Tstudentttest2 = nil;
    x_xv2_unequalvariancettest: Tunequalvariancettest = nil;
    x_xv2_mannwhitneyutest: Tmannwhitneyutest = nil;
    x_xv2_jarqueberatest: Tjarqueberatest = nil;
    x_xv2_ftest: Tftest = nil;
    x_xv2_onesamplevariancetest: Tonesamplevariancetest = nil;
    x_xv2_rmatrixschur: Trmatrixschur = nil;
    x_xv2_smatrixgevd: Tsmatrixgevd = nil;
    x_xv2_smatrixgevdreduce: Tsmatrixgevdreduce = nil;
    x_xv2_rmatrixinvupdatesimple: Trmatrixinvupdatesimple = nil;
    x_xv2_rmatrixinvupdaterow: Trmatrixinvupdaterow = nil;
    x_xv2_rmatrixinvupdatecolumn: Trmatrixinvupdatecolumn = nil;
    x_xv2_rmatrixinvupdateuv: Trmatrixinvupdateuv = nil;
    x_xv2_rmatrixludet: Trmatrixludet = nil;
    x_xv2_rmatrixdet: Trmatrixdet = nil;
    x_xv2_cmatrixludet: Tcmatrixludet = nil;
    x_xv2_cmatrixdet: Tcmatrixdet = nil;
    x_xv2_spdmatrixcholeskydet: Tspdmatrixcholeskydet = nil;
    x_xv2_spdmatrixdet: Tspdmatrixdet = nil;
    x_xv2_polynomialsolve: Tpolynomialsolve = nil;
    x_obj_copy_nleqstate: Tx_obj_copy_nleqstate = nil;
    x_obj_free_nleqstate : Tx_obj_free_nleqstate = nil;
    x_nleqstate_get_needf : Tx_nleqstate_get_needf = nil;
    x_nleqstate_set_needf : Tx_nleqstate_set_needf = nil;
    x_nleqstate_get_needfij : Tx_nleqstate_get_needfij = nil;
    x_nleqstate_set_needfij : Tx_nleqstate_set_needfij = nil;
    x_nleqstate_get_xupdated : Tx_nleqstate_get_xupdated = nil;
    x_nleqstate_set_xupdated : Tx_nleqstate_set_xupdated = nil;
    x_nleqstate_get_f : Tx_nleqstate_get_f = nil;
    x_nleqstate_set_f : Tx_nleqstate_set_f = nil;
    x_nleqstate_get_fi : Tx_nleqstate_get_fi = nil;
    x_nleqstate_get_j : Tx_nleqstate_get_j = nil;
    x_nleqstate_get_x : Tx_nleqstate_get_x = nil;
    x_xv2_nleqcreatelm: Tnleqcreatelm = nil;
    x_xv2_nleqsetcond: Tnleqsetcond = nil;
    x_xv2_nleqsetxrep: Tnleqsetxrep = nil;
    x_xv2_nleqsetstpmax: Tnleqsetstpmax = nil;
    x_xv2_nleqiteration: Tnleqiteration = nil;
    x_xv2_nleqresults: Tnleqresults = nil;
    x_xv2_nleqresultsbuf: Tnleqresultsbuf = nil;
    x_xv2_nleqrestartfrom: Tnleqrestartfrom = nil;
    x_xv2_sparsesolvesks: Tsparsesolvesks = nil;
    x_xv2_sparsecholeskysolvesks: Tsparsecholeskysolvesks = nil;
    x_xv2_sparsesolve: Tsparsesolve = nil;
    x_xv2_sparselusolve: Tsparselusolve = nil;
    x_obj_copy_lincgstate: Tx_obj_copy_lincgstate = nil;
    x_obj_free_lincgstate : Tx_obj_free_lincgstate = nil;
    x_xv2_lincgcreate: Tlincgcreate = nil;
    x_xv2_lincgsetstartingpoint: Tlincgsetstartingpoint = nil;
    x_xv2_lincgsetprecunit: Tlincgsetprecunit = nil;
    x_xv2_lincgsetprecdiag: Tlincgsetprecdiag = nil;
    x_xv2_lincgsetcond: Tlincgsetcond = nil;
    x_xv2_lincgsolvesparse: Tlincgsolvesparse = nil;
    x_xv2_lincgresults: Tlincgresults = nil;
    x_xv2_lincgsetrestartfreq: Tlincgsetrestartfreq = nil;
    x_xv2_lincgsetrupdatefreq: Tlincgsetrupdatefreq = nil;
    x_xv2_lincgsetxrep: Tlincgsetxrep = nil;


{$IFDEF FPC}
function SetXExceptionMask(mask: TFPUExceptionMask):TFPUExceptionMask;
begin
    Result:=SetExceptionMask(mask);
end;

function XAnsiStrLIComp(S1: PAnsiChar; S2: PAnsiChar; MaxLen: TALGLIBInteger):Integer;
begin
    Result:=AnsiStrLIComp(S1, S2, MaxLen);
end;

function XStrScan(p: PAnsiChar; c: AnsiChar):PAnsiChar;
begin
    Result:=StrScan(p,c);
end;

function XMidStr(const AText: AnsiString; const AStart: TALGLIBInteger; const ACount: TALGLIBInteger):AnsiString;
begin
    Result:=MidStr(AText, AStart, ACount);
end;

function XStrLCopy(Dest: PAnsiChar; const Source: PAnsiChar; MaxLen: TALGLIBInteger): PAnsiChar;
begin
    Result:=StrLCopy(Dest, Source, MaxLen);
end;

function XStrLen(const Str: PAnsiChar):TALGLIBInteger;
begin
    Result:=StrLen(Str);
end;
{$ELSE}
function SetXExceptionMask(mask: TArithmeticExceptionMask):TArithmeticExceptionMask;
begin
    Result:=SetExceptionMask(mask);
end;

function XAnsiStrLIComp(S1: PAnsiChar; S2: PAnsiChar; MaxLen: TALGLIBInteger):Integer;
begin
    Result:=System.AnsiStrings.AnsiStrLIComp(S1, S2, MaxLen);
end;

function XStrScan(p: PAnsiChar; c: AnsiChar):PAnsiChar;
begin
    Result:=System.AnsiStrings.StrScan(p,c);
end;

function XMidStr(const AText: AnsiString; const AStart: TALGLIBInteger; const ACount: TALGLIBInteger):AnsiString;overload;
begin
    Result:=System.AnsiStrings.MidStr(AText, AStart, ACount);
end;

function XMidStr(const AText: string; const AStart: TALGLIBInteger; const ACount: TALGLIBInteger):AnsiString;overload;
begin
    Result:=AnsiString(MidStr(AText, AStart, ACount));
end;

function XStrLCopy(Dest: PAnsiChar; const Source: PAnsiChar; MaxLen: TALGLIBInteger): PAnsiChar;
begin
    Result:=System.AnsiStrings.StrLCopy(Dest, Source, MaxLen);
end;

function XStrLen(const Str: PAnsiChar):TALGLIBInteger;
begin
    Result:=System.AnsiStrings.StrLen(Str);
end;
{$ENDIF}
    
function XLoadLibrary(LibName: XStringType):TSharedLibHandle;
begin
    Result:=LoadLibrary(XPCharType(LibName));
end;
        
function XGetProcAddress(lib: TSharedLibHandle; name: XStringType):Pointer;
begin
    Result:=GetProcAddress(lib, XPCharType(name));
    if Result=nil then
        raise Exception.Create('ALGLIB: unable to load function - '+name);
end;

function x_malloc(cnt: PtrIntT):Pointer;
begin
    Result := nil;
    if XMallocFunc(@Result, cnt)<>0 then
        raise Exception.Create('Error while calling x_malloc()');
end;

procedure x_free(ptr: Pointer);
begin
    XFreeFunc(ptr);
end;

function x_alloc_counter():Int64;
begin
    Result:=Int64(XAllocCounterFunc());
end;

procedure x_alloc_counter_activate();
begin
    XAllocCounterActivateFunc();
end;

procedure x_free_disposed_items();
begin
    XFreeDisposedItemsFunc();
end;

procedure SetNWorkers(nworkers: Integer);
begin
    XSetNWorkersFunc(nworkers);
end;

procedure SetGlobalThreading(xparams: UInt64);
begin
    XSetDbgFlag(_ALGLIB_SET_GLOBAL_THREADING, Int64T(XParams));
end;

function  GetCoresCount():Integer;
begin
    Result:=Integer(XGetDbgValue(_ALGLIB_GET_CORES_COUNT));
end;

function  GetNWorkers():Integer;
begin
    Result:=Integer(XGetDbgValue(_ALGLIB_GET_NWORKERS));
end;

function  GetGlobalThreading():UInt64;
begin
    Result:=UInt64(XGetDbgValue(_ALGLIB_GET_GLOBAL_THREADING));
end;

procedure Touch(var V);
begin
end;

function Bool2Byte(B: Boolean):Byte;
begin
    if B then
        Result:=1
    else
        Result:=0;
end;

function Bool2Uint64T(B: Boolean):UInt64T;
begin
    if B then
        Result:=1
    else
        Result:=0;
end;

function Byte2Bool(B: Byte):Boolean;
begin
    Result:=B<>0;
end;

function Uint64T2Bool(B: Uint64T):Boolean;
begin
    Result:=B<>0;
end;

function Clone(const A: TIVector):TIVector;overload;
var
    I:  TALGLIBInteger;
    R:  TIVector;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
        R[I]:=A[I];
    Result:=R;
end;

function Clone(const A: TVector):TVector;overload;
var
    I:  TALGLIBInteger;
    R:  TVector;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
        R[I]:=A[I];
    Result:=R;
end;

function Clone(const A: TCVector):TCVector;overload;
var
    I:  TALGLIBInteger;
    R:  TCVector;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
        R[I]:=A[I];
    Result:=R;
end;

function Clone(const A: TBVector):TBVector;overload;
var
    I:  TALGLIBInteger;
    R:  TBVector;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
        R[I]:=A[I];
    Result:=R;
end;

function Clone(const A: TIMatrix):TIMatrix;overload;
var
    I,J:    TALGLIBInteger;
    R:      TIMatrix;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
    begin
        SetLength(R[I], High(A[I])+1);
        for J:=Low(A[I]) to High(A[I]) do
            R[I,J]:=A[I,J];
    end;
    Result:=R;
end;

function Clone(const A: TMatrix):TMatrix;overload;
var
    I,J:    TALGLIBInteger;
    R:      TMatrix;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
    begin
        SetLength(R[I], High(A[I])+1);
        for J:=Low(A[I]) to High(A[I]) do
            R[I,J]:=A[I,J];
    end;
    Result:=R;
end;

function Clone(const A: TCMatrix):TCMatrix;overload;
var
    I,J:    TALGLIBInteger;
    R:      TCMatrix;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
    begin
        SetLength(R[I], High(A[I])+1);
        for J:=Low(A[I]) to High(A[I]) do
            R[I,J]:=A[I,J];
    end;
    Result:=R;
end;

function Clone(const A: TBMatrix):TBMatrix;overload;
var
    I,J:    TALGLIBInteger;
    R:      TBMatrix;
begin
    SetLength(R, High(A)+1);
    for I:=Low(A) to High(A) do
    begin
        SetLength(R[I], High(A[I])+1);
        for J:=Low(A[I]) to High(A[I]) do
            R[I,J]:=A[I,J];
    end;
    Result:=R;
end;

/////////////////////////////////////////////////////////////////////////
// complex numbers
/////////////////////////////////////////////////////////////////////////
function C_Abs(const Z : Complex):Double;
var
    W : Double;
    XABS : Double;
    YABS : Double;
    V : Double;
begin
    XABS := Abs(Z.X);
    YABS := Abs(Z.Y);
    W := Max(XABS, YABS);
    V := Min(XABS, YABS);
    if V=0 then
    begin
        Result := W;
    end
    else
    begin
        Result := W*SQRT(1+Sqr(V/W));
    end;
end;


function C_Conj(const Z : Complex):Complex;
begin
    Result.X := Z.X;
    Result.Y := -Z.Y;
end;


function C_Sqr(const Z : Complex):Complex;
begin
    Result.X := Sqr(Z.X)-Sqr(Z.Y);
    Result.Y := 2*Z.X*Z.Y;
end;

{$IFDEF FPC}
operator :=(R: Double) Z:Complex;
begin
    Z.X:=R;
    Z.Y:=0;
end;
{$ELSE}
class operator Complex.Implicit(R: Double):Complex;
begin
    Result.X:=R;
    Result.Y:=0;
end;
{$ENDIF}

function C_Complex(X : Double):Complex;overload;
begin
    Result.X := X;
    Result.Y := 0;
end;


function C_Complex(X,Y : Double):Complex;overload;
begin
    Result.X := X;
    Result.Y := Y;
end;


function C_Complex(Z: Complex):Complex;overload;
begin
    Result := Z;
end;


function C_Opposite(const Z : Complex):Complex;
begin
    C_Opposite.X := -Z.X;
    C_Opposite.Y := -Z.Y;
end;


function C_Add(const Z1 : Complex; const Z2 : Complex):Complex;
begin
    C_Add.X := Z1.X+Z2.X;
    C_Add.Y := Z1.Y+Z2.Y;
end;


function C_Mul(const Z1 : Complex; const Z2 : Complex):Complex;
begin
    C_Mul.X := Z1.X*Z2.X-Z1.Y*Z2.Y;
    C_Mul.Y := Z1.X*Z2.Y+Z1.Y*Z2.X;
end;


function C_AddR(const Z1 : Complex; const R : Double):Complex;
begin
    C_AddR.X := Z1.X+R;
    C_AddR.Y := Z1.Y;
end;


function C_MulR(const Z1 : Complex; const R : Double):Complex;
begin
    C_MulR.X := Z1.X*R;
    C_MulR.Y := Z1.Y*R;
end;


function C_Sub(const Z1 : Complex; const Z2 : Complex):Complex;
begin
    C_Sub.X := Z1.X-Z2.X;
    C_Sub.Y := Z1.Y-Z2.Y;
end;


function C_SubR(const Z1 : Complex; const R : Double):Complex;
begin
    C_SubR.X := Z1.X-R;
    C_SubR.Y := Z1.Y;
end;


function C_RSub(const R : Double; const Z1 : Complex):Complex;
begin
    C_RSub.X := R-Z1.X;
    C_RSub.Y := -Z1.Y;
end;


function C_Div(const Z1 : Complex; const Z2 : Complex):Complex;
var
    A : Double;
    B : Double;
    C : Double;
    D : Double;
    E : Double;
    F : Double;
begin
    A := Z1.X;
    B := Z1.Y;
    C := Z2.X;
    D := Z2.Y;
    if Abs(D)<Abs(C) then
    begin
        E := D/C;
        F := C+D*E;
        C_Div.X := (A+B*E)/F;
        C_Div.Y := (B-A*E)/F;
    end
    else
    begin
        E := C/D;
        F := D+C*E;
        C_Div.X := (B+A*E)/F;
        C_Div.Y := (-A+B*E)/F;
    end;
end;


function C_DivR(const Z1 : Complex; const R : Double):Complex;
begin
    C_DivR.X := Z1.X/R;
    C_DivR.Y := Z1.Y/R;
end;


function C_RDiv(const R : Double; const Z2 : Complex):Complex;
var
    A : Double;
    C : Double;
    D : Double;
    E : Double;
    F : Double;
begin
    A := R;
    C := Z2.X;
    D := Z2.Y;
    if Abs(D)<Abs(C) then
    begin
        E := D/C;
        F := C+D*E;
        C_RDiv.X := A/F;
        C_RDiv.Y := -A*E/F;
    end
    else
    begin
        E := C/D;
        F := D+C*E;
        C_RDiv.X := A*E/F;
        C_RDiv.Y := -A/F;
    end;
end;


function C_Equal(const Z1 : Complex; const Z2 : Complex):Boolean;
begin
    C_Equal := (Z1.X=Z2.X) and (Z1.Y=Z2.Y);
end;


function C_NotEqual(const Z1 : Complex; const Z2 : Complex):Boolean;
begin
    C_NotEqual := (Z1.X<>Z2.X) or (Z1.Y<>Z2.Y);
end;

function C_EqualR(const Z1 : Complex; const R : Double):Boolean;
begin
    C_EqualR := (Z1.X=R) and (Z1.Y=0);
end;

function C_NotEqualR(const Z1 : Complex; const R : Double):Boolean;
begin
    C_NotEqualR := (Z1.X<>R) or (Z1.Y<>0);
end;

function XLen(const A: TVector):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XLen(const A: TIVector):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XLen(const A: TCVector):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XLen(const A: TBVector):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XLen(const A: TSVector):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XRows(const A: TMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XRows(const A: TIMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XRows(const A: TCMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XRows(const A: TBMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XRows(const A: TSMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    Result:=Length(A);
end;

function XCols(const A: TMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    if Length(A)=0 then
        Exit(0);
    Result:=Length(A[0]);
end;

function XCols(const A: TIMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    if Length(A)=0 then
        Exit(0);
    Result:=Length(A[0]);
end;

function XCols(const A: TCMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    if Length(A)=0 then
        Exit(0);
    Result:=Length(A[0]);
end;

function XCols(const A: TBMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    if Length(A)=0 then
        Exit(0);
    Result:=Length(A[0]);
end;

function XCols(const A: TSMatrix):TALGLIBInteger;overload;
begin
    if A=nil then
        Exit(0);
    if Length(A)=0 then
        Exit(0);
    Result:=Length(A[0]);
end;

function StrExplode(const S: AnsiString; Separator: Char):TSVector;
var
    tmpS: string;
    Strings: TStringList;
    N, I: Integer;
begin
    Strings:=TStringList.Create;
    try
        tmpS:=string(S);
        N:=ExtractStrings([Separator], [], PChar(tmpS), Strings);
        SetLength(Result, N);
        for I:=0 to N-1 do
            Result[I]:=AnsiString(Strings.Strings[I]);
    finally
        Strings.Free();
    end;
end;

//
// Parses string of the form "[+-] VALUE delim", returning result as floating-point value,
// and returning pointer past the delim.
//
// Here VALUE can be:
// * NAN
// * INF
// * [ddd] [.,] [ddd] [e|E[sign]ddd]
//
// Parameters:
// * S - pointer to null-terminated string
// * Delim - pointer to null-terminated string containing all possible values of delim
// * R - result variable
// * NewS - initialized by pointer to the delim
// Result: true for success, false for failure
//
function parse_real_delim(s: PAnsiChar; delim: PAnsiChar; var R: Double; var new_s: PAnsiChar):Boolean;
var
    p: PAnsiChar;
    has_digits: Boolean;
    isign: TALGLIBInteger;
    bufmax: TALGLIBInteger;
    buf: array [0..64] of AnsiChar;
begin
    bufmax:=64;
    p:=s;
    
    //
    // Check sign, advance pointer
    //
    isign:=1;
    if (s[0]='-') or (s[0]='+') then
    begin
        isign:=IfThen(s[0]='-', -1, +1);
        Inc(s);
    end;
    
    //
    // Is it NAN or INF?
    //
    if XAnsiStrLIComp(s,'nan',3)=0 then
    begin
        Inc(s,3);
        if (s[0]=Chr(0)) or (XStrScan(delim,s[0])=nil) then
            Exit(False);
        new_s:=s;
        R:=NAN;
        Exit(True);
    end;
    if XAnsiStrLIComp(s,'inf',3)=0 then
    begin
        Inc(s,3);
        if (s[0]=Chr(0)) or (XStrScan(delim,s[0])=nil) then
            Exit(False);
        new_s:=s;
        R:=IfThen(isign>0, Infinity, NegInfinity);
        Exit(True);
    end;
    
    //
    // OK, check that we have normal value of the form
    //
    // [sign] [ddd] [.] [ddd] [e|E[sign]ddd]
    //
    has_digits:=False;
    if (s[0]<>Chr(0)) and (XStrScan('1234567890',s[0])<>nil) then
    begin
        has_digits:=True;
        while (s[0]<>Chr(0)) and (XStrScan('1234567890',s[0])<>nil) do
            Inc(s);
    end;
    if s[0]=XDecimalSeparator then
        Inc(s);
    if (s[0]<>Chr(0)) and (XStrScan('1234567890',s[0])<>nil) then
    begin
        has_digits:=True;
        while (s[0]<>Chr(0)) and (XStrScan('1234567890',s[0])<>nil) do
            Inc(s);
    end;
    if not has_digits then
        Exit(False);
    if (s[0]='e') or (s[0]='E') then
    begin
        Inc(s);
        if (s[0]='-') or (s[0]='+') then
            Inc(s);
        if (s[0]=Chr(0)) or (XStrScan('1234567890',s[0])=nil) then
            Exit(false);
        while (s[0]<>Chr(0)) and (XStrScan('1234567890',s[0])<>nil) do
            Inc(s);
    end;
    if (s[0]=Chr(0)) or (XStrScan(delim,s[0])=nil) then
        Exit(false);
    new_s:=s;

    //
    // Convert to float
    //
    if new_s-p>=bufmax then
        Exit(False);
    XStrLCopy(buf, p, new_s-p); // null terminator appended
    R:=StrToFloat(string(PAnsiChar(@buf[0])));
    Exit(true);
end;


function StrToComplex(S: AnsiString):Complex;
var
    d_result:   Double;
    c_result:   Complex;
    PS, PS1:    PAnsiChar;
begin
    //
    // Add fake delimiter for the purposes of parse_real_delim().
    // Convert to PAnsiChar.
    //
    S:=S+'@';
    PS:=PAnsiChar(S);
    
    //
    // Try to parse as real value
    //
    if parse_real_delim(PS, '@', d_result, PS1) then
        Exit(C_Complex(d_result));

    //
    // Try to parse as "a+bi" or "a-bi"
    //
    if parse_real_delim(PS, '+-', c_result.x, PS1) then
    begin
        PS:=PS1;
        if not parse_real_delim(PS, 'i', c_result.y, PS1) then
            raise Exception.Create('ALGLIB: cant parse value');
        PS:=PS1+1;
        if PS[0]<>'@' then
            raise Exception.Create('ALGLIB: cant parse value');
        Exit(c_result);
    end;
    
    //
    // Try to parse as complex value "bi+a" or "bi-a" or just "bi"
    //
    if parse_real_delim(PS, 'i', c_result.y, PS1) then
    begin
        PS:=PS1+1;
        if PS[0]=Chr(0) then
            raise Exception.Create('ALGLIB: cant parse value');
        if PS[0]='@' then
        begin
            c_result.x:=0;
            Exit(c_result);
        end;
        if (PS[0]<>'+') and (PS[0]<>'-') then
            raise Exception.Create('ALGLIB: cant parse value');
        if not parse_real_delim(PS, '@', c_result.x, PS1) then
            raise Exception.Create('ALGLIB: cant parse value');
        Exit(c_result);
    end;

    // error
    raise Exception.Create('ALGLIB: cant parse value');
end;


function StrNormalize(S: string):string;
var
    N, I: Integer;
{$IFNDEF FPC}
    FS: TFormatSettings;
{$ENDIF}
begin
    // normalize string
    S:=LowerCase(S);
    S:=StringReplace(S, Chr( 9), '', [rfReplaceAll]);
    S:=StringReplace(S, Chr(10), '', [rfReplaceAll]);
    S:=StringReplace(S, Chr(13), '', [rfReplaceAll]);
    S:=StringReplace(S, Chr(32), '', [rfReplaceAll]);
    if S='[]' then
    begin
        SetLength(Result,0);
        Exit;
    end;
    
    // check that string does not contain characters which will be used during reformatting
    N:=Length(S);
    for I:=1 to N do
        if (S[I]='|') or (S[I]='^') then
            raise Exception.Create('ALGLIB: array initializer contains | or ^ characters');
    S:=StringReplace(S, '],[', ']^[', [rfReplaceAll]);
    S:=StringReplace(S, ',',   '|', [rfReplaceAll]);
    
    // handle decimal separator
{$IFDEF FPC}
    S:=StringReplace(S, '.', DefaultFormatSettings.DecimalSeparator, [rfReplaceAll]);
{$ELSE}
    FS:=TFormatSettings.Create;
    S:=StringReplace(S, '.', FS.DecimalSeparator, [rfReplaceAll]);
{$ENDIF}

    // done
    Result:=S;
end;

function Str2SVector(S: string):TSVector;
begin
    // normalize string, convert separating commas to | and ^ (item and line separators)
    S:=StrNormalize(S);
    
    // check that first and last characters are brackets; throw exception otherwise
    if S[1]<>'[' then
        raise Exception.Create('ALGLIB: incorrect beginning of array string: [ expected');
    if S[Length(S)]<>']' then
        raise Exception.Create('ALGLIB: incorrect end of array string: ] expected');
    
    // drop brackets and explode
    Result:=StrExplode(XMidStr(S, 2, Length(S)-2), '|');
end;

function Str2SMatrix(S: string):TSMatrix;
var
    M, N, I, J: Integer;
    TmpVec, TmpVec2: TSVector;
begin
    // normalize string, convert separating commas to | and ^ (item and line separators)
    S:=StrNormalize(S);
    
    // check that first and last characters are brackets; throw exception otherwise
    if S[1]<>'[' then
        raise Exception.Create('ALGLIB: incorrect beginning of array string: [ expected');
    if S[Length(S)]<>']' then
        raise Exception.Create('ALGLIB: incorrect end of array string: ] expected');
    
    // drop outermost brackets and explode to temporary vector of rows
    TmpVec:=StrExplode(XMidStr(S, 2, Length(S)-2), '^');
    M:=Length(TmpVec);
    N:=-1;
    
    // fill result, row by row
    SetLength(Result, M);
    for I:=0 to M-1 do
    begin
        // check that first and last characters are brackets; throw exception otherwise
        if TmpVec[I][1]<>'[' then
            raise Exception.Create('ALGLIB: incorrect beginning of array string: [ expected');
        if TmpVec[I][Length(TmpVec[I])]<>']' then
            raise Exception.Create('ALGLIB: incorrect end of array string: ] expected');
            
        // drop brackets and explode
        TmpVec2:=StrExplode(XMidStr(TmpVec[I], 2, Length(TmpVec[I])-2), '|');
        if I=0 then
            N:=Length(TmpVec2);
        SetLength(Result[I], N);
        for J:=0 to N-1 do
            Result[I,J]:=TmpVec2[J];
        
        // check consistency of sizes
        if Length(Result[I])<>N then
            raise Exception.Create('ALGLIB: non-rectangular array string');
    end;
end;

function Str2BVector(S: string):TBVector;
var
    V:  TSVector;
    I:  TALGLIBInteger;
begin
    V:=Str2SVector(S);
    SetLength(Result, Length(V));
    for I:=0 to Length(V)-1 do
        Result[I]:=V[I]='true';
end;

function Str2IVector(S: string):TIVector;
var
    V:  TSVector;
    I:  TALGLIBInteger;
begin
    V:=Str2SVector(S);
    SetLength(Result, Length(V));
    for I:=0 to Length(V)-1 do
        Result[I]:=StrToInt(string(V[I]));
end;

function Str2Vector(S: string):TVector;
var
    V:  TSVector;
    I:  TALGLIBInteger;
    tmpS: AnsiString;
    PP: PAnsiChar;
    R: Double;
begin
    V:=Str2SVector(S);
    SetLength(Result, Length(V));
    for I:=0 to Length(V)-1 do
    begin
        tmpS:=V[I]+'@';
        if not parse_real_delim(PAnsiChar(tmpS), '@', R, PP) then
            raise Exception.Create('ALGLIB: can not parse string');
        Result[I]:=R;
    end;
end;

function Str2CVector(S: string):TCVector;
var
    V:  TSVector;
    I:  TALGLIBInteger;
begin
    V:=Str2SVector(S);
    SetLength(Result, Length(V));
    for I:=0 to Length(V)-1 do
        Result[I]:=StrToComplex(V[I]);
end;

function Str2BMatrix(S: string):TBMatrix;
var
    V:  TSMatrix;
    M, N, I, J:  TALGLIBInteger;
begin
    V:=Str2SMatrix(S);
    M:=XRows(V);
    N:=XCols(V);
    SetLength(Result, M, N);
    for I:=0 to M-1 do
        for J:=0 to N-1 do
            Result[I,J]:=V[I,J]='true';
end;

function Str2IMatrix(S: string):TIMatrix;
var
    V:  TSMatrix;
    M, N, I, J:  TALGLIBInteger;
begin
    V:=Str2SMatrix(S);
    M:=XRows(V);
    N:=XCols(V);
    SetLength(Result, M, N);
    for I:=0 to M-1 do
        for J:=0 to N-1 do
            Result[I,J]:=StrToInt(string(V[I,J]));
end;

function Str2Matrix( S: string):TMatrix;
var
    V:  TSMatrix;
    M, N, I, J:  TALGLIBInteger;
    tmpS: AnsiString;
    PP: PAnsiChar;
    R: Double;
begin
    V:=Str2SMatrix(S);
    M:=XRows(V);
    N:=XCols(V);
    SetLength(Result, M, N);
    for I:=0 to M-1 do
        for J:=0 to N-1 do
        begin
            tmpS:=V[I,J]+'@';
            if not parse_real_delim(PAnsiChar(tmpS), '@', R, PP) then
                raise Exception.Create('ALGLIB: can not parse string');
            Result[I,J]:=R;
        end;
end;

function Str2CMatrix(S: string):TCMatrix;
var
    V:  TSMatrix;
    M, N, I, J:  TALGLIBInteger;
begin
    V:=Str2SMatrix(S);
    M:=XRows(V);
    N:=XCols(V);
    SetLength(Result, M, N);
    for I:=0 to M-1 do
        for J:=0 to N-1 do
            Result[I,J]:=StrToComplex(V[I,J]);
end;

function XFormat(Const Formatting: string; Const Data: array of const): string;
begin
    Result:=StringReplace(Format(Formatting, Data), ',', '.', [rfReplaceAll]);
end;

function CFmt(const Mask: string; V: Complex):string;
var
    SX, SY, S0: string;
begin
    // print |X|, |Y|, 0 with same mask
    SX:=XFormat(Mask, [Abs(V.X)]);
    SY:=XFormat(Mask, [Abs(V.Y)]);
    S0:=XFormat(Mask, [0.0]);

    // different zero/nonzero patterns
    if (SX<>S0) and (SY<>S0) then
        Exit(IfThen(V.X>0,'','-')+SX+IfThen(V.Y>0,'+','-')+SY+'i');
    if (SX<>S0) and (SY=S0) then
        Exit(IfThen(V.X>0,'','-')+SX);
    if (SX=S0) and (SY<>S0) then
        Exit(IfThen(V.Y>0,'','-')+SY+'i');
    Exit('0');
end;

function FormatComplex(const V: Complex; Dps: Integer):string;
var
    Mask: string;
begin
    Mask:=Format('%%.%d%s', [Abs(Dps), IfThen(Dps>0,'F','E')]);
    Result:=CFmt(Mask, V);
end;

function FormatVector(const V: TBVector; Dps: Integer):string;overload;
var
    I, N: TALGLIBInteger;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    N:=Length(V);
    for i:=0 to N-1 do
    begin
        if i<>0 then
            Result:=Result+',';
        Result:=Result+IfThen(V[i], 'true', 'false');
    end;
    Result:=Result+']';
end;

function FormatVector(const V: TIVector; Dps: Integer):string;overload;
var
    I, N: TALGLIBInteger;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    N:=Length(V);
    for i:=0 to N-1 do
    begin
        if i<>0 then
            Result:=Result+',';
        Result:=Result+IntToStr(V[i]);
    end;
    Result:=Result+']';
end;

function FormatVector(const V: TVector; Dps: Integer):string;overload;
var
    I, N: TALGLIBInteger;
    Mask: string;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    Mask:=Format('%%.%d%s', [Abs(Dps), IfThen(Dps>0,'F','E')]);
    N:=Length(V);
    for i:=0 to N-1 do
    begin
        if I>0 then
            Result:=Result+',';
        if IsNan(V[I]) then
        begin
            Result:=Result+'NAN';
            Continue;
        end;
        if IsInfinite(V[I]) then
        begin
            Result:=Result+IfThen(V[I]>0,'+INF','-INF');
            Continue;
        end;
        Result:=Result+XFormat(Mask,[V[I]]);
    end;
    Result:=Result+']';
end;

function FormatVector(const V: TCVector; Dps: Integer):string;overload;
var
    I, N: TALGLIBInteger;
    Mask: string;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    Mask:=Format('%%.%d%s', [Abs(Dps), IfThen(Dps>0,'F','E')]);
    N:=Length(V);
    for i:=0 to N-1 do
    begin
        if I>0 then
            Result:=Result+',';
        if IsNan(V[I].X) or IsNan(V[I].Y) then
        begin
            Result:=Result+'NAN';
            Continue;
        end;
        if IsInfinite(V[I].X) or IsInfinite(V[I].Y) then
        begin
            Result:=Result+'INF';
            Continue;
        end;
        Result:=Result+CFmt(Mask,V[I]);
    end;
    Result:=Result+']';
end;

function FormatMatrix(const V: TBMatrix; Dps: Integer):string;overload;
var
    I, J, N, M: TALGLIBInteger;
    R: TBVector;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    N:=Length(V);
    SetLength(R, 1);
    for i:=0 to N-1 do
    begin
        if i<>0 then
            Result:=Result+',';
        M:=Length(V[I]);
        if Length(R)<M then
            SetLength(R, M);
        for J:=0 to M-1 do
            R[J]:=V[I,J];
        Result:=Result+FormatVector(R,Dps);
    end;
    Result:=Result+']';
end;

function FormatMatrix(const V: TIMatrix; Dps: Integer):string;overload;
var
    I, J, N, M: TALGLIBInteger;
    R: TIVector;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    N:=Length(V);
    SetLength(R, 1);
    for i:=0 to N-1 do
    begin
        if i<>0 then
            Result:=Result+',';
        M:=Length(V[I]);
        if Length(R)<M then
            SetLength(R, M);
        for J:=0 to M-1 do
            R[J]:=V[I,J];
        Result:=Result+FormatVector(R,Dps);
    end;
    Result:=Result+']';
end;

function FormatMatrix(const V: TMatrix; Dps: Integer):string;overload;
var
    I, J, N, M: TALGLIBInteger;
    R: TVector;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    N:=Length(V);
    SetLength(R, 1);
    for i:=0 to N-1 do
    begin
        if i<>0 then
            Result:=Result+',';
        M:=Length(V[I]);
        if Length(R)<M then
            SetLength(R, M);
        for J:=0 to M-1 do
            R[J]:=V[I,J];
        Result:=Result+FormatVector(R,Dps);
    end;
    Result:=Result+']';
end;

function FormatMatrix(const V: TCMatrix; Dps: Integer):string;overload;
var
    I, J, N, M: TALGLIBInteger;
    R: TCVector;
begin
    if (V=nil) or (Length(V)=0) then
        Exit('[]');
    Result:='[';
    N:=Length(V);
    SetLength(R, 1);
    for i:=0 to N-1 do
    begin
        if i<>0 then
            Result:=Result+',';
        M:=Length(V[I]);
        if Length(R)<M then
            SetLength(R, M);
        for J:=0 to M-1 do
            R[J]:=V[I,J];
        Result:=Result+FormatVector(R,Dps);
    end;
    Result:=Result+']';
end;

procedure x_init_empty(var x: x_vector);overload;
begin
    x.datatype := DT_REAL;
    x.cnt := 0;
    x.owner := OWN_CALLER;
    x.xptr.ptr := nil;
    x.last_action := 1;
end;

//
// conversion from 1D array to x-vector:
//
// x     x-vector. 
// v     array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_vector; const v: TVector; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    ptr: PDouble;
    I: NativeInt;
begin
    // entry info
    elemsize := SizeOf(Double);
    dt:=DT_REAL;
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite vector - types do not match');
        if Length(v)<>x.cnt then
            raise Exception.Create('Trying to rewrite vector - sizes don not match');
        x.last_action := 2;
    end;
    ptr:=PDouble(x.xptr.ptr);
    
    // copy
    for I:=0 to x.cnt-1 do
        ptr[i]:=v[i];
end;

//
// conversion from 1D array to x-vector:
//
// x     x-vector. 
// v     array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_vector; const v: TIVector; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    ptr: PNativeInt;
    I: NativeInt;
begin
    // entry info
    elemsize := SizeOf(NativeInt);
    dt:=DT_INT;
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite vector - types do not match');
        if Length(v)<>x.cnt then
            raise Exception.Create('Trying to rewrite vector - sizes don not match');
        x.last_action := 2;
    end;
    ptr:=PNativeInt(x.xptr.ptr);
    
    // copy
    for I:=0 to x.cnt-1 do
        ptr[i]:=v[i];
end;


//
// conversion from 1D array to x-vector:
//
// x     x-vector. 
// v     array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_vector; const v: TBVector; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    ptr: PByte;
    I: NativeInt;
begin
    // entry info
    elemsize := SizeOf(Byte);
    dt:=DT_BOOL;
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite vector - types do not match');
        if Length(v)<>x.cnt then
            raise Exception.Create('Trying to rewrite vector - sizes don not match');
        x.last_action := 2;
    end;
    ptr:=PByte(x.xptr.ptr);
    
    // copy
    for I:=0 to x.cnt-1 do
        ptr[i]:=Bool2Byte(v[i]);
end;

//
// conversion from 1D array to x-vector:
//
// x     x-vector. 
// v     array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_vector; const v: TCVector; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    ptr: PComplex;
    I: NativeInt;
begin
    // entry info
    elemsize := SizeOf(Complex);
    dt:=DT_COMPLEX;
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.datatype := dt;
        x.cnt := Length(v);
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.cnt);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite vector - types do not match');
        if Length(v)<>x.cnt then
            raise Exception.Create('Trying to rewrite vector - sizes don not match');
        x.last_action := 2;
    end;
    ptr:=PComplex(x.xptr.ptr);
    
    // copy
    for I:=0 to x.cnt-1 do
    begin
        ptr[i].x:=v[i].x;
        ptr[i].y:=v[i].y;
    end;
end;

//
// conversion from 2D array to x-matrix:
//
// x     x-matrix.
// v     2D array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_matrix; const v: TMatrix; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    rows, cols: NativeInt;
    i, j: NativeInt;
    ptr: PDouble;
begin
    dt:=DT_REAL;
    elemsize := SizeOf(Double);
    
    // determine size
    rows := Length(v);
    if rows>0 then
        cols := Length(v[0])
    else
        cols := 0;
    if cols=0 then
        rows := 0;
    for i:=0 to rows-1 do
        if Length(v[i])<>cols then
            raise Exception.Create('Non-rectangular matrix passed');
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite matrix - types do not match');
        if (rows<>x.rows) or (cols<>x.cols) then
            raise Exception.Create('Trying to rewrite vector - sizes do not match');
        x.last_action := 2;
    end;
    
    // copy
    ptr:=PDouble(x.xptr.ptr);
    for i:=0 to rows-1 do
    begin
        for j:=0 to cols-1 do
            ptr[j] := v[i,j];
        ptr:=ptr+x.stride;
    end;
end;

//
// conversion from 2D array to x-matrix:
//
// x     x-matrix.
// v     2D array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_matrix; const v: TBMatrix; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    rows, cols: NativeInt;
    i, j: NativeInt;
    ptr: PByte;
begin
    dt:=DT_BOOL;
    elemsize := SizeOf(Byte);
    
    // determine size
    rows := Length(v);
    if rows>0 then
        cols := Length(v[0])
    else
        cols := 0;
    if cols=0 then
        rows := 0;
    for i:=0 to rows-1 do
        if Length(v[i])<>cols then
            raise Exception.Create('Non-rectangular matrix passed');
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite matrix - types do not match');
        if (rows<>x.rows) or (cols<>x.cols) then
            raise Exception.Create('Trying to rewrite vector - sizes do not match');
        x.last_action := 2;
    end;
    
    // copy
    ptr:=PByte(x.xptr.ptr);
    for i:=0 to rows-1 do
    begin
        for j:=0 to cols-1 do
            ptr[j] := Bool2Byte(v[i,j]);
        ptr:=ptr+x.stride;
    end;
end;

//
// conversion from 2D array to x-matrix:
//
// x     x-matrix.
// v     2D array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_matrix; const v: TIMatrix; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    rows, cols: NativeInt;
    i, j: NativeInt;
    ptr:  PNativeInt;
begin
    dt:=DT_INT;
    elemsize := SizeOf(NativeInt);
    
    // determine size
    rows := Length(v);
    if rows>0 then
        cols := Length(v[0])
    else
        cols := 0;
    if cols=0 then
        rows := 0;
    for i:=0 to rows-1 do
        if Length(v[i])<>cols then
            raise Exception.Create('Non-rectangular matrix passed');
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite matrix - types do not match');
        if (rows<>x.rows) or (cols<>x.cols) then
            raise Exception.Create('Trying to rewrite vector - sizes do not match');
        x.last_action := 2;
    end;
    
    // copy
    ptr:=PNativeInt(x.xptr.ptr);
    for i:=0 to rows-1 do
    begin
        for j:=0 to cols-1 do
            ptr[j]:=v[i,j];
        ptr:=ptr+x.stride;
    end;
end;

//
// conversion from 2D array to x-matrix:
//
// x     x-matrix.
// v     2D array
// mode  one of the modes:
//       * X_CREATE -  x is assumed to be uninitialized
//       * X_SET -     x is assumed to be initialized; old contents is freed
//       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
//                     it is rewritten without reallocation of memory;
//
procedure x_from_array(var x: x_matrix; const v: TCMatrix; mode: Integer);overload;
var
    elemsize: UInt64T;
    dt: Integer;
    rows, cols: NativeInt;
    i, j: NativeInt;
    ptr:  PComplex;
begin
    dt:=DT_COMPLEX;
    elemsize := SizeOf(Complex);
    
    // determine size
    rows := Length(v);
    if rows>0 then
        cols := Length(v[0])
    else
        cols := 0;
    if cols=0 then
        rows := 0;
    for i:=0 to rows-1 do
        if Length(v[i])<>cols then
            raise Exception.Create('Non-rectangular matrix passed');
    
    // allocation
    if mode=X_CREATE then
    begin
        x.datatype := dt;
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 1;
    end;
    if mode=X_SET then
    begin
        if x.owner=OWN_AE then
            x_free(x.xptr.ptr);
        x.cols := cols;
        x.rows := rows;
        x.stride := cols;
        x.owner := OWN_AE;
        x.xptr.ptr := x_malloc(elemsize*x.stride*x.rows);
        x.last_action := 3;
    end;
    if mode=X_REWRITE then
    begin
        if x.datatype<>dt then
            raise Exception.Create('Trying to rewrite matrix - types do not match');
        if (rows<>x.rows) or (cols<>x.cols) then
            raise Exception.Create('Trying to rewrite vector - sizes do not match');
        x.last_action := 2;
    end;
    
    // copy
    ptr:=PComplex(x.xptr.ptr);
    for i:=0 to rows-1 do
    begin
        for j:=0 to cols-1 do
        begin
            ptr[j].x := v[i,j].x;
            ptr[j].y := v[i,j].y;
        end;
        ptr:=ptr+x.stride;
    end;
end;


//
// this function creates array using x-vector as source.
// array is resized to fit exactly to source.
//
// exception is generated if types mismatch.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_vector; var r: TVector);overload;
var
    I, N: NativeInt;
    Ptr: PDouble;
begin
    if x.datatype<>DT_REAL then
        raise Exception.Create('ALGLIB: x_to_array failed - types mismatch');
    SetLength(r, x.cnt);
    N:=X.cnt;
    Ptr:=PDouble(x.xptr.ptr);
    for I:=0 to N-1 do  
    begin
        r[I]:=Ptr^;
        Inc(Ptr);
    end;
end;


//
// this function creates array using x-vector as source.
// array is resized to fit exactly to source.
//
// exception is generated if types mismatch.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_vector; var r: TIVector);overload;
var
    I, N: NativeInt;
    Ptr: PNativeInt;
begin
    if x.datatype<>DT_INT then
        raise Exception.Create('ALGLIB: x_to_array failed - types mismatch');
    SetLength(r, x.cnt);
    N:=X.cnt;
    Ptr:=PNativeInt(x.xptr.ptr);
    for I:=0 to N-1 do
        r[I]:=Ptr[I];
end;


//
// this function creates array using x-vector as source.
// array is resized to fit exactly to source.
//
// exception is generated if types mismatch.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_vector; var r: TBVector);overload;
var
    I, N: NativeInt;
    Ptr: PByte;
begin
    if x.datatype<>DT_BOOL then
        raise Exception.Create('ALGLIB: x_to_array failed - types mismatch');
    SetLength(r, x.cnt);
    N:=X.cnt;
    Ptr:=PByte(x.xptr.ptr);
    for I:=0 to N-1 do  
    begin
        r[I]:=Ptr^<>0;
        Inc(Ptr);
    end;
end;


//
// this function creates array using x-vector as source.
// array is resized to fit exactly to source.
//
// exception is generated if types mismatch.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_vector; var r: TCVector);overload;
var
    I, N: NativeInt;
    Ptr: PComplex;
begin
    if x.datatype<>DT_COMPLEX then
        raise Exception.Create('ALGLIB: x_to_array failed - types mismatch');
    SetLength(r, x.cnt);
    N:=X.cnt;
    Ptr:=PComplex(x.xptr.ptr);
    for I:=0 to N-1 do  
    begin
        r[I].x:=Ptr^.x;
        r[I].y:=Ptr^.y;
        Inc(Ptr);
    end;
end;


//
// this function creates array using x-matrix as source.
// array is resized to fit exactly to source.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_matrix; var v: TMatrix);overload;
var
    i, j: NativeInt;
    rows, cols, stride: NativeInt;
    p: PDouble;
begin
    rows := x.rows;
    cols := x.cols;
    stride := x.stride;
    Assert(x.datatype=DT_REAL, 'ALGLIB: internal error (unexpected x-matrix type)');
    SetLength(v, rows, cols);
    p:=PDouble(x.xptr.ptr);
    for I:=0 to Rows-1 do
    begin
        for J:=0 to Cols-1 do
            V[I,J]:=p[J];
        p:=p+stride;
    end;
end;


//
// this function creates array using x-matrix as source.
// array is resized to fit exactly to source.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_matrix; var v: TIMatrix);overload;
var
    i, j: NativeInt;
    rows, cols, stride: NativeInt;
    p: PNativeInt;
begin
    rows := x.rows;
    cols := x.cols;
    stride := x.stride;
    Assert(x.datatype=DT_INT, 'ALGLIB: internal error (unexpected x-matrix type)');
    SetLength(v, rows, cols);
    p:=PNativeInt(x.xptr.ptr);
    for I:=0 to Rows-1 do
    begin
        for J:=0 to Cols-1 do
            V[I,J]:=p[J];
        p:=p+stride;
    end;
end;


//
// this function creates array using x-matrix as source.
// array is resized to fit exactly to source.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_matrix; var v: TBMatrix);overload;
var
    i, j: NativeInt;
    rows, cols, stride: NativeInt;
    p: PByte;
begin
    rows := x.rows;
    cols := x.cols;
    stride := x.stride;
    Assert(x.datatype=DT_BOOL, 'ALGLIB: internal error (unexpected x-matrix type)');
    SetLength(v, rows, cols);
    p:=PByte(x.xptr.ptr);
    for I:=0 to Rows-1 do
    begin
        for J:=0 to Cols-1 do
            V[I,J]:=Byte2Bool(p[J]);
        p:=p+stride;
    end;
end;


//
// this function creates array using x-matrix as source.
// array is resized to fit exactly to source.
// x-vector is not freed after use.
//
procedure x_to_array(const x: x_matrix; var v: TCMatrix);overload;
var
    i, j: NativeInt;
    rows, cols, stride: NativeInt;
    p: PComplex;
begin
    rows := x.rows;
    cols := x.cols;
    stride := x.stride;
    Assert(x.datatype=DT_COMPLEX, 'ALGLIB: internal error (unexpected x-matrix type)');
    SetLength(v, rows, cols);
    p:=PComplex(x.xptr.ptr);
    for I:=0 to Rows-1 do
    begin
        for J:=0 to Cols-1 do
        begin
            V[I,J].x:=p[J].x;
            V[I,J].y:=p[J].y;
        end;
        p:=p+stride;
    end;
end;


//
// this function copies x-vector to previously allocated array
// which should be large enough to store x-vector.
//
// exception is generated if array is too small or types mismatch.
// x-vector is not freed after use.
//
procedure copy_x_to_1d(const x: x_vector; var r: TVector);overload;
var
    I, N: NativeInt;
    Ptr: PDouble;
begin
    if x.cnt=0 then
        Exit;
    if Length(r)<x.cnt then
        raise Exception.Create('ALGLIB: copy_x_to_1d failed - sizes mismatch');
    if x.datatype<>DT_REAL then
        raise Exception.Create('ALGLIB: copy_x_to_1d failed - types mismatch');
    N:=X.cnt;
    Ptr:=x.xptr.ptr;
    for I:=0 to N-1 do  
    begin
        r[I]:=Ptr^;
        Inc(Ptr);
    end;
end;
    
procedure x_create_empty(var x: x_vector; datatype: Integer);overload;
begin
    x.cnt := 0;
    x.datatype := datatype;
    x.owner := OWN_CALLER;
    x.last_action := ACT_UNCHANGED;
    x.xptr.ptr := nil;
end;
           
procedure x_create_empty(var x: x_matrix; datatype: Integer);overload;
begin
    x.rows := 0;
    x.cols := 0;
    x.stride := 0;
    x.datatype := datatype;
    x.owner := OWN_CALLER;
    x.last_action := ACT_UNCHANGED;
    x.xptr.ptr := nil;
end;

procedure x_clear(var x: x_vector);overload;
begin
    if x.owner=OWN_AE then
        x_free(x.xptr.ptr);
    x.cnt := 0;
    x.xptr.ptr := nil;
end;
    
procedure x_clear(var x: x_matrix);overload;
begin
    if x.owner=OWN_AE then
        x_free(x.xptr.ptr);
    x.rows := 0;
    x.cols := 0;
    x.xptr.ptr := nil;
end;


function StreamReaderAdapter(StreamObj: NativeInt; Cnt: NativeInt; PDst: PAnsiChar):Byte;cdecl;
var
    Stream: TStream;
    C: AnsiChar;
    K: TALGLIBInteger;
begin
    try
        Stream:=TStream(Pointer(StreamObj));
        if Cnt<1 then
            Exit(1);
        while True do
        begin
            if Stream.Read(C,1)<1 then
                Exit(1);
            if (c<>' ') and (c<>Chr(9)) and (c<>Chr(10)) and (c<>Chr(13)) then
                Break;
        end;
        PDst[0]:=C;
        for k:=1 to cnt-1 do
        begin
            if Stream.Read(C,1)<1 then
                Exit(1);
            if (c=' ') or (c=Chr(9)) or (c=Chr(10)) or (c=Chr(13)) then
                Exit(1);
            PDst[k]:=C;
        end;
        PDst[Cnt]:=AnsiChar(0);
        Exit(0);
    except
        Exit(1);
    end;
end;

function StreamWriterAdapter(const PSrc: PAnsiChar; StreamObj: NativeInt):Byte;cdecl;
var
    Stream: TStream;
begin
    try
        Stream:=TStream(Pointer(StreamObj));
        Stream.Write(PSrc^, XStrLen(PSrc));
        Exit(0);
    except
        Exit(1);
    end;
end;


(****************************************************************
checks that matrix is symmetric.
max|A-A^T| is calculated; if it is within 1.0E-14 of max|A|,
matrix is considered symmetric
****************************************************************)
function xissymmetric(const a: TMatrix):Boolean;
var
    I, J, N: TALGLIBInteger;
    err, mx, v1, v2: Double;
begin
    if xrows(a)<>xcols(a) then
        Exit(False);
    n := xrows(a);
    if n=0 then
        Exit(true);
    mx := 0;
    err := 0;
    for i:=0 to N-1 do
    begin
        for j:=i+1 to N-1 do
        begin
            v1 := a[i,j];
            v2 := a[j,i];
            if isinfinite(v1) or  isnan(v1) then
                Exit(false);
            if isinfinite(v2) or  isnan(v2) then
                Exit(false);
            err := Max(err, Abs(v1-v2));
            mx  := Max(mx,  Abs(v1));
            mx  := Max(mx,  Abs(v2));
        end;
        v1 := a[i,i];
        if isinfinite(v1) or  isnan(v1) then
            Exit(false);
        mx := Max(mx, Abs(v1));
    end;
    if mx=0 then
        Exit(true);
    Exit(err/mx<=1.0E-14);
end;


(****************************************************************
checks that matrix is Hermitian.
max|A-A^H| is calculated; if it is within 1.0E-14 of max|A|,
matrix is considered Hermitian
****************************************************************)
function xishermitian(const a: TCMatrix):Boolean;
var
    i, j, n: TALGLIBInteger;
    err, mx: Double;
    v1, v2: Complex;
begin
    if xrows(a)<>xcols(a) then
        Exit(false);
    n := xrows(a);
    if n=0 then
        Exit(true);
    mx := 0;
    err := 0;
    for i:=0 to n-1 do
    begin
        for j:=i+1 to n-1 do
        begin
            v1 := a[i,j];
            v2 := a[j,i];
            if isinfinite(v1.x) or isnan(v1.x) then
                Exit(false);
            if isinfinite(v1.y) or isnan(v1.y) then
                Exit(false);
            if isinfinite(v2.x) or isnan(v2.x) then
                Exit(false);
            if isinfinite(v2.y) or isnan(v2.y) then
                Exit(false);
            err := Max(err, Abs(v1.x-v2.x));
            err := Max(err, Abs(v1.y+v2.y));
            mx  := Max(mx,  C_Abs(v1));
            mx  := Max(mx,  C_Abs(v2));
        end;
        v1 := a[i,i];
        if isinfinite(v1.x) or isnan(v1.x) then
            Exit(false);
        if isinfinite(v1.y) or isnan(v1.y) then
            Exit(false);
        err := Max(err, Abs(v1.y));
        mx  := Max(mx, C_Abs(v1));
    end;
    if mx=0 then
        Exit(true);
    Exit(err/mx<=1.0E-14);
end;


(****************************************************************
Enforces symmetricity by copying upper half of A to the lower one
****************************************************************)
function xforcesymmetric(a: TMatrix):Boolean;
var
    i, j, n: TALGLIBInteger;
begin
    if xrows(a)<>xcols(a) then
        Exit(false);
    n := xrows(a);
    if n=0 then
        Exit(true);
    for i:=0 to n-1 do
        for j:=i+1 to n-1 do
            a[i,j] := a[j,i];
    Exit(true);
end;

(****************************************************************
Forces Hermiticity by copying upper half of A to the lower one
****************************************************************)
function xforcehermitian(a: TCMatrix):Boolean;
var
    i, j, n: TALGLIBInteger;
    v: complex;
begin
    if xrows(a)<>xcols(a) then
        Exit(false);
    n := xrows(a);
    if n=0 then
        Exit(true);
    for i:=0 to n-1 do
        for j:=i+1 to n-1 do
        begin
            v := a[j,i];
            a[i,j].x := v.x;
            a[i,j].y := -v.y;
        end;
    Exit(true);
end;


constructor Tkdtreerequestbuffer.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tkdtreerequestbuffer.Destroy();
begin
    Deallocate();
end;

function Tkdtreerequestbuffer.Clone():Tkdtreerequestbuffer;
begin
    if ptr=nil then
        Result:=Tkdtreerequestbuffer.Create(nil)
    else
        Result:=Tkdtreerequestbuffer.Create(x_obj_copy_kdtreerequestbuffer(ptr));
end;

procedure Tkdtreerequestbuffer.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_kdtreerequestbuffer(ptr);
    ptr:=nil;
end;

constructor Tkdtree.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tkdtree.Destroy();
begin
    Deallocate();
end;

function Tkdtree.Clone():Tkdtree;
begin
    if ptr=nil then
        Result:=Tkdtree.Create(nil)
    else
        Result:=Tkdtree.Create(x_obj_copy_kdtree(ptr));
end;

procedure Tkdtree.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_kdtree(ptr);
    ptr:=nil;
end;

procedure kdtreeserialize(const obj: Tkdtree; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_kdtreeserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreeserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure kdtreeunserialize(const s_in: AnsiString; out obj: Tkdtree);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_kdtreeunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreeunserialize() call');
        end;
        obj:=Tkdtree.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_kdtree(_x);
    end;
end;

procedure kdtreeserialize(const obj: Tkdtree; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_kdtreeserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during kdtreeserialize_stream() call');
    end;
end;

procedure kdtreeunserialize(stream: TStream; out obj: Tkdtree);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_kdtreeunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreeunserialize_stream() call');
        end;
        obj:=Tkdtree.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_kdtree(_x);
    end;
end;


procedure _core_kdtreebuild( xy: TMatrix;  n: TALGLIBInteger;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_n: NativeInt;
    _d_nx: NativeInt;
    _d_ny: NativeInt;
    _d_normtype: NativeInt;
    _d_kdt : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _d_nx := nx;
        _d_ny := ny;
        _d_normtype := normtype;
        _d_kdt := nil;
        kdt := nil;
        _error_code := x_xv2_kdtreebuild(@_s_error_msg, @_d_xy, @_d_n, @_d_nx, @_d_ny, @_d_normtype, @_d_kdt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreebuild call');
        end;
        kdt := Tkdtree.Create(_d_kdt);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_kdt<>nil) and (kdt=nil) then
            x_obj_free_kdtree(_d_kdt); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure kdtreebuild( xy: TMatrix;  n: TALGLIBInteger;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
begin
    _core_kdtreebuild(xy, n, nx, ny, normtype, kdt, _xparams);
end;


procedure kdtreebuild( xy: TMatrix;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xrows(xy);

    _core_kdtreebuild(xy, n, nx, ny, normtype, kdt, _xparams);

end;


procedure _core_kdtreebuildtagged( xy: TMatrix;  tags: TIVector;  n: TALGLIBInteger;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_tags: x_vector;
    _d_n: NativeInt;
    _d_nx: NativeInt;
    _d_ny: NativeInt;
    _d_normtype: NativeInt;
    _d_kdt : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        x_from_array(_d_tags, tags, X_CREATE);
        _d_n := n;
        _d_nx := nx;
        _d_ny := ny;
        _d_normtype := normtype;
        _d_kdt := nil;
        kdt := nil;
        _error_code := x_xv2_kdtreebuildtagged(@_s_error_msg, @_d_xy, @_d_tags, @_d_n, @_d_nx, @_d_ny, @_d_normtype, @_d_kdt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreebuildtagged call');
        end;
        kdt := Tkdtree.Create(_d_kdt);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_tags);
        if (_d_kdt<>nil) and (kdt=nil) then
            x_obj_free_kdtree(_d_kdt); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure kdtreebuildtagged( xy: TMatrix;  tags: TIVector;  n: TALGLIBInteger;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
begin
    _core_kdtreebuildtagged(xy, tags, n, nx, ny, normtype, kdt, _xparams);
end;


procedure kdtreebuildtagged( xy: TMatrix;  tags: TIVector;  nx: TALGLIBInteger;  ny: TALGLIBInteger;  normtype: TALGLIBInteger; out  kdt: Tkdtree; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xrows(xy)<>xlen(tags))) then
    raise Exception.Create('Error while calling kdtreebuildtagged: looks like one of arguments has wrong size');

    n := xrows(xy);

    _core_kdtreebuildtagged(xy, tags, n, nx, ny, normtype, kdt, _xparams);

end;


procedure _core_kdtreecreaterequestbuffer( kdt: Tkdtree; out  buf: Tkdtreerequestbuffer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_buf : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := nil;
        buf := nil;
        _error_code := x_xv2_kdtreecreaterequestbuffer(@_s_error_msg, @_d_kdt, @_d_buf, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreecreaterequestbuffer call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        buf := Tkdtreerequestbuffer.Create(_d_buf);
    finally
        SetXExceptionMask(fpumask);
        if (_d_buf<>nil) and (buf=nil) then
            x_obj_free_kdtreerequestbuffer(_d_buf); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure kdtreecreaterequestbuffer( kdt: Tkdtree; out  buf: Tkdtreerequestbuffer; const _xparams: UInt64 = 0);
begin
    _core_kdtreecreaterequestbuffer(kdt, buf, _xparams);
end;


function _core_kdtreequeryknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_x: x_vector;
    _d_k: NativeInt;
    _d_selfmatch: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_k := k;
        _d_selfmatch := Bool2Byte(selfmatch);
        _error_code := x_xv2_kdtreequeryknn(@_s_error_msg, @_d_result, @_d_kdt, @_d_x, @_d_k, @_d_selfmatch, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryknn call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreequeryknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreequeryknn(kdt, x, k, selfmatch, _xparams);
end;


function kdtreequeryknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreequeryknn(kdt, x, k, selfmatch, _xparams);

end;


function _core_kdtreetsqueryknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_k: NativeInt;
    _d_selfmatch: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_k := k;
        _d_selfmatch := Bool2Byte(selfmatch);
        _error_code := x_xv2_kdtreetsqueryknn(@_s_error_msg, @_d_result, @_d_kdt, @_d_buf, @_d_x, @_d_k, @_d_selfmatch, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryknn call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreetsqueryknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreetsqueryknn(kdt, buf, x, k, selfmatch, _xparams);
end;


function kdtreetsqueryknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreetsqueryknn(kdt, buf, x, k, selfmatch, _xparams);

end;


function _core_kdtreequeryrnn( kdt: Tkdtree;  x: TVector;  r: Double;  selfmatch: Boolean; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_x: x_vector;
    _d_r: Double;
    _d_selfmatch: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_r := r;
        _d_selfmatch := Bool2Byte(selfmatch);
        _error_code := x_xv2_kdtreequeryrnn(@_s_error_msg, @_d_result, @_d_kdt, @_d_x, @_d_r, @_d_selfmatch, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryrnn call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreequeryrnn( kdt: Tkdtree;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreequeryrnn(kdt, x, r, selfmatch, _xparams);
end;


function kdtreequeryrnn( kdt: Tkdtree;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreequeryrnn(kdt, x, r, selfmatch, _xparams);

end;


function _core_kdtreequeryrnnu( kdt: Tkdtree;  x: TVector;  r: Double;  selfmatch: Boolean; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_x: x_vector;
    _d_r: Double;
    _d_selfmatch: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_r := r;
        _d_selfmatch := Bool2Byte(selfmatch);
        _error_code := x_xv2_kdtreequeryrnnu(@_s_error_msg, @_d_result, @_d_kdt, @_d_x, @_d_r, @_d_selfmatch, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryrnnu call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreequeryrnnu( kdt: Tkdtree;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreequeryrnnu(kdt, x, r, selfmatch, _xparams);
end;


function kdtreequeryrnnu( kdt: Tkdtree;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreequeryrnnu(kdt, x, r, selfmatch, _xparams);

end;


function _core_kdtreetsqueryrnn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double;  selfmatch: Boolean; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_r: Double;
    _d_selfmatch: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_r := r;
        _d_selfmatch := Bool2Byte(selfmatch);
        _error_code := x_xv2_kdtreetsqueryrnn(@_s_error_msg, @_d_result, @_d_kdt, @_d_buf, @_d_x, @_d_r, @_d_selfmatch, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryrnn call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreetsqueryrnn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreetsqueryrnn(kdt, buf, x, r, selfmatch, _xparams);
end;


function kdtreetsqueryrnn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreetsqueryrnn(kdt, buf, x, r, selfmatch, _xparams);

end;


function _core_kdtreetsqueryrnnu( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double;  selfmatch: Boolean; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_r: Double;
    _d_selfmatch: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_r := r;
        _d_selfmatch := Bool2Byte(selfmatch);
        _error_code := x_xv2_kdtreetsqueryrnnu(@_s_error_msg, @_d_result, @_d_kdt, @_d_buf, @_d_x, @_d_r, @_d_selfmatch, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryrnnu call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreetsqueryrnnu( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double;  selfmatch: Boolean; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreetsqueryrnnu(kdt, buf, x, r, selfmatch, _xparams);
end;


function kdtreetsqueryrnnu( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  r: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreetsqueryrnnu(kdt, buf, x, r, selfmatch, _xparams);

end;


function _core_kdtreequeryaknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean;  eps: Double; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_x: x_vector;
    _d_k: NativeInt;
    _d_selfmatch: Byte;
    _d_eps: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_k := k;
        _d_selfmatch := Bool2Byte(selfmatch);
        _d_eps := eps;
        _error_code := x_xv2_kdtreequeryaknn(@_s_error_msg, @_d_result, @_d_kdt, @_d_x, @_d_k, @_d_selfmatch, @_d_eps, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryaknn call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreequeryaknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreequeryaknn(kdt, x, k, selfmatch, eps, _xparams);
end;


function kdtreequeryaknn( kdt: Tkdtree;  x: TVector;  k: TALGLIBInteger;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreequeryaknn(kdt, x, k, selfmatch, eps, _xparams);

end;


function _core_kdtreetsqueryaknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean;  eps: Double; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_k: NativeInt;
    _d_selfmatch: Byte;
    _d_eps: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_k := k;
        _d_selfmatch := Bool2Byte(selfmatch);
        _d_eps := eps;
        _error_code := x_xv2_kdtreetsqueryaknn(@_s_error_msg, @_d_result, @_d_kdt, @_d_buf, @_d_x, @_d_k, @_d_selfmatch, @_d_eps, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryaknn call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function kdtreetsqueryaknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  selfmatch: Boolean;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
begin
    Result := _core_kdtreetsqueryaknn(kdt, buf, x, k, selfmatch, eps, _xparams);
end;


function kdtreetsqueryaknn( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  x: TVector;  k: TALGLIBInteger;  eps: Double; const _xparams: UInt64 = 0):TALGLIBInteger;overload;
var
    selfmatch: Boolean;

begin

    selfmatch := True;

    Result := _core_kdtreetsqueryaknn(kdt, buf, x, k, selfmatch, eps, _xparams);

end;


function _core_kdtreequerybox( kdt: Tkdtree;  boxmin: TVector;  boxmax: TVector; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_boxmin: x_vector;
    _d_boxmax: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_boxmin, boxmin, X_CREATE);
        x_from_array(_d_boxmax, boxmax, X_CREATE);
        _error_code := x_xv2_kdtreequerybox(@_s_error_msg, @_d_result, @_d_kdt, @_d_boxmin, @_d_boxmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequerybox call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_boxmin);
        x_clear(_d_boxmax);
    end;
end;


function kdtreequerybox( kdt: Tkdtree;  boxmin: TVector;  boxmax: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_kdtreequerybox(kdt, boxmin, boxmax, _xparams);
end;


function _core_kdtreetsquerybox( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  boxmin: TVector;  boxmax: TVector; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_boxmin: x_vector;
    _d_boxmax: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_boxmin, boxmin, X_CREATE);
        x_from_array(_d_boxmax, boxmax, X_CREATE);
        _error_code := x_xv2_kdtreetsquerybox(@_s_error_msg, @_d_result, @_d_kdt, @_d_buf, @_d_boxmin, @_d_boxmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsquerybox call');
        end;
        result := _d_result;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_boxmin);
        x_clear(_d_boxmax);
    end;
end;


function kdtreetsquerybox( kdt: Tkdtree;  buf: Tkdtreerequestbuffer;  boxmin: TVector;  boxmax: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_kdtreetsquerybox(kdt, buf, boxmin, boxmax, _xparams);
end;


procedure _core_kdtreequeryresultsx( kdt: Tkdtree; var  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_kdtreequeryresultsx(@_s_error_msg, @_d_kdt, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultsx call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure kdtreequeryresultsx( kdt: Tkdtree; var  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultsx(kdt, x, _xparams);
end;


procedure _core_kdtreequeryresultsxy( kdt: Tkdtree; var  xy: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_xy: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _error_code := x_xv2_kdtreequeryresultsxy(@_s_error_msg, @_d_kdt, @_d_xy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultsxy call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_xy, xy);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure kdtreequeryresultsxy( kdt: Tkdtree; var  xy: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultsxy(kdt, xy, _xparams);
end;


procedure _core_kdtreequeryresultstags( kdt: Tkdtree; var  tags: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_tags: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_tags, tags, X_CREATE);
        _error_code := x_xv2_kdtreequeryresultstags(@_s_error_msg, @_d_kdt, @_d_tags, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultstags call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_tags, tags);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_tags);
    end;
end;


procedure kdtreequeryresultstags( kdt: Tkdtree; var  tags: TIVector; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultstags(kdt, tags, _xparams);
end;


procedure _core_kdtreequeryresultsdistances( kdt: Tkdtree; var  r: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_from_array(_d_r, r, X_CREATE);
        _error_code := x_xv2_kdtreequeryresultsdistances(@_s_error_msg, @_d_kdt, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultsdistances call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_r);
    end;
end;


procedure kdtreequeryresultsdistances( kdt: Tkdtree; var  r: TVector; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultsdistances(kdt, r, _xparams);
end;


procedure _core_kdtreetsqueryresultsx( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_kdtreetsqueryresultsx(@_s_error_msg, @_d_kdt, @_d_buf, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryresultsx call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure kdtreetsqueryresultsx( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_kdtreetsqueryresultsx(kdt, buf, x, _xparams);
end;


procedure _core_kdtreetsqueryresultsxy( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  xy: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_xy: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _error_code := x_xv2_kdtreetsqueryresultsxy(@_s_error_msg, @_d_kdt, @_d_buf, @_d_xy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryresultsxy call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_xy, xy);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure kdtreetsqueryresultsxy( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  xy: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_kdtreetsqueryresultsxy(kdt, buf, xy, _xparams);
end;


procedure _core_kdtreetsqueryresultstags( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  tags: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_tags: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_tags, tags, X_CREATE);
        _error_code := x_xv2_kdtreetsqueryresultstags(@_s_error_msg, @_d_kdt, @_d_buf, @_d_tags, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryresultstags call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_tags, tags);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_tags);
    end;
end;


procedure kdtreetsqueryresultstags( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  tags: TIVector; const _xparams: UInt64 = 0);
begin
    _core_kdtreetsqueryresultstags(kdt, buf, tags, _xparams);
end;


procedure _core_kdtreetsqueryresultsdistances( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  r: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_buf : Pointer;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_r, r, X_CREATE);
        _error_code := x_xv2_kdtreetsqueryresultsdistances(@_s_error_msg, @_d_kdt, @_d_buf, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreetsqueryresultsdistances call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_r);
    end;
end;


procedure kdtreetsqueryresultsdistances( kdt: Tkdtree;  buf: Tkdtreerequestbuffer; var  r: TVector; const _xparams: UInt64 = 0);
begin
    _core_kdtreetsqueryresultsdistances(kdt, buf, r, _xparams);
end;


procedure _core_kdtreequeryresultsxi( kdt: Tkdtree; out  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_kdtreequeryresultsxi(@_s_error_msg, @_d_kdt, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultsxi call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure kdtreequeryresultsxi( kdt: Tkdtree; out  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultsxi(kdt, x, _xparams);
end;


procedure _core_kdtreequeryresultsxyi( kdt: Tkdtree; out  xy: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_xy: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_create_empty(_d_xy, DT_REAL);
        xy := nil;
        _error_code := x_xv2_kdtreequeryresultsxyi(@_s_error_msg, @_d_kdt, @_d_xy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultsxyi call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_xy, xy);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure kdtreequeryresultsxyi( kdt: Tkdtree; out  xy: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultsxyi(kdt, xy, _xparams);
end;


procedure _core_kdtreequeryresultstagsi( kdt: Tkdtree; out  tags: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_tags: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_create_empty(_d_tags, DT_INT);
        tags := nil;
        _error_code := x_xv2_kdtreequeryresultstagsi(@_s_error_msg, @_d_kdt, @_d_tags, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultstagsi call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_tags, tags);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_tags);
    end;
end;


procedure kdtreequeryresultstagsi( kdt: Tkdtree; out  tags: TIVector; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultstagsi(kdt, tags, _xparams);
end;


procedure _core_kdtreequeryresultsdistancesi( kdt: Tkdtree; out  r: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_kdt : Pointer;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_kdt := kdt.ptr;
        x_create_empty(_d_r, DT_REAL);
        r := nil;
        _error_code := x_xv2_kdtreequeryresultsdistancesi(@_s_error_msg, @_d_kdt, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kdtreequeryresultsdistancesi call');
        end;
        Assert(kdt.ptr=_d_kdt, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_r);
    end;
end;


procedure kdtreequeryresultsdistancesi( kdt: Tkdtree; out  r: TVector; const _xparams: UInt64 = 0);
begin
    _core_kdtreequeryresultsdistancesi(kdt, r, _xparams);
end;

constructor Thqrndstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Thqrndstate.Destroy();
begin
    Deallocate();
end;

function Thqrndstate.Clone():Thqrndstate;
begin
    if ptr=nil then
        Result:=Thqrndstate.Create(nil)
    else
        Result:=Thqrndstate.Create(x_obj_copy_hqrndstate(ptr));
end;

procedure Thqrndstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_hqrndstate(ptr);
    ptr:=nil;
end;


procedure _core_hqrndrandomize(out  state: Thqrndstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_hqrndrandomize(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrndrandomize call');
        end;
        state := Thqrndstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_hqrndstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure hqrndrandomize(out  state: Thqrndstate; const _xparams: UInt64 = 0);
begin
    _core_hqrndrandomize(state, _xparams);
end;


procedure _core_hqrndseed( s1: TALGLIBInteger;  s2: TALGLIBInteger; out  state: Thqrndstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s1: NativeInt;
    _d_s2: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s1 := s1;
        _d_s2 := s2;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_hqrndseed(@_s_error_msg, @_d_s1, @_d_s2, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrndseed call');
        end;
        state := Thqrndstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_hqrndstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure hqrndseed( s1: TALGLIBInteger;  s2: TALGLIBInteger; out  state: Thqrndstate; const _xparams: UInt64 = 0);
begin
    _core_hqrndseed(s1, s2, state, _xparams);
end;


function _core_hqrnduniformr( state: Thqrndstate; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_hqrnduniformr(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrnduniformr call');
        end;
        result := _d_result;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function hqrnduniformr( state: Thqrndstate; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hqrnduniformr(state, _xparams);
end;


function _core_hqrnduniformi( state: Thqrndstate;  n: TALGLIBInteger; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_state : Pointer;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_n := n;
        _error_code := x_xv2_hqrnduniformi(@_s_error_msg, @_d_result, @_d_state, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrnduniformi call');
        end;
        result := _d_result;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function hqrnduniformi( state: Thqrndstate;  n: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_hqrnduniformi(state, n, _xparams);
end;


function _core_hqrndnormal( state: Thqrndstate; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_hqrndnormal(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrndnormal call');
        end;
        result := _d_result;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function hqrndnormal( state: Thqrndstate; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hqrndnormal(state, _xparams);
end;


procedure _core_hqrndunit2( state: Thqrndstate; out  x: Double; out  y: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: Double;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_hqrndunit2(@_s_error_msg, @_d_state, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrndunit2 call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        y := _d_y;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure hqrndunit2( state: Thqrndstate; out  x: Double; out  y: Double; const _xparams: UInt64 = 0);
begin
    _core_hqrndunit2(state, x, y, _xparams);
end;


procedure _core_hqrndnormal2( state: Thqrndstate; out  x1: Double; out  x2: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x1: Double;
    _d_x2: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_hqrndnormal2(@_s_error_msg, @_d_state, @_d_x1, @_d_x2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrndnormal2 call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x1 := _d_x1;
        x2 := _d_x2;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure hqrndnormal2( state: Thqrndstate; out  x1: Double; out  x2: Double; const _xparams: UInt64 = 0);
begin
    _core_hqrndnormal2(state, x1, x2, _xparams);
end;


function _core_hqrndexponential( state: Thqrndstate;  lambdav: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_state : Pointer;
    _d_lambdav: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_lambdav := lambdav;
        _error_code := x_xv2_hqrndexponential(@_s_error_msg, @_d_result, @_d_state, @_d_lambdav, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrndexponential call');
        end;
        result := _d_result;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function hqrndexponential( state: Thqrndstate;  lambdav: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hqrndexponential(state, lambdav, _xparams);
end;


function _core_hqrnddiscrete( state: Thqrndstate;  x: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_hqrnddiscrete(@_s_error_msg, @_d_result, @_d_state, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrnddiscrete call');
        end;
        result := _d_result;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function hqrnddiscrete( state: Thqrndstate;  x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hqrnddiscrete(state, x, n, _xparams);
end;


function _core_hqrndcontinuous( state: Thqrndstate;  x: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_hqrndcontinuous(@_s_error_msg, @_d_result, @_d_state, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hqrndcontinuous call');
        end;
        result := _d_result;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function hqrndcontinuous( state: Thqrndstate;  x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hqrndcontinuous(state, x, n, _xparams);
end;

function Clone(const Src: Txdebugrecord1):Txdebugrecord1;overload;
begin
    Result.i := src.i;
    Result.c := src.c;
    Result.a := Clone(src.a);
end;

procedure x_xdebugrecord1_init(var x: x_xdebugrecord1);
begin
    x.i.longval := 0;
    x.c.x := 0;
    x.c.y := 0;
    x_create_empty(x.a, DT_REAL);
end;

procedure x_xdebugrecord1_clear(var x: x_xdebugrecord1);
begin
    x_clear(x.a);
end;

procedure x_xdebugrecord1_init_from(var x: x_xdebugrecord1; const v: Txdebugrecord1);
begin
    x.i.longval := v.i;
    x.c.x := v.c.x;
    x.c.y := v.c.y;
    x_from_array(x.a, v.a, X_CREATE);
end;

procedure x_xdebugrecord1_to_record(const x: x_xdebugrecord1; var v: Txdebugrecord1);
begin
    v.i := x.i.val; // long is silently truncated to TALGLIBInteger
    v.c.x := x.c.x;
    v.c.y := x.c.y;
    x_to_array(x.a, v.a);
end;


procedure _core_xdebuginitrecord1(out  rec1: Txdebugrecord1; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_rec1: x_xdebugrecord1;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_xdebugrecord1_init(_d_rec1);
        _error_code := x_xv2_xdebuginitrecord1(@_s_error_msg, @_d_rec1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebuginitrecord1 call');
        end;
        x_xdebugrecord1_to_record(_d_rec1, rec1);
    finally
        SetXExceptionMask(fpumask);
        x_xdebugrecord1_clear(_d_rec1);
    end;
end;


procedure xdebuginitrecord1(out  rec1: Txdebugrecord1; const _xparams: UInt64 = 0);
begin
    _core_xdebuginitrecord1(rec1, _xparams);
end;


function _core_xdebugb1count( a: TBVector; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugb1count(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb1count call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugb1count( a: TBVector; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_xdebugb1count(a, _xparams);
end;


procedure _core_xdebugb1not(var  a: TBVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugb1not(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb1not call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugb1not(var  a: TBVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugb1not(a, _xparams);
end;


procedure _core_xdebugb1appendcopy(var  a: TBVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugb1appendcopy(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb1appendcopy call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugb1appendcopy(var  a: TBVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugb1appendcopy(a, _xparams);
end;


procedure _core_xdebugb1outeven( n: TALGLIBInteger; out  a: TBVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_a, DT_BOOL);
        a := nil;
        _error_code := x_xv2_xdebugb1outeven(@_s_error_msg, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb1outeven call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugb1outeven( n: TALGLIBInteger; out  a: TBVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugb1outeven(n, a, _xparams);
end;


function _core_xdebugi1sum( a: TIVector; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugi1sum(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi1sum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugi1sum( a: TIVector; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_xdebugi1sum(a, _xparams);
end;


procedure _core_xdebugi1neg(var  a: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugi1neg(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi1neg call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugi1neg(var  a: TIVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugi1neg(a, _xparams);
end;


procedure _core_xdebugi1appendcopy(var  a: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugi1appendcopy(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi1appendcopy call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugi1appendcopy(var  a: TIVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugi1appendcopy(a, _xparams);
end;


procedure _core_xdebugi1outeven( n: TALGLIBInteger; out  a: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_a, DT_INT);
        a := nil;
        _error_code := x_xv2_xdebugi1outeven(@_s_error_msg, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi1outeven call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugi1outeven( n: TALGLIBInteger; out  a: TIVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugi1outeven(n, a, _xparams);
end;


function _core_xdebugr1sum( a: TVector; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugr1sum(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr1sum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugr1sum( a: TVector; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_xdebugr1sum(a, _xparams);
end;


procedure _core_xdebugr1neg(var  a: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugr1neg(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr1neg call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugr1neg(var  a: TVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugr1neg(a, _xparams);
end;


procedure _core_xdebugr1appendcopy(var  a: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugr1appendcopy(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr1appendcopy call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugr1appendcopy(var  a: TVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugr1appendcopy(a, _xparams);
end;


procedure _core_xdebugr1outeven( n: TALGLIBInteger; out  a: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_xdebugr1outeven(@_s_error_msg, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr1outeven call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugr1outeven( n: TALGLIBInteger; out  a: TVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugr1outeven(n, a, _xparams);
end;


function _core_xdebugc1sum( a: TCVector; _xparams: UInt64):Complex;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Complex;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugc1sum(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc1sum call');
        end;
        result.x := _d_result.x;
        result.y := _d_result.y;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugc1sum( a: TCVector; const _xparams: UInt64 = 0):Complex;
begin
    Result := _core_xdebugc1sum(a, _xparams);
end;


procedure _core_xdebugc1neg(var  a: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugc1neg(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc1neg call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugc1neg(var  a: TCVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugc1neg(a, _xparams);
end;


procedure _core_xdebugc1appendcopy(var  a: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugc1appendcopy(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc1appendcopy call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugc1appendcopy(var  a: TCVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugc1appendcopy(a, _xparams);
end;


procedure _core_xdebugc1outeven( n: TALGLIBInteger; out  a: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_a, DT_COMPLEX);
        a := nil;
        _error_code := x_xv2_xdebugc1outeven(@_s_error_msg, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc1outeven call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugc1outeven( n: TALGLIBInteger; out  a: TCVector; const _xparams: UInt64 = 0);
begin
    _core_xdebugc1outeven(n, a, _xparams);
end;


function _core_xdebugb2count( a: TBMatrix; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugb2count(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb2count call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugb2count( a: TBMatrix; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_xdebugb2count(a, _xparams);
end;


procedure _core_xdebugb2not(var  a: TBMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugb2not(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb2not call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugb2not(var  a: TBMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugb2not(a, _xparams);
end;


procedure _core_xdebugb2transpose(var  a: TBMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugb2transpose(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb2transpose call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugb2transpose(var  a: TBMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugb2transpose(a, _xparams);
end;


procedure _core_xdebugb2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TBMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_a, DT_BOOL);
        a := nil;
        _error_code := x_xv2_xdebugb2outsin(@_s_error_msg, @_d_m, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugb2outsin call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugb2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TBMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugb2outsin(m, n, a, _xparams);
end;


function _core_xdebugi2sum( a: TIMatrix; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugi2sum(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi2sum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugi2sum( a: TIMatrix; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_xdebugi2sum(a, _xparams);
end;


procedure _core_xdebugi2neg(var  a: TIMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugi2neg(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi2neg call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugi2neg(var  a: TIMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugi2neg(a, _xparams);
end;


procedure _core_xdebugi2transpose(var  a: TIMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugi2transpose(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi2transpose call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugi2transpose(var  a: TIMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugi2transpose(a, _xparams);
end;


procedure _core_xdebugi2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TIMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_a, DT_INT);
        a := nil;
        _error_code := x_xv2_xdebugi2outsin(@_s_error_msg, @_d_m, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugi2outsin call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugi2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TIMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugi2outsin(m, n, a, _xparams);
end;


function _core_xdebugr2sum( a: TMatrix; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugr2sum(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr2sum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugr2sum( a: TMatrix; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_xdebugr2sum(a, _xparams);
end;


procedure _core_xdebugr2neg(var  a: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugr2neg(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr2neg call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugr2neg(var  a: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugr2neg(a, _xparams);
end;


procedure _core_xdebugr2transpose(var  a: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugr2transpose(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr2transpose call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugr2transpose(var  a: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugr2transpose(a, _xparams);
end;


procedure _core_xdebugr2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_xdebugr2outsin(@_s_error_msg, @_d_m, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugr2outsin call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugr2outsin( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugr2outsin(m, n, a, _xparams);
end;


function _core_xdebugc2sum( a: TCMatrix; _xparams: UInt64):Complex;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Complex;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugc2sum(@_s_error_msg, @_d_result, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc2sum call');
        end;
        result.x := _d_result.x;
        result.y := _d_result.y;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function xdebugc2sum( a: TCMatrix; const _xparams: UInt64 = 0):Complex;
begin
    Result := _core_xdebugc2sum(a, _xparams);
end;


procedure _core_xdebugc2neg(var  a: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugc2neg(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc2neg call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugc2neg(var  a: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugc2neg(a, _xparams);
end;


procedure _core_xdebugc2transpose(var  a: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _error_code := x_xv2_xdebugc2transpose(@_s_error_msg, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc2transpose call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugc2transpose(var  a: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugc2transpose(a, _xparams);
end;


procedure _core_xdebugc2outsincos( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_a, DT_COMPLEX);
        a := nil;
        _error_code := x_xv2_xdebugc2outsincos(@_s_error_msg, @_d_m, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugc2outsincos call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure xdebugc2outsincos( m: TALGLIBInteger;  n: TALGLIBInteger; out  a: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_xdebugc2outsincos(m, n, a, _xparams);
end;


function _core_xdebugmaskedbiasedproductsum( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  b: TMatrix;  c: TBMatrix; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_b: x_matrix;
    _d_c: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_b, b, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _error_code := x_xv2_xdebugmaskedbiasedproductsum(@_s_error_msg, @_d_result, @_d_m, @_d_n, @_d_a, @_d_b, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during xdebugmaskedbiasedproductsum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_c);
    end;
end;


function xdebugmaskedbiasedproductsum( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  b: TMatrix;  c: TBMatrix; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_xdebugmaskedbiasedproductsum(m, n, a, b, c, _xparams);
end;

constructor Todesolverstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Todesolverstate.Destroy();
begin
    Deallocate();
end;

function Todesolverstate.Clone():Todesolverstate;
begin
    if ptr=nil then
        Result:=Todesolverstate.Create(nil)
    else
        Result:=Todesolverstate.Create(x_obj_copy_odesolverstate(ptr));
end;

procedure Todesolverstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_odesolverstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Todesolverreport):Todesolverreport;overload;
begin
    Result.nfev := src.nfev;
    Result.terminationtype := src.terminationtype;
end;

procedure x_odesolverreport_init(var x: x_odesolverreport);
begin
    x.nfev.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_odesolverreport_clear(var x: x_odesolverreport);
begin
end;

procedure x_odesolverreport_init_from(var x: x_odesolverreport; const v: Todesolverreport);
begin
    x.nfev.longval := v.nfev;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_odesolverreport_to_record(const x: x_odesolverreport; var v: Todesolverreport);
begin
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_odesolverrkck( y: TVector;  n: TALGLIBInteger;  x: TVector;  m: TALGLIBInteger;  eps: Double;  h: Double; out  state: Todesolverstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_m: NativeInt;
    _d_eps: Double;
    _d_h: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_m := m;
        _d_eps := eps;
        _d_h := h;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_odesolverrkck(@_s_error_msg, @_d_y, @_d_n, @_d_x, @_d_m, @_d_eps, @_d_h, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during odesolverrkck call');
        end;
        state := Todesolverstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_odesolverstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure odesolverrkck( y: TVector;  n: TALGLIBInteger;  x: TVector;  m: TALGLIBInteger;  eps: Double;  h: Double; out  state: Todesolverstate; const _xparams: UInt64 = 0);overload;
begin
    _core_odesolverrkck(y, n, x, m, eps, h, state, _xparams);
end;


procedure odesolverrkck( y: TVector;  x: TVector;  eps: Double;  h: Double; out  state: Todesolverstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;

begin

    n := xlen(y);
    m := xlen(x);

    _core_odesolverrkck(y, n, x, m, eps, h, state, _xparams);

end;


function _core_odesolveriteration( state: Todesolverstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_odesolveriteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during odesolveriteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function odesolveriteration( state: Todesolverstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_odesolveriteration(state, _xparams);
end;

procedure odesolversolve(state: Todesolverstate; diff: Tndimensional_ode_rp; obj: Pointer; _xparams: UInt64 = 0);
var
    _s_error_msg: PAnsiChar;
    _error_code:Int32T;
    _b_result:  Byte;
    _state:     Pointer;
    _xc_x:      Double;
    _xc_y:      x_vector;
    _xc_dy:     x_vector;
    _xc_needdy: Byte;
    _pas_y:     TVector;
    _pas_dy:    TVector;
begin
    _s_error_msg:=nil;
    _state:=state.ptr;
    _pas_y:=nil;
    _pas_dy:=nil;

    //
    // Check correctness of delegates
    //
    if @diff=nil then
        raise Exception.Create('ALGLIB: error in odesolversolve() (diff is nil)');

    //
    // Attach x-structures to internal arrays allocated by solver
    //
    x_create_empty(_xc_y,  DT_REAL);
    x_create_empty(_xc_dy, DT_REAL);
    x_odesolverstate_get_y(_state,  @_xc_y);
    x_odesolverstate_get_dy(_state, @_xc_dy);
    SetLength(_pas_y, _xc_y.cnt);
    SetLength(_pas_dy, _xc_dy.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_odesolveriteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during odesolveriteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;

        //
        // Reverse communication interface:
        // * fetch flags
        // * make delegate calls
        //
        x_odesolverstate_get_needdy(_state, @_xc_needdy);
        if _xc_needdy<>0 then
        begin
            x_odesolverstate_get_x(_state, @_xc_x);
            x_to_array(_xc_y, _pas_y);
            diff(_pas_y, _xc_x, _pas_dy, obj);
            x_from_array(_xc_dy, _pas_dy, X_REWRITE);
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in odesolversolve (some derivatives were not provided?)');
    end;
end;


procedure _core_odesolverresults( state: Todesolverstate; out  m: TALGLIBInteger; out  xtbl: TVector; out  ytbl: TMatrix; out  rep: Todesolverreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_m: NativeInt;
    _d_xtbl: x_vector;
    _d_ytbl: x_matrix;
    _d_rep: x_odesolverreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_xtbl, DT_REAL);
        xtbl := nil;
        x_create_empty(_d_ytbl, DT_REAL);
        ytbl := nil;
        x_odesolverreport_init(_d_rep);
        _error_code := x_xv2_odesolverresults(@_s_error_msg, @_d_state, @_d_m, @_d_xtbl, @_d_ytbl, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during odesolverresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        m := _d_m;
        x_to_array(_d_xtbl, xtbl);
        x_to_array(_d_ytbl, ytbl);
        x_odesolverreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xtbl);
        x_clear(_d_ytbl);
        x_odesolverreport_clear(_d_rep);
    end;
end;


procedure odesolverresults( state: Todesolverstate; out  m: TALGLIBInteger; out  xtbl: TVector; out  ytbl: TMatrix; out  rep: Todesolverreport; const _xparams: UInt64 = 0);
begin
    _core_odesolverresults(state, m, xtbl, ytbl, rep, _xparams);
end;

constructor Tsparsematrix.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tsparsematrix.Destroy();
begin
    Deallocate();
end;

function Tsparsematrix.Clone():Tsparsematrix;
begin
    if ptr=nil then
        Result:=Tsparsematrix.Create(nil)
    else
        Result:=Tsparsematrix.Create(x_obj_copy_sparsematrix(ptr));
end;

procedure Tsparsematrix.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_sparsematrix(ptr);
    ptr:=nil;
end;

constructor Tsparsebuffers.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tsparsebuffers.Destroy();
begin
    Deallocate();
end;

function Tsparsebuffers.Clone():Tsparsebuffers;
begin
    if ptr=nil then
        Result:=Tsparsebuffers.Create(nil)
    else
        Result:=Tsparsebuffers.Create(x_obj_copy_sparsebuffers(ptr));
end;

procedure Tsparsebuffers.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_sparsebuffers(ptr);
    ptr:=nil;
end;


procedure _core_sparsecreate( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger; out  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_k := k;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_sparsecreate(@_s_error_msg, @_d_m, @_d_n, @_d_k, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreate call');
        end;
        s := Tsparsematrix.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecreate( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger; out  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
begin
    _core_sparsecreate(m, n, k, s, _xparams);
end;


procedure sparsecreate( m: TALGLIBInteger;  n: TALGLIBInteger; out  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin

    k := 0;

    _core_sparsecreate(m, n, k, s, _xparams);

end;


procedure _core_sparsecreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_k := k;
        _d_s := s.ptr;
        _error_code := x_xv2_sparsecreatebuf(@_s_error_msg, @_d_m, @_d_n, @_d_k, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreatebuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
begin
    _core_sparsecreatebuf(m, n, k, s, _xparams);
end;


procedure sparsecreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  s: Tsparsematrix; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin

    k := 0;

    _core_sparsecreatebuf(m, n, k, s, _xparams);

end;


procedure _core_sparsecreatecrs( m: TALGLIBInteger;  n: TALGLIBInteger;  ner: TIVector; out  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_ner: x_vector;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_ner, ner, X_CREATE);
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_sparsecreatecrs(@_s_error_msg, @_d_m, @_d_n, @_d_ner, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreatecrs call');
        end;
        s := Tsparsematrix.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_ner);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecreatecrs( m: TALGLIBInteger;  n: TALGLIBInteger;  ner: TIVector; out  s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecreatecrs(m, n, ner, s, _xparams);
end;


procedure _core_sparsecreatecrsbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  ner: TIVector;  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_ner: x_vector;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_ner, ner, X_CREATE);
        _d_s := s.ptr;
        _error_code := x_xv2_sparsecreatecrsbuf(@_s_error_msg, @_d_m, @_d_n, @_d_ner, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreatecrsbuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_ner);
    end;
end;


procedure sparsecreatecrsbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  ner: TIVector;  s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecreatecrsbuf(m, n, ner, s, _xparams);
end;


procedure _core_sparsecreatesks( m: TALGLIBInteger;  n: TALGLIBInteger;  d: TIVector;  u: TIVector; out  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_d: x_vector;
    _d_u: x_vector;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_d, d, X_CREATE);
        x_from_array(_d_u, u, X_CREATE);
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_sparsecreatesks(@_s_error_msg, @_d_m, @_d_n, @_d_d, @_d_u, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreatesks call');
        end;
        s := Tsparsematrix.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
        x_clear(_d_u);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecreatesks( m: TALGLIBInteger;  n: TALGLIBInteger;  d: TIVector;  u: TIVector; out  s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecreatesks(m, n, d, u, s, _xparams);
end;


procedure _core_sparsecreatesksbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  d: TIVector;  u: TIVector;  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_d: x_vector;
    _d_u: x_vector;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_d, d, X_CREATE);
        x_from_array(_d_u, u, X_CREATE);
        _d_s := s.ptr;
        _error_code := x_xv2_sparsecreatesksbuf(@_s_error_msg, @_d_m, @_d_n, @_d_d, @_d_u, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreatesksbuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
        x_clear(_d_u);
    end;
end;


procedure sparsecreatesksbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  d: TIVector;  u: TIVector;  s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecreatesksbuf(m, n, d, u, s, _xparams);
end;


procedure _core_sparsecreatesksband( m: TALGLIBInteger;  n: TALGLIBInteger;  bw: TALGLIBInteger; out  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_bw: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_bw := bw;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_sparsecreatesksband(@_s_error_msg, @_d_m, @_d_n, @_d_bw, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreatesksband call');
        end;
        s := Tsparsematrix.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecreatesksband( m: TALGLIBInteger;  n: TALGLIBInteger;  bw: TALGLIBInteger; out  s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecreatesksband(m, n, bw, s, _xparams);
end;


procedure _core_sparsecreatesksbandbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  bw: TALGLIBInteger;  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_bw: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_bw := bw;
        _d_s := s.ptr;
        _error_code := x_xv2_sparsecreatesksbandbuf(@_s_error_msg, @_d_m, @_d_n, @_d_bw, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecreatesksbandbuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecreatesksbandbuf( m: TALGLIBInteger;  n: TALGLIBInteger;  bw: TALGLIBInteger;  s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecreatesksbandbuf(m, n, bw, s, _xparams);
end;


procedure _core_sparsecopy( s0: Tsparsematrix; out  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := nil;
        s1 := nil;
        _error_code := x_xv2_sparsecopy(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopy call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        s1 := Tsparsematrix.Create(_d_s1);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s1<>nil) and (s1=nil) then
            x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecopy( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopy(s0, s1, _xparams);
end;


procedure _core_sparsecopybuf( s0: Tsparsematrix;  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := s1.ptr;
        _error_code := x_xv2_sparsecopybuf(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopybuf call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(s1.ptr=_d_s1, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecopybuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopybuf(s0, s1, _xparams);
end;


procedure _core_sparseswap( s0: Tsparsematrix;  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := s1.ptr;
        _error_code := x_xv2_sparseswap(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseswap call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(s1.ptr=_d_s1, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseswap( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparseswap(s0, s1, _xparams);
end;


procedure _core_sparseadd( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_j: NativeInt;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        _d_j := j;
        _d_v := v;
        _error_code := x_xv2_sparseadd(@_s_error_msg, @_d_s, @_d_i, @_d_j, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseadd call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseadd( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; const _xparams: UInt64 = 0);
begin
    _core_sparseadd(s, i, j, v, _xparams);
end;


procedure _core_sparseset( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_j: NativeInt;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        _d_j := j;
        _d_v := v;
        _error_code := x_xv2_sparseset(@_s_error_msg, @_d_s, @_d_i, @_d_j, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseset call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseset( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; const _xparams: UInt64 = 0);
begin
    _core_sparseset(s, i, j, v, _xparams);
end;


function _core_sparseget( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_j: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        _d_j := j;
        _error_code := x_xv2_sparseget(@_s_error_msg, @_d_result, @_d_s, @_d_i, @_d_j, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseget call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparseget( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_sparseget(s, i, j, _xparams);
end;


function _core_sparsegetdiagonal( s: Tsparsematrix;  i: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_i: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        _error_code := x_xv2_sparsegetdiagonal(@_s_error_msg, @_d_result, @_d_s, @_d_i, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetdiagonal call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparsegetdiagonal( s: Tsparsematrix;  i: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_sparsegetdiagonal(s, i, _xparams);
end;


procedure _core_sparsemv( s: Tsparsematrix;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_sparsemv(@_s_error_msg, @_d_s, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsemv call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure sparsemv( s: Tsparsematrix;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsemv(s, x, y, _xparams);
end;


procedure _core_sparsemtv( s: Tsparsematrix;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_sparsemtv(@_s_error_msg, @_d_s, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsemtv call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure sparsemtv( s: Tsparsematrix;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsemtv(s, x, y, _xparams);
end;


procedure _core_sparsegemv( s: Tsparsematrix;  alpha: Double;  ops: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_alpha: Double;
    _d_ops: NativeInt;
    _d_x: x_vector;
    _d_ix: NativeInt;
    _d_beta: Double;
    _d_y: x_vector;
    _d_iy: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_alpha := alpha;
        _d_ops := ops;
        x_from_array(_d_x, x, X_CREATE);
        _d_ix := ix;
        _d_beta := beta;
        x_from_array(_d_y, y, X_CREATE);
        _d_iy := iy;
        _error_code := x_xv2_sparsegemv(@_s_error_msg, @_d_s, @_d_alpha, @_d_ops, @_d_x, @_d_ix, @_d_beta, @_d_y, @_d_iy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegemv call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure sparsegemv( s: Tsparsematrix;  alpha: Double;  ops: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_sparsegemv(s, alpha, ops, x, ix, beta, y, iy, _xparams);
end;


procedure _core_sparsemv2( s: Tsparsematrix;  x: TVector; var  y0: TVector; var  y1: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_y0: x_vector;
    _d_y1: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y0, y0, X_CREATE);
        x_from_array(_d_y1, y1, X_CREATE);
        _error_code := x_xv2_sparsemv2(@_s_error_msg, @_d_s, @_d_x, @_d_y0, @_d_y1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsemv2 call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y0, y0);
        x_to_array(_d_y1, y1);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y0);
        x_clear(_d_y1);
    end;
end;


procedure sparsemv2( s: Tsparsematrix;  x: TVector; var  y0: TVector; var  y1: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsemv2(s, x, y0, y1, _xparams);
end;


procedure _core_sparsesmv( s: Tsparsematrix;  isupper: Boolean;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_isupper: Byte;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_sparsesmv(@_s_error_msg, @_d_s, @_d_isupper, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsesmv call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure sparsesmv( s: Tsparsematrix;  isupper: Boolean;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsesmv(s, isupper, x, y, _xparams);
end;


function _core_sparsevsmv( s: Tsparsematrix;  isupper: Boolean;  x: TVector; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_isupper: Byte;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_sparsevsmv(@_s_error_msg, @_d_result, @_d_s, @_d_isupper, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsevsmv call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function sparsevsmv( s: Tsparsematrix;  isupper: Boolean;  x: TVector; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_sparsevsmv(s, isupper, x, _xparams);
end;


procedure _core_sparsemm( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_a: x_matrix;
    _d_k: NativeInt;
    _d_b: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_k := k;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_sparsemm(@_s_error_msg, @_d_s, @_d_a, @_d_k, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsemm call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure sparsemm( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_sparsemm(s, a, k, b, _xparams);
end;


procedure _core_sparsemtm( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_a: x_matrix;
    _d_k: NativeInt;
    _d_b: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_k := k;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_sparsemtm(@_s_error_msg, @_d_s, @_d_a, @_d_k, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsemtm call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure sparsemtm( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_sparsemtm(s, a, k, b, _xparams);
end;


procedure _core_sparsemm2( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b0: TMatrix; var  b1: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_a: x_matrix;
    _d_k: NativeInt;
    _d_b0: x_matrix;
    _d_b1: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_k := k;
        x_from_array(_d_b0, b0, X_CREATE);
        x_from_array(_d_b1, b1, X_CREATE);
        _error_code := x_xv2_sparsemm2(@_s_error_msg, @_d_s, @_d_a, @_d_k, @_d_b0, @_d_b1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsemm2 call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_b0, b0);
        x_to_array(_d_b1, b1);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b0);
        x_clear(_d_b1);
    end;
end;


procedure sparsemm2( s: Tsparsematrix;  a: TMatrix;  k: TALGLIBInteger; var  b0: TMatrix; var  b1: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_sparsemm2(s, a, k, b0, b1, _xparams);
end;


procedure _core_sparsesmm( s: Tsparsematrix;  isupper: Boolean;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_isupper: Byte;
    _d_a: x_matrix;
    _d_k: NativeInt;
    _d_b: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_a, a, X_CREATE);
        _d_k := k;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_sparsesmm(@_s_error_msg, @_d_s, @_d_isupper, @_d_a, @_d_k, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsesmm call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure sparsesmm( s: Tsparsematrix;  isupper: Boolean;  a: TMatrix;  k: TALGLIBInteger; var  b: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_sparsesmm(s, isupper, a, k, b, _xparams);
end;


procedure _core_sparsetrmv( s: Tsparsematrix;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_optype: NativeInt;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _d_optype := optype;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_sparsetrmv(@_s_error_msg, @_d_s, @_d_isupper, @_d_isunit, @_d_optype, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsetrmv call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure sparsetrmv( s: Tsparsematrix;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsetrmv(s, isupper, isunit, optype, x, y, _xparams);
end;


procedure _core_sparsetrsv( s: Tsparsematrix;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_optype: NativeInt;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _d_optype := optype;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_sparsetrsv(@_s_error_msg, @_d_s, @_d_isupper, @_d_isunit, @_d_optype, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsetrsv call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure sparsetrsv( s: Tsparsematrix;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsetrsv(s, isupper, isunit, optype, x, _xparams);
end;


procedure _core_sparseresizematrix( s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparseresizematrix(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseresizematrix call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseresizematrix( s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparseresizematrix(s, _xparams);
end;


function _core_sparseenumerate( s: Tsparsematrix; var  t0: TALGLIBInteger; var  t1: TALGLIBInteger; out  i: TALGLIBInteger; out  j: TALGLIBInteger; out  v: Double; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_s : Pointer;
    _d_t0: NativeInt;
    _d_t1: NativeInt;
    _d_i: NativeInt;
    _d_j: NativeInt;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_t0 := t0;
        _d_t1 := t1;
        _error_code := x_xv2_sparseenumerate(@_s_error_msg, @_d_result, @_d_s, @_d_t0, @_d_t1, @_d_i, @_d_j, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseenumerate call');
        end;
        result := Byte2Bool(_d_result);
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        t0 := _d_t0;
        t1 := _d_t1;
        i := _d_i;
        j := _d_j;
        v := _d_v;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparseenumerate( s: Tsparsematrix; var  t0: TALGLIBInteger; var  t1: TALGLIBInteger; out  i: TALGLIBInteger; out  j: TALGLIBInteger; out  v: Double; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_sparseenumerate(s, t0, t1, i, j, v, _xparams);
end;


function _core_sparserewriteexisting( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_j: NativeInt;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        _d_j := j;
        _d_v := v;
        _error_code := x_xv2_sparserewriteexisting(@_s_error_msg, @_d_result, @_d_s, @_d_i, @_d_j, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparserewriteexisting call');
        end;
        result := Byte2Bool(_d_result);
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparserewriteexisting( s: Tsparsematrix;  i: TALGLIBInteger;  j: TALGLIBInteger;  v: Double; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_sparserewriteexisting(s, i, j, v, _xparams);
end;


procedure _core_sparsegetrow( s: Tsparsematrix;  i: TALGLIBInteger; var  irow: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_irow: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        x_from_array(_d_irow, irow, X_CREATE);
        _error_code := x_xv2_sparsegetrow(@_s_error_msg, @_d_s, @_d_i, @_d_irow, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetrow call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_irow, irow);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_irow);
    end;
end;


procedure sparsegetrow( s: Tsparsematrix;  i: TALGLIBInteger; var  irow: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsegetrow(s, i, irow, _xparams);
end;


procedure _core_sparsegetcompressedrow( s: Tsparsematrix;  i: TALGLIBInteger; var  colidx: TIVector; var  vals: TVector; out  nzcnt: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_colidx: x_vector;
    _d_vals: x_vector;
    _d_nzcnt: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        x_from_array(_d_colidx, colidx, X_CREATE);
        x_from_array(_d_vals, vals, X_CREATE);
        _error_code := x_xv2_sparsegetcompressedrow(@_s_error_msg, @_d_s, @_d_i, @_d_colidx, @_d_vals, @_d_nzcnt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetcompressedrow call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_colidx, colidx);
        x_to_array(_d_vals, vals);
        nzcnt := _d_nzcnt;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_colidx);
        x_clear(_d_vals);
    end;
end;


procedure sparsegetcompressedrow( s: Tsparsematrix;  i: TALGLIBInteger; var  colidx: TIVector; var  vals: TVector; out  nzcnt: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_sparsegetcompressedrow(s, i, colidx, vals, nzcnt, _xparams);
end;


procedure _core_sparsetransposesks( s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparsetransposesks(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsetransposesks call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsetransposesks( s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsetransposesks(s, _xparams);
end;


procedure _core_sparsetransposecrs( s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparsetransposecrs(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsetransposecrs call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsetransposecrs( s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsetransposecrs(s, _xparams);
end;


procedure _core_sparsecopytransposecrs( s0: Tsparsematrix; out  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := nil;
        s1 := nil;
        _error_code := x_xv2_sparsecopytransposecrs(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytransposecrs call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        s1 := Tsparsematrix.Create(_d_s1);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s1<>nil) and (s1=nil) then
            x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecopytransposecrs( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytransposecrs(s0, s1, _xparams);
end;


procedure _core_sparsecopytransposecrsbuf( s0: Tsparsematrix;  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := s1.ptr;
        _error_code := x_xv2_sparsecopytransposecrsbuf(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytransposecrsbuf call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(s1.ptr=_d_s1, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecopytransposecrsbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytransposecrsbuf(s0, s1, _xparams);
end;


procedure _core_sparseconvertto( s0: Tsparsematrix;  fmt: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_fmt: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_fmt := fmt;
        _error_code := x_xv2_sparseconvertto(@_s_error_msg, @_d_s0, @_d_fmt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseconvertto call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseconvertto( s0: Tsparsematrix;  fmt: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_sparseconvertto(s0, fmt, _xparams);
end;


procedure _core_sparsecopytobuf( s0: Tsparsematrix;  fmt: TALGLIBInteger;  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_fmt: NativeInt;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_fmt := fmt;
        _d_s1 := s1.ptr;
        _error_code := x_xv2_sparsecopytobuf(@_s_error_msg, @_d_s0, @_d_fmt, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytobuf call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(s1.ptr=_d_s1, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecopytobuf( s0: Tsparsematrix;  fmt: TALGLIBInteger;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytobuf(s0, fmt, s1, _xparams);
end;


procedure _core_sparseconverttohash( s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparseconverttohash(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseconverttohash call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseconverttohash( s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparseconverttohash(s, _xparams);
end;


procedure _core_sparsecopytohash( s0: Tsparsematrix; out  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := nil;
        s1 := nil;
        _error_code := x_xv2_sparsecopytohash(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytohash call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        s1 := Tsparsematrix.Create(_d_s1);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s1<>nil) and (s1=nil) then
            x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecopytohash( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytohash(s0, s1, _xparams);
end;


procedure _core_sparsecopytohashbuf( s0: Tsparsematrix;  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := s1.ptr;
        _error_code := x_xv2_sparsecopytohashbuf(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytohashbuf call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(s1.ptr=_d_s1, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecopytohashbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytohashbuf(s0, s1, _xparams);
end;


procedure _core_sparseconverttocrs( s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparseconverttocrs(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseconverttocrs call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseconverttocrs( s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparseconverttocrs(s, _xparams);
end;


procedure _core_sparsecopytocrs( s0: Tsparsematrix; out  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := nil;
        s1 := nil;
        _error_code := x_xv2_sparsecopytocrs(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytocrs call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        s1 := Tsparsematrix.Create(_d_s1);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s1<>nil) and (s1=nil) then
            x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecopytocrs( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytocrs(s0, s1, _xparams);
end;


procedure _core_sparsecopytocrsbuf( s0: Tsparsematrix;  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := s1.ptr;
        _error_code := x_xv2_sparsecopytocrsbuf(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytocrsbuf call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(s1.ptr=_d_s1, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecopytocrsbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytocrsbuf(s0, s1, _xparams);
end;


procedure _core_sparseconverttosks( s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparseconverttosks(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseconverttosks call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparseconverttosks( s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparseconverttosks(s, _xparams);
end;


procedure _core_sparsecopytosks( s0: Tsparsematrix; out  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := nil;
        s1 := nil;
        _error_code := x_xv2_sparsecopytosks(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytosks call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        s1 := Tsparsematrix.Create(_d_s1);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s1<>nil) and (s1=nil) then
            x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsecopytosks( s0: Tsparsematrix; out  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytosks(s0, s1, _xparams);
end;


procedure _core_sparsecopytosksbuf( s0: Tsparsematrix;  s1: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s0 : Pointer;
    _d_s1 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s0 := s0.ptr;
        _d_s1 := s1.ptr;
        _error_code := x_xv2_sparsecopytosksbuf(@_s_error_msg, @_d_s0, @_d_s1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecopytosksbuf call');
        end;
        Assert(s0.ptr=_d_s0, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(s1.ptr=_d_s1, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sparsecopytosksbuf( s0: Tsparsematrix;  s1: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsecopytosksbuf(s0, s1, _xparams);
end;


function _core_sparsegetmatrixtype( s: Tsparsematrix; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparsegetmatrixtype(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetmatrixtype call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparsegetmatrixtype( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_sparsegetmatrixtype(s, _xparams);
end;


function _core_sparseishash( s: Tsparsematrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparseishash(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseishash call');
        end;
        result := Byte2Bool(_d_result);
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparseishash( s: Tsparsematrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_sparseishash(s, _xparams);
end;


function _core_sparseiscrs( s: Tsparsematrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparseiscrs(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseiscrs call');
        end;
        result := Byte2Bool(_d_result);
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparseiscrs( s: Tsparsematrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_sparseiscrs(s, _xparams);
end;


function _core_sparseissks( s: Tsparsematrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparseissks(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparseissks call');
        end;
        result := Byte2Bool(_d_result);
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparseissks( s: Tsparsematrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_sparseissks(s, _xparams);
end;


procedure _core_sparsefree(out  s: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_sparsefree(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsefree call');
        end;
        s := Tsparsematrix.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure sparsefree(out  s: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_sparsefree(s, _xparams);
end;


function _core_sparsegetnrows( s: Tsparsematrix; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparsegetnrows(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetnrows call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparsegetnrows( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_sparsegetnrows(s, _xparams);
end;


function _core_sparsegetncols( s: Tsparsematrix; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparsegetncols(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetncols call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparsegetncols( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_sparsegetncols(s, _xparams);
end;


function _core_sparsegetuppercount( s: Tsparsematrix; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparsegetuppercount(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetuppercount call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparsegetuppercount( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_sparsegetuppercount(s, _xparams);
end;


function _core_sparsegetlowercount( s: Tsparsematrix; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_sparsegetlowercount(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsegetlowercount call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparsegetlowercount( s: Tsparsematrix; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_sparsegetlowercount(s, _xparams);
end;


procedure _core_cmatrixtranspose( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_b: x_matrix;
    _d_ib: NativeInt;
    _d_jb: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _d_jb := jb;
        _error_code := x_xv2_cmatrixtranspose(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_b, @_d_ib, @_d_jb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixtranspose call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure cmatrixtranspose( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixtranspose(m, n, a, ia, ja, b, ib, jb, _xparams);
end;


procedure _core_rmatrixtranspose( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_b: x_matrix;
    _d_ib: NativeInt;
    _d_jb: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _d_jb := jb;
        _error_code := x_xv2_rmatrixtranspose(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_b, @_d_ib, @_d_jb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixtranspose call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure rmatrixtranspose( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixtranspose(m, n, a, ia, ja, b, ib, jb, _xparams);
end;


procedure _core_rmatrixenforcesymmetricity(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_rmatrixenforcesymmetricity(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixenforcesymmetricity call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure rmatrixenforcesymmetricity(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
begin
    _core_rmatrixenforcesymmetricity(a, n, isupper, _xparams);
end;


procedure _core_cmatrixcopy( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_b: x_matrix;
    _d_ib: NativeInt;
    _d_jb: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _d_jb := jb;
        _error_code := x_xv2_cmatrixcopy(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_b, @_d_ib, @_d_jb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixcopy call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure cmatrixcopy( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixcopy(m, n, a, ia, ja, b, ib, jb, _xparams);
end;


procedure _core_rvectorcopy( n: TALGLIBInteger;  a: TVector;  ia: TALGLIBInteger; var  b: TVector;  ib: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_vector;
    _d_ia: NativeInt;
    _d_b: x_vector;
    _d_ib: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _error_code := x_xv2_rvectorcopy(@_s_error_msg, @_d_n, @_d_a, @_d_ia, @_d_b, @_d_ib, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rvectorcopy call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure rvectorcopy( n: TALGLIBInteger;  a: TVector;  ia: TALGLIBInteger; var  b: TVector;  ib: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rvectorcopy(n, a, ia, b, ib, _xparams);
end;


procedure _core_rmatrixcopy( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_b: x_matrix;
    _d_ib: NativeInt;
    _d_jb: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _d_jb := jb;
        _error_code := x_xv2_rmatrixcopy(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_b, @_d_ib, @_d_jb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixcopy call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure rmatrixcopy( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixcopy(m, n, a, ia, ja, b, ib, jb, _xparams);
end;


procedure _core_rmatrixgencopy( m: TALGLIBInteger;  n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  beta: Double; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_alpha: Double;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_beta: Double;
    _d_b: x_matrix;
    _d_ib: NativeInt;
    _d_jb: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_alpha := alpha;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_beta := beta;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _d_jb := jb;
        _error_code := x_xv2_rmatrixgencopy(@_s_error_msg, @_d_m, @_d_n, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_beta, @_d_b, @_d_ib, @_d_jb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixgencopy call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure rmatrixgencopy( m: TALGLIBInteger;  n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  beta: Double; var  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixgencopy(m, n, alpha, a, ia, ja, beta, b, ib, jb, _xparams);
end;


procedure _core_rmatrixger( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  alpha: Double;  u: TVector;  iu: TALGLIBInteger;  v: TVector;  iv: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_alpha: Double;
    _d_u: x_vector;
    _d_iu: NativeInt;
    _d_v: x_vector;
    _d_iv: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_alpha := alpha;
        x_from_array(_d_u, u, X_CREATE);
        _d_iu := iu;
        x_from_array(_d_v, v, X_CREATE);
        _d_iv := iv;
        _error_code := x_xv2_rmatrixger(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_alpha, @_d_u, @_d_iu, @_d_v, @_d_iv, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixger call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_u);
        x_clear(_d_v);
    end;
end;


procedure rmatrixger( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  alpha: Double;  u: TVector;  iu: TALGLIBInteger;  v: TVector;  iv: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixger(m, n, a, ia, ja, alpha, u, iu, v, iv, _xparams);
end;


procedure _core_cmatrixrank1( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  u: TCVector;  iu: TALGLIBInteger; var  v: TCVector;  iv: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_u: x_vector;
    _d_iu: NativeInt;
    _d_v: x_vector;
    _d_iv: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        x_from_array(_d_u, u, X_CREATE);
        _d_iu := iu;
        x_from_array(_d_v, v, X_CREATE);
        _d_iv := iv;
        _error_code := x_xv2_cmatrixrank1(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_u, @_d_iu, @_d_v, @_d_iv, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrank1 call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_u, u);
        x_to_array(_d_v, v);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_u);
        x_clear(_d_v);
    end;
end;


procedure cmatrixrank1( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  u: TCVector;  iu: TALGLIBInteger; var  v: TCVector;  iv: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixrank1(m, n, a, ia, ja, u, iu, v, iv, _xparams);
end;


procedure _core_rmatrixrank1( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  u: TVector;  iu: TALGLIBInteger; var  v: TVector;  iv: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_u: x_vector;
    _d_iu: NativeInt;
    _d_v: x_vector;
    _d_iv: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        x_from_array(_d_u, u, X_CREATE);
        _d_iu := iu;
        x_from_array(_d_v, v, X_CREATE);
        _d_iv := iv;
        _error_code := x_xv2_rmatrixrank1(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_u, @_d_iu, @_d_v, @_d_iv, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrank1 call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_u, u);
        x_to_array(_d_v, v);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_u);
        x_clear(_d_v);
    end;
end;


procedure rmatrixrank1( m: TALGLIBInteger;  n: TALGLIBInteger; var  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger; var  u: TVector;  iu: TALGLIBInteger; var  v: TVector;  iv: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixrank1(m, n, a, ia, ja, u, iu, v, iv, _xparams);
end;


procedure _core_rmatrixgemv( m: TALGLIBInteger;  n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_alpha: Double;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_opa: NativeInt;
    _d_x: x_vector;
    _d_ix: NativeInt;
    _d_beta: Double;
    _d_y: x_vector;
    _d_iy: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_alpha := alpha;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_opa := opa;
        x_from_array(_d_x, x, X_CREATE);
        _d_ix := ix;
        _d_beta := beta;
        x_from_array(_d_y, y, X_CREATE);
        _d_iy := iy;
        _error_code := x_xv2_rmatrixgemv(@_s_error_msg, @_d_m, @_d_n, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_opa, @_d_x, @_d_ix, @_d_beta, @_d_y, @_d_iy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixgemv call');
        end;
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure rmatrixgemv( m: TALGLIBInteger;  n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixgemv(m, n, alpha, a, ia, ja, opa, x, ix, beta, y, iy, _xparams);
end;


procedure _core_cmatrixmv( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TCVector;  ix: TALGLIBInteger; var  y: TCVector;  iy: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_opa: NativeInt;
    _d_x: x_vector;
    _d_ix: NativeInt;
    _d_y: x_vector;
    _d_iy: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_opa := opa;
        x_from_array(_d_x, x, X_CREATE);
        _d_ix := ix;
        x_from_array(_d_y, y, X_CREATE);
        _d_iy := iy;
        _error_code := x_xv2_cmatrixmv(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_opa, @_d_x, @_d_ix, @_d_y, @_d_iy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixmv call');
        end;
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure cmatrixmv( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TCVector;  ix: TALGLIBInteger; var  y: TCVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixmv(m, n, a, ia, ja, opa, x, ix, y, iy, _xparams);
end;


procedure _core_rmatrixmv( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger; var  y: TVector;  iy: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_opa: NativeInt;
    _d_x: x_vector;
    _d_ix: NativeInt;
    _d_y: x_vector;
    _d_iy: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_opa := opa;
        x_from_array(_d_x, x, X_CREATE);
        _d_ix := ix;
        x_from_array(_d_y, y, X_CREATE);
        _d_iy := iy;
        _error_code := x_xv2_rmatrixmv(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_opa, @_d_x, @_d_ix, @_d_y, @_d_iy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixmv call');
        end;
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure rmatrixmv( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  opa: TALGLIBInteger;  x: TVector;  ix: TALGLIBInteger; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixmv(m, n, a, ia, ja, opa, x, ix, y, iy, _xparams);
end;


procedure _core_rmatrixsymv( n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_alpha: Double;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_isupper: Byte;
    _d_x: x_vector;
    _d_ix: NativeInt;
    _d_beta: Double;
    _d_y: x_vector;
    _d_iy: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_alpha := alpha;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_x, x, X_CREATE);
        _d_ix := ix;
        _d_beta := beta;
        x_from_array(_d_y, y, X_CREATE);
        _d_iy := iy;
        _error_code := x_xv2_rmatrixsymv(@_s_error_msg, @_d_n, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_isupper, @_d_x, @_d_ix, @_d_beta, @_d_y, @_d_iy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsymv call');
        end;
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure rmatrixsymv( n: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  x: TVector;  ix: TALGLIBInteger;  beta: Double; var  y: TVector;  iy: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixsymv(n, alpha, a, ia, ja, isupper, x, ix, beta, y, iy, _xparams);
end;


function _core_rmatrixsyvmv( n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  x: TVector;  ix: TALGLIBInteger; var  tmp: TVector; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_isupper: Byte;
    _d_x: x_vector;
    _d_ix: NativeInt;
    _d_tmp: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_x, x, X_CREATE);
        _d_ix := ix;
        x_from_array(_d_tmp, tmp, X_CREATE);
        _error_code := x_xv2_rmatrixsyvmv(@_s_error_msg, @_d_result, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_isupper, @_d_x, @_d_ix, @_d_tmp, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsyvmv call');
        end;
        result := _d_result;
        x_to_array(_d_tmp, tmp);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
        x_clear(_d_tmp);
    end;
end;


function rmatrixsyvmv( n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  x: TVector;  ix: TALGLIBInteger; var  tmp: TVector; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rmatrixsyvmv(n, a, ia, ja, isupper, x, ix, tmp, _xparams);
end;


procedure _core_rmatrixtrsv( n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector;  ix: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_optype: NativeInt;
    _d_x: x_vector;
    _d_ix: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _d_optype := optype;
        x_from_array(_d_x, x, X_CREATE);
        _d_ix := ix;
        _error_code := x_xv2_rmatrixtrsv(@_s_error_msg, @_d_n, @_d_a, @_d_ia, @_d_ja, @_d_isupper, @_d_isunit, @_d_optype, @_d_x, @_d_ix, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixtrsv call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
    end;
end;


procedure rmatrixtrsv( n: TALGLIBInteger;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TVector;  ix: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixtrsv(n, a, ia, ja, isupper, isunit, optype, x, ix, _xparams);
end;


procedure _core_cmatrixrighttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TCMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_i1: NativeInt;
    _d_j1: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_optype: NativeInt;
    _d_x: x_matrix;
    _d_i2: NativeInt;
    _d_j2: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_i1 := i1;
        _d_j1 := j1;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _d_optype := optype;
        x_from_array(_d_x, x, X_CREATE);
        _d_i2 := i2;
        _d_j2 := j2;
        _error_code := x_xv2_cmatrixrighttrsm(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_i1, @_d_j1, @_d_isupper, @_d_isunit, @_d_optype, @_d_x, @_d_i2, @_d_j2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrighttrsm call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
    end;
end;


procedure cmatrixrighttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TCMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2, _xparams);
end;


procedure _core_cmatrixlefttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TCMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_i1: NativeInt;
    _d_j1: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_optype: NativeInt;
    _d_x: x_matrix;
    _d_i2: NativeInt;
    _d_j2: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_i1 := i1;
        _d_j1 := j1;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _d_optype := optype;
        x_from_array(_d_x, x, X_CREATE);
        _d_i2 := i2;
        _d_j2 := j2;
        _error_code := x_xv2_cmatrixlefttrsm(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_i1, @_d_j1, @_d_isupper, @_d_isunit, @_d_optype, @_d_x, @_d_i2, @_d_j2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlefttrsm call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
    end;
end;


procedure cmatrixlefttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TCMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TCMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2, _xparams);
end;


procedure _core_rmatrixrighttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_i1: NativeInt;
    _d_j1: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_optype: NativeInt;
    _d_x: x_matrix;
    _d_i2: NativeInt;
    _d_j2: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_i1 := i1;
        _d_j1 := j1;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _d_optype := optype;
        x_from_array(_d_x, x, X_CREATE);
        _d_i2 := i2;
        _d_j2 := j2;
        _error_code := x_xv2_rmatrixrighttrsm(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_i1, @_d_j1, @_d_isupper, @_d_isunit, @_d_optype, @_d_x, @_d_i2, @_d_j2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrighttrsm call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
    end;
end;


procedure rmatrixrighttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2, _xparams);
end;


procedure _core_rmatrixlefttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_a: x_matrix;
    _d_i1: NativeInt;
    _d_j1: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_optype: NativeInt;
    _d_x: x_matrix;
    _d_i2: NativeInt;
    _d_j2: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        x_from_array(_d_a, a, X_CREATE);
        _d_i1 := i1;
        _d_j1 := j1;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _d_optype := optype;
        x_from_array(_d_x, x, X_CREATE);
        _d_i2 := i2;
        _d_j2 := j2;
        _error_code := x_xv2_rmatrixlefttrsm(@_s_error_msg, @_d_m, @_d_n, @_d_a, @_d_i1, @_d_j1, @_d_isupper, @_d_isunit, @_d_optype, @_d_x, @_d_i2, @_d_j2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlefttrsm call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
    end;
end;


procedure rmatrixlefttrsm( m: TALGLIBInteger;  n: TALGLIBInteger;  a: TMatrix;  i1: TALGLIBInteger;  j1: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean;  optype: TALGLIBInteger; var  x: TMatrix;  i2: TALGLIBInteger;  j2: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2, _xparams);
end;


procedure _core_cmatrixherk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_alpha: Double;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_optypea: NativeInt;
    _d_beta: Double;
    _d_c: x_matrix;
    _d_ic: NativeInt;
    _d_jc: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_k := k;
        _d_alpha := alpha;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_optypea := optypea;
        _d_beta := beta;
        x_from_array(_d_c, c, X_CREATE);
        _d_ic := ic;
        _d_jc := jc;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_cmatrixherk(@_s_error_msg, @_d_n, @_d_k, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_optypea, @_d_beta, @_d_c, @_d_ic, @_d_jc, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixherk call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_c);
    end;
end;


procedure cmatrixherk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
begin
    _core_cmatrixherk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper, _xparams);
end;


procedure _core_rmatrixsyrk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_alpha: Double;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_optypea: NativeInt;
    _d_beta: Double;
    _d_c: x_matrix;
    _d_ic: NativeInt;
    _d_jc: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_k := k;
        _d_alpha := alpha;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_optypea := optypea;
        _d_beta := beta;
        x_from_array(_d_c, c, X_CREATE);
        _d_ic := ic;
        _d_jc := jc;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_rmatrixsyrk(@_s_error_msg, @_d_n, @_d_k, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_optypea, @_d_beta, @_d_c, @_d_ic, @_d_jc, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsyrk call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_c);
    end;
end;


procedure rmatrixsyrk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
begin
    _core_rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper, _xparams);
end;


procedure _core_cmatrixgemm( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Complex;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger;  optypeb: TALGLIBInteger;  beta: Complex; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_alpha: Complex;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_optypea: NativeInt;
    _d_b: x_matrix;
    _d_ib: NativeInt;
    _d_jb: NativeInt;
    _d_optypeb: NativeInt;
    _d_beta: Complex;
    _d_c: x_matrix;
    _d_ic: NativeInt;
    _d_jc: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_k := k;
        _d_alpha.x := alpha.x;
        _d_alpha.y := alpha.y;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_optypea := optypea;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _d_jb := jb;
        _d_optypeb := optypeb;
        _d_beta.x := beta.x;
        _d_beta.y := beta.y;
        x_from_array(_d_c, c, X_CREATE);
        _d_ic := ic;
        _d_jc := jc;
        _error_code := x_xv2_cmatrixgemm(@_s_error_msg, @_d_m, @_d_n, @_d_k, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_optypea, @_d_b, @_d_ib, @_d_jb, @_d_optypeb, @_d_beta, @_d_c, @_d_ic, @_d_jc, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixgemm call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_c);
    end;
end;


procedure cmatrixgemm( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Complex;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  b: TCMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger;  optypeb: TALGLIBInteger;  beta: Complex; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc, _xparams);
end;


procedure _core_rmatrixgemm( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger;  optypeb: TALGLIBInteger;  beta: Double; var  c: TMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_alpha: Double;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_optypea: NativeInt;
    _d_b: x_matrix;
    _d_ib: NativeInt;
    _d_jb: NativeInt;
    _d_optypeb: NativeInt;
    _d_beta: Double;
    _d_c: x_matrix;
    _d_ic: NativeInt;
    _d_jc: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_k := k;
        _d_alpha := alpha;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_optypea := optypea;
        x_from_array(_d_b, b, X_CREATE);
        _d_ib := ib;
        _d_jb := jb;
        _d_optypeb := optypeb;
        _d_beta := beta;
        x_from_array(_d_c, c, X_CREATE);
        _d_ic := ic;
        _d_jc := jc;
        _error_code := x_xv2_rmatrixgemm(@_s_error_msg, @_d_m, @_d_n, @_d_k, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_optypea, @_d_b, @_d_ib, @_d_jb, @_d_optypeb, @_d_beta, @_d_c, @_d_ic, @_d_jc, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixgemm call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_c);
    end;
end;


procedure rmatrixgemm( m: TALGLIBInteger;  n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  b: TMatrix;  ib: TALGLIBInteger;  jb: TALGLIBInteger;  optypeb: TALGLIBInteger;  beta: Double; var  c: TMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc, _xparams);
end;


procedure _core_cmatrixsyrk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_alpha: Double;
    _d_a: x_matrix;
    _d_ia: NativeInt;
    _d_ja: NativeInt;
    _d_optypea: NativeInt;
    _d_beta: Double;
    _d_c: x_matrix;
    _d_ic: NativeInt;
    _d_jc: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_k := k;
        _d_alpha := alpha;
        x_from_array(_d_a, a, X_CREATE);
        _d_ia := ia;
        _d_ja := ja;
        _d_optypea := optypea;
        _d_beta := beta;
        x_from_array(_d_c, c, X_CREATE);
        _d_ic := ic;
        _d_jc := jc;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_cmatrixsyrk(@_s_error_msg, @_d_n, @_d_k, @_d_alpha, @_d_a, @_d_ia, @_d_ja, @_d_optypea, @_d_beta, @_d_c, @_d_ic, @_d_jc, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixsyrk call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_c);
    end;
end;


procedure cmatrixsyrk( n: TALGLIBInteger;  k: TALGLIBInteger;  alpha: Double;  a: TCMatrix;  ia: TALGLIBInteger;  ja: TALGLIBInteger;  optypea: TALGLIBInteger;  beta: Double; var  c: TCMatrix;  ic: TALGLIBInteger;  jc: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);
begin
    _core_cmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper, _xparams);
end;


procedure _core_rmatrixrndorthogonal( n: TALGLIBInteger; out  a: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_rmatrixrndorthogonal(@_s_error_msg, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrndorthogonal call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure rmatrixrndorthogonal( n: TALGLIBInteger; out  a: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixrndorthogonal(n, a, _xparams);
end;


procedure _core_rmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: Double;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_c := c;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_rmatrixrndcond(@_s_error_msg, @_d_n, @_d_c, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrndcond call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure rmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixrndcond(n, c, a, _xparams);
end;


procedure _core_cmatrixrndorthogonal( n: TALGLIBInteger; out  a: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_a, DT_COMPLEX);
        a := nil;
        _error_code := x_xv2_cmatrixrndorthogonal(@_s_error_msg, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrndorthogonal call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure cmatrixrndorthogonal( n: TALGLIBInteger; out  a: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixrndorthogonal(n, a, _xparams);
end;


procedure _core_cmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: Double;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_c := c;
        x_create_empty(_d_a, DT_COMPLEX);
        a := nil;
        _error_code := x_xv2_cmatrixrndcond(@_s_error_msg, @_d_n, @_d_c, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrndcond call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure cmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixrndcond(n, c, a, _xparams);
end;


procedure _core_smatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: Double;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_c := c;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_smatrixrndcond(@_s_error_msg, @_d_n, @_d_c, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixrndcond call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure smatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_smatrixrndcond(n, c, a, _xparams);
end;


procedure _core_spdmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: Double;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_c := c;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_spdmatrixrndcond(@_s_error_msg, @_d_n, @_d_c, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixrndcond call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure spdmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixrndcond(n, c, a, _xparams);
end;


procedure _core_hmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: Double;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_c := c;
        x_create_empty(_d_a, DT_COMPLEX);
        a := nil;
        _error_code := x_xv2_hmatrixrndcond(@_s_error_msg, @_d_n, @_d_c, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hmatrixrndcond call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure hmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_hmatrixrndcond(n, c, a, _xparams);
end;


procedure _core_hpdmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: Double;
    _d_a: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_c := c;
        x_create_empty(_d_a, DT_COMPLEX);
        a := nil;
        _error_code := x_xv2_hpdmatrixrndcond(@_s_error_msg, @_d_n, @_d_c, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixrndcond call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure hpdmatrixrndcond( n: TALGLIBInteger;  c: Double; out  a: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixrndcond(n, c, a, _xparams);
end;


procedure _core_rmatrixrndorthogonalfromtheright(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        _error_code := x_xv2_rmatrixrndorthogonalfromtheright(@_s_error_msg, @_d_a, @_d_m, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrndorthogonalfromtheright call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure rmatrixrndorthogonalfromtheright(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixrndorthogonalfromtheright(a, m, n, _xparams);
end;


procedure _core_rmatrixrndorthogonalfromtheleft(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        _error_code := x_xv2_rmatrixrndorthogonalfromtheleft(@_s_error_msg, @_d_a, @_d_m, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrndorthogonalfromtheleft call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure rmatrixrndorthogonalfromtheleft(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixrndorthogonalfromtheleft(a, m, n, _xparams);
end;


procedure _core_cmatrixrndorthogonalfromtheright(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        _error_code := x_xv2_cmatrixrndorthogonalfromtheright(@_s_error_msg, @_d_a, @_d_m, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrndorthogonalfromtheright call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure cmatrixrndorthogonalfromtheright(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixrndorthogonalfromtheright(a, m, n, _xparams);
end;


procedure _core_cmatrixrndorthogonalfromtheleft(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        _error_code := x_xv2_cmatrixrndorthogonalfromtheleft(@_s_error_msg, @_d_a, @_d_m, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrndorthogonalfromtheleft call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure cmatrixrndorthogonalfromtheleft(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixrndorthogonalfromtheleft(a, m, n, _xparams);
end;


procedure _core_smatrixrndmultiply(var  a: TMatrix;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_smatrixrndmultiply(@_s_error_msg, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixrndmultiply call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure smatrixrndmultiply(var  a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_smatrixrndmultiply(a, n, _xparams);
end;


procedure _core_hmatrixrndmultiply(var  a: TCMatrix;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_hmatrixrndmultiply(@_s_error_msg, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hmatrixrndmultiply call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure hmatrixrndmultiply(var  a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_hmatrixrndmultiply(a, n, _xparams);
end;


procedure _core_rmatrixlu(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  pivots: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_pivots: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_pivots, DT_INT);
        pivots := nil;
        _error_code := x_xv2_rmatrixlu(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_pivots, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlu call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_pivots, pivots);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_pivots);
    end;
end;


procedure rmatrixlu(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  pivots: TIVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlu(a, m, n, pivots, _xparams);
end;


procedure _core_cmatrixlu(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  pivots: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_pivots: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_pivots, DT_INT);
        pivots := nil;
        _error_code := x_xv2_cmatrixlu(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_pivots, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlu call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_pivots, pivots);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_pivots);
    end;
end;


procedure cmatrixlu(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  pivots: TIVector; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlu(a, m, n, pivots, _xparams);
end;


function _core_hpdmatrixcholesky(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_hpdmatrixcholesky(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixcholesky call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function hpdmatrixcholesky(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_hpdmatrixcholesky(a, n, isupper, _xparams);
end;


function _core_spdmatrixcholesky(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_spdmatrixcholesky(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholesky call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function spdmatrixcholesky(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_spdmatrixcholesky(a, n, isupper, _xparams);
end;


procedure _core_spdmatrixcholeskyupdateadd1(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  u: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_u: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_u, u, X_CREATE);
        _error_code := x_xv2_spdmatrixcholeskyupdateadd1(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_u, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskyupdateadd1 call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_u);
    end;
end;


procedure spdmatrixcholeskyupdateadd1(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  u: TVector; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskyupdateadd1(a, n, isupper, u, _xparams);
end;


procedure _core_spdmatrixcholeskyupdatefix(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  fix: TBVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_fix: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_fix, fix, X_CREATE);
        _error_code := x_xv2_spdmatrixcholeskyupdatefix(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_fix, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskyupdatefix call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_fix);
    end;
end;


procedure spdmatrixcholeskyupdatefix(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  fix: TBVector; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskyupdatefix(a, n, isupper, fix, _xparams);
end;


procedure _core_spdmatrixcholeskyupdateadd1buf(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  u: TVector; var  bufr: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_u: x_vector;
    _d_bufr: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_u, u, X_CREATE);
        x_from_array(_d_bufr, bufr, X_CREATE);
        _error_code := x_xv2_spdmatrixcholeskyupdateadd1buf(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_u, @_d_bufr, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskyupdateadd1buf call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_bufr, bufr);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_u);
        x_clear(_d_bufr);
    end;
end;


procedure spdmatrixcholeskyupdateadd1buf(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  u: TVector; var  bufr: TVector; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskyupdateadd1buf(a, n, isupper, u, bufr, _xparams);
end;


procedure _core_spdmatrixcholeskyupdatefixbuf(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  fix: TBVector; var  bufr: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_fix: x_vector;
    _d_bufr: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_fix, fix, X_CREATE);
        x_from_array(_d_bufr, bufr, X_CREATE);
        _error_code := x_xv2_spdmatrixcholeskyupdatefixbuf(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_fix, @_d_bufr, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskyupdatefixbuf call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_bufr, bufr);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_fix);
        x_clear(_d_bufr);
    end;
end;


procedure spdmatrixcholeskyupdatefixbuf(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  fix: TBVector; var  bufr: TVector; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskyupdatefixbuf(a, n, isupper, fix, bufr, _xparams);
end;


function _core_sparselu( a: Tsparsematrix;  pivottype: TALGLIBInteger; out  p: TIVector; out  q: TIVector; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a : Pointer;
    _d_pivottype: NativeInt;
    _d_p: x_vector;
    _d_q: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a.ptr;
        _d_pivottype := pivottype;
        x_create_empty(_d_p, DT_INT);
        p := nil;
        x_create_empty(_d_q, DT_INT);
        q := nil;
        _error_code := x_xv2_sparselu(@_s_error_msg, @_d_result, @_d_a, @_d_pivottype, @_d_p, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparselu call');
        end;
        result := Byte2Bool(_d_result);
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_p, p);
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_p);
        x_clear(_d_q);
    end;
end;


function sparselu( a: Tsparsematrix;  pivottype: TALGLIBInteger; out  p: TIVector; out  q: TIVector; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_sparselu(a, pivottype, p, q, _xparams);
end;


function _core_sparsecholeskyskyline( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a : Pointer;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a.ptr;
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_sparsecholeskyskyline(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecholeskyskyline call');
        end;
        result := Byte2Bool(_d_result);
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function sparsecholeskyskyline( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_sparsecholeskyskyline(a, n, isupper, _xparams);
end;


function _core_rmatrixrcond1( a: TMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_rmatrixrcond1(@_s_error_msg, @_d_result, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrcond1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function rmatrixrcond1( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rmatrixrcond1(a, n, _xparams);
end;


function _core_rmatrixrcondinf( a: TMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_rmatrixrcondinf(@_s_error_msg, @_d_result, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixrcondinf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function rmatrixrcondinf( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rmatrixrcondinf(a, n, _xparams);
end;


function _core_spdmatrixrcond( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_spdmatrixrcond(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixrcond call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function spdmatrixrcond( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spdmatrixrcond(a, n, isupper, _xparams);
end;


function _core_rmatrixtrrcond1( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _error_code := x_xv2_rmatrixtrrcond1(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, @_d_isunit, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixtrrcond1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function rmatrixtrrcond1( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rmatrixtrrcond1(a, n, isupper, isunit, _xparams);
end;


function _core_rmatrixtrrcondinf( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _error_code := x_xv2_rmatrixtrrcondinf(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, @_d_isunit, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixtrrcondinf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function rmatrixtrrcondinf( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rmatrixtrrcondinf(a, n, isupper, isunit, _xparams);
end;


function _core_hpdmatrixrcond( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_hpdmatrixrcond(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixrcond call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function hpdmatrixrcond( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hpdmatrixrcond(a, n, isupper, _xparams);
end;


function _core_cmatrixrcond1( a: TCMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_cmatrixrcond1(@_s_error_msg, @_d_result, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrcond1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function cmatrixrcond1( a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_cmatrixrcond1(a, n, _xparams);
end;


function _core_cmatrixrcondinf( a: TCMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_cmatrixrcondinf(@_s_error_msg, @_d_result, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixrcondinf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function cmatrixrcondinf( a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_cmatrixrcondinf(a, n, _xparams);
end;


function _core_rmatrixlurcond1( lua: TMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lua: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_rmatrixlurcond1(@_s_error_msg, @_d_result, @_d_lua, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlurcond1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
    end;
end;


function rmatrixlurcond1( lua: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rmatrixlurcond1(lua, n, _xparams);
end;


function _core_rmatrixlurcondinf( lua: TMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lua: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_rmatrixlurcondinf(@_s_error_msg, @_d_result, @_d_lua, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlurcondinf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
    end;
end;


function rmatrixlurcondinf( lua: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rmatrixlurcondinf(lua, n, _xparams);
end;


function _core_spdmatrixcholeskyrcond( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_spdmatrixcholeskyrcond(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskyrcond call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function spdmatrixcholeskyrcond( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spdmatrixcholeskyrcond(a, n, isupper, _xparams);
end;


function _core_hpdmatrixcholeskyrcond( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_hpdmatrixcholeskyrcond(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixcholeskyrcond call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function hpdmatrixcholeskyrcond( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hpdmatrixcholeskyrcond(a, n, isupper, _xparams);
end;


function _core_cmatrixlurcond1( lua: TCMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lua: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_cmatrixlurcond1(@_s_error_msg, @_d_result, @_d_lua, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlurcond1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
    end;
end;


function cmatrixlurcond1( lua: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_cmatrixlurcond1(lua, n, _xparams);
end;


function _core_cmatrixlurcondinf( lua: TCMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lua: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_cmatrixlurcondinf(@_s_error_msg, @_d_result, @_d_lua, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlurcondinf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
    end;
end;


function cmatrixlurcondinf( lua: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_cmatrixlurcondinf(lua, n, _xparams);
end;


function _core_cmatrixtrrcond1( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _error_code := x_xv2_cmatrixtrrcond1(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, @_d_isunit, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixtrrcond1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function cmatrixtrrcond1( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_cmatrixtrrcond1(a, n, isupper, isunit, _xparams);
end;


function _core_cmatrixtrrcondinf( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        _error_code := x_xv2_cmatrixtrrcondinf(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, @_d_isunit, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixtrrcondinf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function cmatrixtrrcondinf( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_cmatrixtrrcondinf(a, n, isupper, isunit, _xparams);
end;

function Clone(const Src: Tmatinvreport):Tmatinvreport;overload;
begin
    Result.r1 := src.r1;
    Result.rinf := src.rinf;
end;

procedure x_matinvreport_init(var x: x_matinvreport);
begin
    x.r1 := 0;
    x.rinf := 0;
end;

procedure x_matinvreport_clear(var x: x_matinvreport);
begin
end;

procedure x_matinvreport_init_from(var x: x_matinvreport; const v: Tmatinvreport);
begin
    x.r1 := v.r1;
    x.rinf := v.rinf;
end;

procedure x_matinvreport_to_record(const x: x_matinvreport; var v: Tmatinvreport);
begin
    v.r1 := x.r1;
    v.rinf := x.rinf;
end;


procedure _core_rmatrixluinverse(var  a: TMatrix;  pivots: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_pivots: x_vector;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_pivots, pivots, X_CREATE);
        _d_n := n;
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_rmatrixluinverse(@_s_error_msg, @_d_a, @_d_pivots, @_d_n, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixluinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_pivots);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure rmatrixluinverse(var  a: TMatrix;  pivots: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_rmatrixluinverse(a, pivots, n, info, rep, _xparams);
end;


procedure rmatrixluinverse(var  a: TMatrix;  pivots: TIVector; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xcols(a)<>xrows(a))) or ((xcols(a)<>xlen(pivots))) then
    raise Exception.Create('Error while calling rmatrixluinverse: looks like one of arguments has wrong size');

    n := xcols(a);

    _core_rmatrixluinverse(a, pivots, n, info, rep, _xparams);

end;


procedure _core_rmatrixinverse(var  a: TMatrix;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_rmatrixinverse(@_s_error_msg, @_d_a, @_d_n, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure rmatrixinverse(var  a: TMatrix;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_rmatrixinverse(a, n, info, rep, _xparams);
end;


procedure rmatrixinverse(var  a: TMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling rmatrixinverse: looks like one of arguments has wrong size');

    n := xcols(a);

    _core_rmatrixinverse(a, n, info, rep, _xparams);

end;


procedure _core_cmatrixluinverse(var  a: TCMatrix;  pivots: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_pivots: x_vector;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_pivots, pivots, X_CREATE);
        _d_n := n;
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_cmatrixluinverse(@_s_error_msg, @_d_a, @_d_pivots, @_d_n, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixluinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_pivots);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure cmatrixluinverse(var  a: TCMatrix;  pivots: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_cmatrixluinverse(a, pivots, n, info, rep, _xparams);
end;


procedure cmatrixluinverse(var  a: TCMatrix;  pivots: TIVector; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xcols(a)<>xrows(a))) or ((xcols(a)<>xlen(pivots))) then
    raise Exception.Create('Error while calling cmatrixluinverse: looks like one of arguments has wrong size');

    n := xcols(a);

    _core_cmatrixluinverse(a, pivots, n, info, rep, _xparams);

end;


procedure _core_cmatrixinverse(var  a: TCMatrix;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_cmatrixinverse(@_s_error_msg, @_d_a, @_d_n, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure cmatrixinverse(var  a: TCMatrix;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_cmatrixinverse(a, n, info, rep, _xparams);
end;


procedure cmatrixinverse(var  a: TCMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling cmatrixinverse: looks like one of arguments has wrong size');

    n := xcols(a);

    _core_cmatrixinverse(a, n, info, rep, _xparams);

end;


procedure _core_spdmatrixcholeskyinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_spdmatrixcholeskyinverse(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskyinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure spdmatrixcholeskyinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spdmatrixcholeskyinverse(a, n, isupper, info, rep, _xparams);
end;


procedure spdmatrixcholeskyinverse(var  a: TMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    isupper: Boolean;

begin
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling spdmatrixcholeskyinverse: looks like one of arguments has wrong size');

    n := xcols(a);
    isupper := False;

    _core_spdmatrixcholeskyinverse(a, n, isupper, info, rep, _xparams);

end;


procedure _core_spdmatrixinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_spdmatrixinverse(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure spdmatrixinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spdmatrixinverse(a, n, isupper, info, rep, _xparams);
end;


procedure spdmatrixinverse(var  a: TMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    isupper: Boolean;

begin
    if not xissymmetric(a) then
        raise Exception.Create('a parameter is not symmetric matrix');
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling spdmatrixinverse: looks like one of arguments has wrong size');

    n := xcols(a);
    isupper := False;

    _core_spdmatrixinverse(a, n, isupper, info, rep, _xparams);
    if not xforcesymmetric(a) then
        raise Exception.Create('Internal error while forcing symmetric properties for a parameter');

end;


procedure _core_hpdmatrixcholeskyinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_hpdmatrixcholeskyinverse(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixcholeskyinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure hpdmatrixcholeskyinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_hpdmatrixcholeskyinverse(a, n, isupper, info, rep, _xparams);
end;


procedure hpdmatrixcholeskyinverse(var  a: TCMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    isupper: Boolean;

begin
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling hpdmatrixcholeskyinverse: looks like one of arguments has wrong size');

    n := xcols(a);
    isupper := False;

    _core_hpdmatrixcholeskyinverse(a, n, isupper, info, rep, _xparams);

end;


procedure _core_hpdmatrixinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_hpdmatrixinverse(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure hpdmatrixinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_hpdmatrixinverse(a, n, isupper, info, rep, _xparams);
end;


procedure hpdmatrixinverse(var  a: TCMatrix; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    isupper: Boolean;

begin
    if not xishermitian(a) then
        raise Exception.Create('a parameter is not hermitian matrix');
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling hpdmatrixinverse: looks like one of arguments has wrong size');

    n := xcols(a);
    isupper := False;

    _core_hpdmatrixinverse(a, n, isupper, info, rep, _xparams);
    if not xforcehermitian(a) then
        raise Exception.Create('Internal error while forcing hermitian properties for a parameter');

end;


procedure _core_rmatrixtrinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_rmatrixtrinverse(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_isunit, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixtrinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure rmatrixtrinverse(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_rmatrixtrinverse(a, n, isupper, isunit, info, rep, _xparams);
end;


procedure rmatrixtrinverse(var  a: TMatrix;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    isunit: Boolean;

begin
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling rmatrixtrinverse: looks like one of arguments has wrong size');

    n := xcols(a);
    isunit := False;

    _core_rmatrixtrinverse(a, n, isupper, isunit, info, rep, _xparams);

end;


procedure _core_cmatrixtrinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_isunit: Byte;
    _d_info: NativeInt;
    _d_rep: x_matinvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _d_isunit := Bool2Byte(isunit);
        x_matinvreport_init(_d_rep);
        _error_code := x_xv2_cmatrixtrinverse(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_isunit, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixtrinverse call');
        end;
        x_to_array(_d_a, a);
        info := _d_info;
        x_matinvreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_matinvreport_clear(_d_rep);
    end;
end;


procedure cmatrixtrinverse(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  isunit: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
begin
    _core_cmatrixtrinverse(a, n, isupper, isunit, info, rep, _xparams);
end;


procedure cmatrixtrinverse(var  a: TCMatrix;  isupper: Boolean; out  info: TALGLIBInteger; out  rep: Tmatinvreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    isunit: Boolean;

begin
    if ((xcols(a)<>xrows(a))) then
    raise Exception.Create('Error while calling cmatrixtrinverse: looks like one of arguments has wrong size');

    n := xcols(a);
    isunit := False;

    _core_cmatrixtrinverse(a, n, isupper, isunit, info, rep, _xparams);

end;


procedure _core_rmatrixqr(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_tau, DT_REAL);
        tau := nil;
        _error_code := x_xv2_rmatrixqr(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixqr call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tau, tau);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
    end;
end;


procedure rmatrixqr(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixqr(a, m, n, tau, _xparams);
end;


procedure _core_rmatrixlq(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_tau, DT_REAL);
        tau := nil;
        _error_code := x_xv2_rmatrixlq(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlq call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tau, tau);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
    end;
end;


procedure rmatrixlq(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlq(a, m, n, tau, _xparams);
end;


procedure _core_cmatrixqr(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_tau, DT_COMPLEX);
        tau := nil;
        _error_code := x_xv2_cmatrixqr(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixqr call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tau, tau);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
    end;
end;


procedure cmatrixqr(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TCVector; const _xparams: UInt64 = 0);
begin
    _core_cmatrixqr(a, m, n, tau, _xparams);
end;


procedure _core_cmatrixlq(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_tau, DT_COMPLEX);
        tau := nil;
        _error_code := x_xv2_cmatrixlq(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlq call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tau, tau);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
    end;
end;


procedure cmatrixlq(var  a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tau: TCVector; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlq(a, m, n, tau, _xparams);
end;


procedure _core_rmatrixqrunpackq( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TVector;  qcolumns: TALGLIBInteger; out  q: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
    _d_qcolumns: NativeInt;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_tau, tau, X_CREATE);
        _d_qcolumns := qcolumns;
        x_create_empty(_d_q, DT_REAL);
        q := nil;
        _error_code := x_xv2_rmatrixqrunpackq(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, @_d_qcolumns, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixqrunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_q);
    end;
end;


procedure rmatrixqrunpackq( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TVector;  qcolumns: TALGLIBInteger; out  q: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixqrunpackq(a, m, n, tau, qcolumns, q, _xparams);
end;


procedure _core_rmatrixqrunpackr( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  r: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_r: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_r, DT_REAL);
        r := nil;
        _error_code := x_xv2_rmatrixqrunpackr(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixqrunpackr call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_r);
    end;
end;


procedure rmatrixqrunpackr( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  r: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixqrunpackr(a, m, n, r, _xparams);
end;


procedure _core_rmatrixlqunpackq( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TVector;  qrows: TALGLIBInteger; out  q: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
    _d_qrows: NativeInt;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_tau, tau, X_CREATE);
        _d_qrows := qrows;
        x_create_empty(_d_q, DT_REAL);
        q := nil;
        _error_code := x_xv2_rmatrixlqunpackq(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, @_d_qrows, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlqunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_q);
    end;
end;


procedure rmatrixlqunpackq( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TVector;  qrows: TALGLIBInteger; out  q: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlqunpackq(a, m, n, tau, qrows, q, _xparams);
end;


procedure _core_rmatrixlqunpackl( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  l: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_l: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_l, DT_REAL);
        l := nil;
        _error_code := x_xv2_rmatrixlqunpackl(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_l, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlqunpackl call');
        end;
        x_to_array(_d_l, l);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_l);
    end;
end;


procedure rmatrixlqunpackl( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  l: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlqunpackl(a, m, n, l, _xparams);
end;


procedure _core_cmatrixqrunpackq( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TCVector;  qcolumns: TALGLIBInteger; out  q: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
    _d_qcolumns: NativeInt;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_tau, tau, X_CREATE);
        _d_qcolumns := qcolumns;
        x_create_empty(_d_q, DT_COMPLEX);
        q := nil;
        _error_code := x_xv2_cmatrixqrunpackq(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, @_d_qcolumns, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixqrunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_q);
    end;
end;


procedure cmatrixqrunpackq( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TCVector;  qcolumns: TALGLIBInteger; out  q: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixqrunpackq(a, m, n, tau, qcolumns, q, _xparams);
end;


procedure _core_cmatrixqrunpackr( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  r: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_r: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_r, DT_COMPLEX);
        r := nil;
        _error_code := x_xv2_cmatrixqrunpackr(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixqrunpackr call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_r);
    end;
end;


procedure cmatrixqrunpackr( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  r: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixqrunpackr(a, m, n, r, _xparams);
end;


procedure _core_cmatrixlqunpackq( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TCVector;  qrows: TALGLIBInteger; out  q: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tau: x_vector;
    _d_qrows: NativeInt;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_tau, tau, X_CREATE);
        _d_qrows := qrows;
        x_create_empty(_d_q, DT_COMPLEX);
        q := nil;
        _error_code := x_xv2_cmatrixlqunpackq(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tau, @_d_qrows, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlqunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_q);
    end;
end;


procedure cmatrixlqunpackq( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tau: TCVector;  qrows: TALGLIBInteger; out  q: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlqunpackq(a, m, n, tau, qrows, q, _xparams);
end;


procedure _core_cmatrixlqunpackl( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  l: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_l: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_l, DT_COMPLEX);
        l := nil;
        _error_code := x_xv2_cmatrixlqunpackl(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_l, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlqunpackl call');
        end;
        x_to_array(_d_l, l);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_l);
    end;
end;


procedure cmatrixlqunpackl( a: TCMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  l: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlqunpackl(a, m, n, l, _xparams);
end;


procedure _core_rmatrixbd(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tauq: TVector; out  taup: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tauq: x_vector;
    _d_taup: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_tauq, DT_REAL);
        tauq := nil;
        x_create_empty(_d_taup, DT_REAL);
        taup := nil;
        _error_code := x_xv2_rmatrixbd(@_s_error_msg, @_d_a, @_d_m, @_d_n, @_d_tauq, @_d_taup, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixbd call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tauq, tauq);
        x_to_array(_d_taup, taup);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tauq);
        x_clear(_d_taup);
    end;
end;


procedure rmatrixbd(var  a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  tauq: TVector; out  taup: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixbd(a, m, n, tauq, taup, _xparams);
end;


procedure _core_rmatrixbdunpackq( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tauq: TVector;  qcolumns: TALGLIBInteger; out  q: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_qp: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tauq: x_vector;
    _d_qcolumns: NativeInt;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_qp, qp, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_tauq, tauq, X_CREATE);
        _d_qcolumns := qcolumns;
        x_create_empty(_d_q, DT_REAL);
        q := nil;
        _error_code := x_xv2_rmatrixbdunpackq(@_s_error_msg, @_d_qp, @_d_m, @_d_n, @_d_tauq, @_d_qcolumns, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixbdunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_qp);
        x_clear(_d_tauq);
        x_clear(_d_q);
    end;
end;


procedure rmatrixbdunpackq( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tauq: TVector;  qcolumns: TALGLIBInteger; out  q: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixbdunpackq(qp, m, n, tauq, qcolumns, q, _xparams);
end;


procedure _core_rmatrixbdmultiplybyq( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tauq: TVector; var  z: TMatrix;  zrows: TALGLIBInteger;  zcolumns: TALGLIBInteger;  fromtheright: Boolean;  dotranspose: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_qp: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tauq: x_vector;
    _d_z: x_matrix;
    _d_zrows: NativeInt;
    _d_zcolumns: NativeInt;
    _d_fromtheright: Byte;
    _d_dotranspose: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_qp, qp, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_tauq, tauq, X_CREATE);
        x_from_array(_d_z, z, X_CREATE);
        _d_zrows := zrows;
        _d_zcolumns := zcolumns;
        _d_fromtheright := Bool2Byte(fromtheright);
        _d_dotranspose := Bool2Byte(dotranspose);
        _error_code := x_xv2_rmatrixbdmultiplybyq(@_s_error_msg, @_d_qp, @_d_m, @_d_n, @_d_tauq, @_d_z, @_d_zrows, @_d_zcolumns, @_d_fromtheright, @_d_dotranspose, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixbdmultiplybyq call');
        end;
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_qp);
        x_clear(_d_tauq);
        x_clear(_d_z);
    end;
end;


procedure rmatrixbdmultiplybyq( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  tauq: TVector; var  z: TMatrix;  zrows: TALGLIBInteger;  zcolumns: TALGLIBInteger;  fromtheright: Boolean;  dotranspose: Boolean; const _xparams: UInt64 = 0);
begin
    _core_rmatrixbdmultiplybyq(qp, m, n, tauq, z, zrows, zcolumns, fromtheright, dotranspose, _xparams);
end;


procedure _core_rmatrixbdunpackpt( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  taup: TVector;  ptrows: TALGLIBInteger; out  pt: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_qp: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_taup: x_vector;
    _d_ptrows: NativeInt;
    _d_pt: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_qp, qp, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_taup, taup, X_CREATE);
        _d_ptrows := ptrows;
        x_create_empty(_d_pt, DT_REAL);
        pt := nil;
        _error_code := x_xv2_rmatrixbdunpackpt(@_s_error_msg, @_d_qp, @_d_m, @_d_n, @_d_taup, @_d_ptrows, @_d_pt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixbdunpackpt call');
        end;
        x_to_array(_d_pt, pt);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_qp);
        x_clear(_d_taup);
        x_clear(_d_pt);
    end;
end;


procedure rmatrixbdunpackpt( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  taup: TVector;  ptrows: TALGLIBInteger; out  pt: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixbdunpackpt(qp, m, n, taup, ptrows, pt, _xparams);
end;


procedure _core_rmatrixbdmultiplybyp( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  taup: TVector; var  z: TMatrix;  zrows: TALGLIBInteger;  zcolumns: TALGLIBInteger;  fromtheright: Boolean;  dotranspose: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_qp: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_taup: x_vector;
    _d_z: x_matrix;
    _d_zrows: NativeInt;
    _d_zcolumns: NativeInt;
    _d_fromtheright: Byte;
    _d_dotranspose: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_qp, qp, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_from_array(_d_taup, taup, X_CREATE);
        x_from_array(_d_z, z, X_CREATE);
        _d_zrows := zrows;
        _d_zcolumns := zcolumns;
        _d_fromtheright := Bool2Byte(fromtheright);
        _d_dotranspose := Bool2Byte(dotranspose);
        _error_code := x_xv2_rmatrixbdmultiplybyp(@_s_error_msg, @_d_qp, @_d_m, @_d_n, @_d_taup, @_d_z, @_d_zrows, @_d_zcolumns, @_d_fromtheright, @_d_dotranspose, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixbdmultiplybyp call');
        end;
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_qp);
        x_clear(_d_taup);
        x_clear(_d_z);
    end;
end;


procedure rmatrixbdmultiplybyp( qp: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  taup: TVector; var  z: TMatrix;  zrows: TALGLIBInteger;  zcolumns: TALGLIBInteger;  fromtheright: Boolean;  dotranspose: Boolean; const _xparams: UInt64 = 0);
begin
    _core_rmatrixbdmultiplybyp(qp, m, n, taup, z, zrows, zcolumns, fromtheright, dotranspose, _xparams);
end;


procedure _core_rmatrixbdunpackdiagonals( b: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  isupper: Boolean; out  d: TVector; out  e: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_d: x_vector;
    _d_e: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _d_n := n;
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        x_create_empty(_d_e, DT_REAL);
        e := nil;
        _error_code := x_xv2_rmatrixbdunpackdiagonals(@_s_error_msg, @_d_b, @_d_m, @_d_n, @_d_isupper, @_d_d, @_d_e, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixbdunpackdiagonals call');
        end;
        isupper := Byte2Bool(_d_isupper);
        x_to_array(_d_d, d);
        x_to_array(_d_e, e);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_b);
        x_clear(_d_d);
        x_clear(_d_e);
    end;
end;


procedure rmatrixbdunpackdiagonals( b: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  isupper: Boolean; out  d: TVector; out  e: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixbdunpackdiagonals(b, m, n, isupper, d, e, _xparams);
end;


procedure _core_rmatrixhessenberg(var  a: TMatrix;  n: TALGLIBInteger; out  tau: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_tau: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_create_empty(_d_tau, DT_REAL);
        tau := nil;
        _error_code := x_xv2_rmatrixhessenberg(@_s_error_msg, @_d_a, @_d_n, @_d_tau, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixhessenberg call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tau, tau);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
    end;
end;


procedure rmatrixhessenberg(var  a: TMatrix;  n: TALGLIBInteger; out  tau: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixhessenberg(a, n, tau, _xparams);
end;


procedure _core_rmatrixhessenbergunpackq( a: TMatrix;  n: TALGLIBInteger;  tau: TVector; out  q: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_tau: x_vector;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_tau, tau, X_CREATE);
        x_create_empty(_d_q, DT_REAL);
        q := nil;
        _error_code := x_xv2_rmatrixhessenbergunpackq(@_s_error_msg, @_d_a, @_d_n, @_d_tau, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixhessenbergunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_q);
    end;
end;


procedure rmatrixhessenbergunpackq( a: TMatrix;  n: TALGLIBInteger;  tau: TVector; out  q: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixhessenbergunpackq(a, n, tau, q, _xparams);
end;


procedure _core_rmatrixhessenbergunpackh( a: TMatrix;  n: TALGLIBInteger; out  h: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_h: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_create_empty(_d_h, DT_REAL);
        h := nil;
        _error_code := x_xv2_rmatrixhessenbergunpackh(@_s_error_msg, @_d_a, @_d_n, @_d_h, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixhessenbergunpackh call');
        end;
        x_to_array(_d_h, h);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_h);
    end;
end;


procedure rmatrixhessenbergunpackh( a: TMatrix;  n: TALGLIBInteger; out  h: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixhessenbergunpackh(a, n, h, _xparams);
end;


procedure _core_smatrixtd(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  tau: TVector; out  d: TVector; out  e: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_tau: x_vector;
    _d_d: x_vector;
    _d_e: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_create_empty(_d_tau, DT_REAL);
        tau := nil;
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        x_create_empty(_d_e, DT_REAL);
        e := nil;
        _error_code := x_xv2_smatrixtd(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_tau, @_d_d, @_d_e, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixtd call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tau, tau);
        x_to_array(_d_d, d);
        x_to_array(_d_e, e);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_d);
        x_clear(_d_e);
    end;
end;


procedure smatrixtd(var  a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  tau: TVector; out  d: TVector; out  e: TVector; const _xparams: UInt64 = 0);
begin
    _core_smatrixtd(a, n, isupper, tau, d, e, _xparams);
end;


procedure _core_smatrixtdunpackq( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  tau: TVector; out  q: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_tau: x_vector;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_tau, tau, X_CREATE);
        x_create_empty(_d_q, DT_REAL);
        q := nil;
        _error_code := x_xv2_smatrixtdunpackq(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_tau, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixtdunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_q);
    end;
end;


procedure smatrixtdunpackq( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  tau: TVector; out  q: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_smatrixtdunpackq(a, n, isupper, tau, q, _xparams);
end;


procedure _core_hmatrixtd(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  tau: TCVector; out  d: TVector; out  e: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_tau: x_vector;
    _d_d: x_vector;
    _d_e: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_create_empty(_d_tau, DT_COMPLEX);
        tau := nil;
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        x_create_empty(_d_e, DT_REAL);
        e := nil;
        _error_code := x_xv2_hmatrixtd(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_tau, @_d_d, @_d_e, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hmatrixtd call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_tau, tau);
        x_to_array(_d_d, d);
        x_to_array(_d_e, e);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_d);
        x_clear(_d_e);
    end;
end;


procedure hmatrixtd(var  a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; out  tau: TCVector; out  d: TVector; out  e: TVector; const _xparams: UInt64 = 0);
begin
    _core_hmatrixtd(a, n, isupper, tau, d, e, _xparams);
end;


procedure _core_hmatrixtdunpackq( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  tau: TCVector; out  q: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_tau: x_vector;
    _d_q: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_tau, tau, X_CREATE);
        x_create_empty(_d_q, DT_COMPLEX);
        q := nil;
        _error_code := x_xv2_hmatrixtdunpackq(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_tau, @_d_q, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hmatrixtdunpackq call');
        end;
        x_to_array(_d_q, q);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_tau);
        x_clear(_d_q);
    end;
end;


procedure hmatrixtdunpackq( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  tau: TCVector; out  q: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_hmatrixtdunpackq(a, n, isupper, tau, q, _xparams);
end;

function Clone(const Src: Toptguardreport):Toptguardreport;overload;
begin
    Result.nonc0suspected := src.nonc0suspected;
    Result.nonc0test0positive := src.nonc0test0positive;
    Result.nonc0fidx := src.nonc0fidx;
    Result.nonc0lipschitzc := src.nonc0lipschitzc;
    Result.nonc1suspected := src.nonc1suspected;
    Result.nonc1test0positive := src.nonc1test0positive;
    Result.nonc1test1positive := src.nonc1test1positive;
    Result.nonc1fidx := src.nonc1fidx;
    Result.nonc1lipschitzc := src.nonc1lipschitzc;
    Result.badgradsuspected := src.badgradsuspected;
    Result.badgradfidx := src.badgradfidx;
    Result.badgradvidx := src.badgradvidx;
    Result.badgradxbase := Clone(src.badgradxbase);
    Result.badgraduser := Clone(src.badgraduser);
    Result.badgradnum := Clone(src.badgradnum);
end;

procedure x_optguardreport_init(var x: x_optguardreport);
begin
    x.nonc0suspected := 0;
    x.nonc0test0positive := 0;
    x.nonc0fidx.longval := 0;
    x.nonc0lipschitzc := 0;
    x.nonc1suspected := 0;
    x.nonc1test0positive := 0;
    x.nonc1test1positive := 0;
    x.nonc1fidx.longval := 0;
    x.nonc1lipschitzc := 0;
    x.badgradsuspected := 0;
    x.badgradfidx.longval := 0;
    x.badgradvidx.longval := 0;
    x_create_empty(x.badgradxbase, DT_REAL);
    x_create_empty(x.badgraduser, DT_REAL);
    x_create_empty(x.badgradnum, DT_REAL);
end;

procedure x_optguardreport_clear(var x: x_optguardreport);
begin
    x_clear(x.badgradxbase);
    x_clear(x.badgraduser);
    x_clear(x.badgradnum);
end;

procedure x_optguardreport_init_from(var x: x_optguardreport; const v: Toptguardreport);
begin
    x.nonc0suspected := Bool2Uint64T(v.nonc0suspected);
    x.nonc0test0positive := Bool2Uint64T(v.nonc0test0positive);
    x.nonc0fidx.longval := v.nonc0fidx;
    x.nonc0lipschitzc := v.nonc0lipschitzc;
    x.nonc1suspected := Bool2Uint64T(v.nonc1suspected);
    x.nonc1test0positive := Bool2Uint64T(v.nonc1test0positive);
    x.nonc1test1positive := Bool2Uint64T(v.nonc1test1positive);
    x.nonc1fidx.longval := v.nonc1fidx;
    x.nonc1lipschitzc := v.nonc1lipschitzc;
    x.badgradsuspected := Bool2Uint64T(v.badgradsuspected);
    x.badgradfidx.longval := v.badgradfidx;
    x.badgradvidx.longval := v.badgradvidx;
    x_from_array(x.badgradxbase, v.badgradxbase, X_CREATE);
    x_from_array(x.badgraduser, v.badgraduser, X_CREATE);
    x_from_array(x.badgradnum, v.badgradnum, X_CREATE);
end;

procedure x_optguardreport_to_record(const x: x_optguardreport; var v: Toptguardreport);
begin
    v.nonc0suspected := Uint64T2Bool(x.nonc0suspected);
    v.nonc0test0positive := Uint64T2Bool(x.nonc0test0positive);
    v.nonc0fidx := x.nonc0fidx.val; // long is silently truncated to TALGLIBInteger
    v.nonc0lipschitzc := x.nonc0lipschitzc;
    v.nonc1suspected := Uint64T2Bool(x.nonc1suspected);
    v.nonc1test0positive := Uint64T2Bool(x.nonc1test0positive);
    v.nonc1test1positive := Uint64T2Bool(x.nonc1test1positive);
    v.nonc1fidx := x.nonc1fidx.val; // long is silently truncated to TALGLIBInteger
    v.nonc1lipschitzc := x.nonc1lipschitzc;
    v.badgradsuspected := Uint64T2Bool(x.badgradsuspected);
    v.badgradfidx := x.badgradfidx.val; // long is silently truncated to TALGLIBInteger
    v.badgradvidx := x.badgradvidx.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.badgradxbase, v.badgradxbase);
    x_to_array(x.badgraduser, v.badgraduser);
    x_to_array(x.badgradnum, v.badgradnum);
end;

function Clone(const Src: Toptguardnonc0report):Toptguardnonc0report;overload;
begin
    Result.positive := src.positive;
    Result.fidx := src.fidx;
    Result.x0 := Clone(src.x0);
    Result.d := Clone(src.d);
    Result.n := src.n;
    Result.stp := Clone(src.stp);
    Result.f := Clone(src.f);
    Result.cnt := src.cnt;
    Result.stpidxa := src.stpidxa;
    Result.stpidxb := src.stpidxb;
end;

procedure x_optguardnonc0report_init(var x: x_optguardnonc0report);
begin
    x.positive := 0;
    x.fidx.longval := 0;
    x_create_empty(x.x0, DT_REAL);
    x_create_empty(x.d, DT_REAL);
    x.n.longval := 0;
    x_create_empty(x.stp, DT_REAL);
    x_create_empty(x.f, DT_REAL);
    x.cnt.longval := 0;
    x.stpidxa.longval := 0;
    x.stpidxb.longval := 0;
end;

procedure x_optguardnonc0report_clear(var x: x_optguardnonc0report);
begin
    x_clear(x.x0);
    x_clear(x.d);
    x_clear(x.stp);
    x_clear(x.f);
end;

procedure x_optguardnonc0report_init_from(var x: x_optguardnonc0report; const v: Toptguardnonc0report);
begin
    x.positive := Bool2Uint64T(v.positive);
    x.fidx.longval := v.fidx;
    x_from_array(x.x0, v.x0, X_CREATE);
    x_from_array(x.d, v.d, X_CREATE);
    x.n.longval := v.n;
    x_from_array(x.stp, v.stp, X_CREATE);
    x_from_array(x.f, v.f, X_CREATE);
    x.cnt.longval := v.cnt;
    x.stpidxa.longval := v.stpidxa;
    x.stpidxb.longval := v.stpidxb;
end;

procedure x_optguardnonc0report_to_record(const x: x_optguardnonc0report; var v: Toptguardnonc0report);
begin
    v.positive := Uint64T2Bool(x.positive);
    v.fidx := x.fidx.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.x0, v.x0);
    x_to_array(x.d, v.d);
    v.n := x.n.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.stp, v.stp);
    x_to_array(x.f, v.f);
    v.cnt := x.cnt.val; // long is silently truncated to TALGLIBInteger
    v.stpidxa := x.stpidxa.val; // long is silently truncated to TALGLIBInteger
    v.stpidxb := x.stpidxb.val; // long is silently truncated to TALGLIBInteger
end;

function Clone(const Src: Toptguardnonc1test0report):Toptguardnonc1test0report;overload;
begin
    Result.positive := src.positive;
    Result.fidx := src.fidx;
    Result.x0 := Clone(src.x0);
    Result.d := Clone(src.d);
    Result.n := src.n;
    Result.stp := Clone(src.stp);
    Result.f := Clone(src.f);
    Result.cnt := src.cnt;
    Result.stpidxa := src.stpidxa;
    Result.stpidxb := src.stpidxb;
end;

procedure x_optguardnonc1test0report_init(var x: x_optguardnonc1test0report);
begin
    x.positive := 0;
    x.fidx.longval := 0;
    x_create_empty(x.x0, DT_REAL);
    x_create_empty(x.d, DT_REAL);
    x.n.longval := 0;
    x_create_empty(x.stp, DT_REAL);
    x_create_empty(x.f, DT_REAL);
    x.cnt.longval := 0;
    x.stpidxa.longval := 0;
    x.stpidxb.longval := 0;
end;

procedure x_optguardnonc1test0report_clear(var x: x_optguardnonc1test0report);
begin
    x_clear(x.x0);
    x_clear(x.d);
    x_clear(x.stp);
    x_clear(x.f);
end;

procedure x_optguardnonc1test0report_init_from(var x: x_optguardnonc1test0report; const v: Toptguardnonc1test0report);
begin
    x.positive := Bool2Uint64T(v.positive);
    x.fidx.longval := v.fidx;
    x_from_array(x.x0, v.x0, X_CREATE);
    x_from_array(x.d, v.d, X_CREATE);
    x.n.longval := v.n;
    x_from_array(x.stp, v.stp, X_CREATE);
    x_from_array(x.f, v.f, X_CREATE);
    x.cnt.longval := v.cnt;
    x.stpidxa.longval := v.stpidxa;
    x.stpidxb.longval := v.stpidxb;
end;

procedure x_optguardnonc1test0report_to_record(const x: x_optguardnonc1test0report; var v: Toptguardnonc1test0report);
begin
    v.positive := Uint64T2Bool(x.positive);
    v.fidx := x.fidx.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.x0, v.x0);
    x_to_array(x.d, v.d);
    v.n := x.n.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.stp, v.stp);
    x_to_array(x.f, v.f);
    v.cnt := x.cnt.val; // long is silently truncated to TALGLIBInteger
    v.stpidxa := x.stpidxa.val; // long is silently truncated to TALGLIBInteger
    v.stpidxb := x.stpidxb.val; // long is silently truncated to TALGLIBInteger
end;

function Clone(const Src: Toptguardnonc1test1report):Toptguardnonc1test1report;overload;
begin
    Result.positive := src.positive;
    Result.fidx := src.fidx;
    Result.vidx := src.vidx;
    Result.x0 := Clone(src.x0);
    Result.d := Clone(src.d);
    Result.n := src.n;
    Result.stp := Clone(src.stp);
    Result.g := Clone(src.g);
    Result.cnt := src.cnt;
    Result.stpidxa := src.stpidxa;
    Result.stpidxb := src.stpidxb;
end;

procedure x_optguardnonc1test1report_init(var x: x_optguardnonc1test1report);
begin
    x.positive := 0;
    x.fidx.longval := 0;
    x.vidx.longval := 0;
    x_create_empty(x.x0, DT_REAL);
    x_create_empty(x.d, DT_REAL);
    x.n.longval := 0;
    x_create_empty(x.stp, DT_REAL);
    x_create_empty(x.g, DT_REAL);
    x.cnt.longval := 0;
    x.stpidxa.longval := 0;
    x.stpidxb.longval := 0;
end;

procedure x_optguardnonc1test1report_clear(var x: x_optguardnonc1test1report);
begin
    x_clear(x.x0);
    x_clear(x.d);
    x_clear(x.stp);
    x_clear(x.g);
end;

procedure x_optguardnonc1test1report_init_from(var x: x_optguardnonc1test1report; const v: Toptguardnonc1test1report);
begin
    x.positive := Bool2Uint64T(v.positive);
    x.fidx.longval := v.fidx;
    x.vidx.longval := v.vidx;
    x_from_array(x.x0, v.x0, X_CREATE);
    x_from_array(x.d, v.d, X_CREATE);
    x.n.longval := v.n;
    x_from_array(x.stp, v.stp, X_CREATE);
    x_from_array(x.g, v.g, X_CREATE);
    x.cnt.longval := v.cnt;
    x.stpidxa.longval := v.stpidxa;
    x.stpidxb.longval := v.stpidxb;
end;

procedure x_optguardnonc1test1report_to_record(const x: x_optguardnonc1test1report; var v: Toptguardnonc1test1report);
begin
    v.positive := Uint64T2Bool(x.positive);
    v.fidx := x.fidx.val; // long is silently truncated to TALGLIBInteger
    v.vidx := x.vidx.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.x0, v.x0);
    x_to_array(x.d, v.d);
    v.n := x.n.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.stp, v.stp);
    x_to_array(x.g, v.g);
    v.cnt := x.cnt.val; // long is silently truncated to TALGLIBInteger
    v.stpidxa := x.stpidxa.val; // long is silently truncated to TALGLIBInteger
    v.stpidxb := x.stpidxb.val; // long is silently truncated to TALGLIBInteger
end;


function _core_rmatrixbdsvd(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  isupper: Boolean;  isfractionalaccuracyrequired: Boolean; var  u: TMatrix;  nru: TALGLIBInteger; var  c: TMatrix;  ncc: TALGLIBInteger; var  vt: TMatrix;  ncvt: TALGLIBInteger; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_d: x_vector;
    _d_e: x_vector;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_isfractionalaccuracyrequired: Byte;
    _d_u: x_matrix;
    _d_nru: NativeInt;
    _d_c: x_matrix;
    _d_ncc: NativeInt;
    _d_vt: x_matrix;
    _d_ncvt: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_d, d, X_CREATE);
        x_from_array(_d_e, e, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _d_isfractionalaccuracyrequired := Bool2Byte(isfractionalaccuracyrequired);
        x_from_array(_d_u, u, X_CREATE);
        _d_nru := nru;
        x_from_array(_d_c, c, X_CREATE);
        _d_ncc := ncc;
        x_from_array(_d_vt, vt, X_CREATE);
        _d_ncvt := ncvt;
        _error_code := x_xv2_rmatrixbdsvd(@_s_error_msg, @_d_result, @_d_d, @_d_e, @_d_n, @_d_isupper, @_d_isfractionalaccuracyrequired, @_d_u, @_d_nru, @_d_c, @_d_ncc, @_d_vt, @_d_ncvt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixbdsvd call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_d, d);
        x_to_array(_d_u, u);
        x_to_array(_d_c, c);
        x_to_array(_d_vt, vt);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
        x_clear(_d_e);
        x_clear(_d_u);
        x_clear(_d_c);
        x_clear(_d_vt);
    end;
end;


function rmatrixbdsvd(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  isupper: Boolean;  isfractionalaccuracyrequired: Boolean; var  u: TMatrix;  nru: TALGLIBInteger; var  c: TMatrix;  ncc: TALGLIBInteger; var  vt: TMatrix;  ncvt: TALGLIBInteger; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_rmatrixbdsvd(d, e, n, isupper, isfractionalaccuracyrequired, u, nru, c, ncc, vt, ncvt, _xparams);
end;


function _core_rmatrixsvd( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  uneeded: TALGLIBInteger;  vtneeded: TALGLIBInteger;  additionalmemory: TALGLIBInteger; out  w: TVector; out  u: TMatrix; out  vt: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_uneeded: NativeInt;
    _d_vtneeded: NativeInt;
    _d_additionalmemory: NativeInt;
    _d_w: x_vector;
    _d_u: x_matrix;
    _d_vt: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        _d_n := n;
        _d_uneeded := uneeded;
        _d_vtneeded := vtneeded;
        _d_additionalmemory := additionalmemory;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_u, DT_REAL);
        u := nil;
        x_create_empty(_d_vt, DT_REAL);
        vt := nil;
        _error_code := x_xv2_rmatrixsvd(@_s_error_msg, @_d_result, @_d_a, @_d_m, @_d_n, @_d_uneeded, @_d_vtneeded, @_d_additionalmemory, @_d_w, @_d_u, @_d_vt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsvd call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_w, w);
        x_to_array(_d_u, u);
        x_to_array(_d_vt, vt);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_w);
        x_clear(_d_u);
        x_clear(_d_vt);
    end;
end;


function rmatrixsvd( a: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger;  uneeded: TALGLIBInteger;  vtneeded: TALGLIBInteger;  additionalmemory: TALGLIBInteger; out  w: TVector; out  u: TMatrix; out  vt: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory, w, u, vt, _xparams);
end;

function Clone(const Src: Tdensesolverreport):Tdensesolverreport;overload;
begin
    Result.r1 := src.r1;
    Result.rinf := src.rinf;
end;

procedure x_densesolverreport_init(var x: x_densesolverreport);
begin
    x.r1 := 0;
    x.rinf := 0;
end;

procedure x_densesolverreport_clear(var x: x_densesolverreport);
begin
end;

procedure x_densesolverreport_init_from(var x: x_densesolverreport; const v: Tdensesolverreport);
begin
    x.r1 := v.r1;
    x.rinf := v.rinf;
end;

procedure x_densesolverreport_to_record(const x: x_densesolverreport; var v: Tdensesolverreport);
begin
    v.r1 := x.r1;
    v.rinf := x.rinf;
end;

function Clone(const Src: Tdensesolverlsreport):Tdensesolverlsreport;overload;
begin
    Result.r2 := src.r2;
    Result.cx := Clone(src.cx);
    Result.n := src.n;
    Result.k := src.k;
end;

procedure x_densesolverlsreport_init(var x: x_densesolverlsreport);
begin
    x.r2 := 0;
    x_create_empty(x.cx, DT_REAL);
    x.n.longval := 0;
    x.k.longval := 0;
end;

procedure x_densesolverlsreport_clear(var x: x_densesolverlsreport);
begin
    x_clear(x.cx);
end;

procedure x_densesolverlsreport_init_from(var x: x_densesolverlsreport; const v: Tdensesolverlsreport);
begin
    x.r2 := v.r2;
    x_from_array(x.cx, v.cx, X_CREATE);
    x.n.longval := v.n;
    x.k.longval := v.k;
end;

procedure x_densesolverlsreport_to_record(const x: x_densesolverlsreport; var v: Tdensesolverlsreport);
begin
    v.r2 := x.r2;
    x_to_array(x.cx, v.cx);
    v.n := x.n.val; // long is silently truncated to TALGLIBInteger
    v.k := x.k.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_rmatrixsolve( a: TMatrix;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_rmatrixsolve(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure rmatrixsolve( a: TMatrix;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixsolve(a, n, b, info, rep, x, _xparams);
end;


procedure _core_rmatrixsolvefast( a: TMatrix;  n: TALGLIBInteger; var  b: TVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_rmatrixsolvefast(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure rmatrixsolvefast( a: TMatrix;  n: TALGLIBInteger; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixsolvefast(a, n, b, info, _xparams);
end;


procedure _core_rmatrixsolvem( a: TMatrix;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger;  rfs: Boolean; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_rfs: Byte;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _d_rfs := Bool2Byte(rfs);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_rmatrixsolvem(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_m, @_d_rfs, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure rmatrixsolvem( a: TMatrix;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger;  rfs: Boolean; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixsolvem(a, n, b, m, rfs, info, rep, x, _xparams);
end;


procedure _core_rmatrixsolvemfast( a: TMatrix;  n: TALGLIBInteger; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_rmatrixsolvemfast(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure rmatrixsolvemfast( a: TMatrix;  n: TALGLIBInteger; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixsolvemfast(a, n, b, m, info, _xparams);
end;


procedure _core_rmatrixlusolve( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_rmatrixlusolve(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlusolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure rmatrixlusolve( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlusolve(lua, p, n, b, info, rep, x, _xparams);
end;


procedure _core_rmatrixlusolvefast( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_rmatrixlusolvefast(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlusolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
    end;
end;


procedure rmatrixlusolvefast( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlusolvefast(lua, p, n, b, info, _xparams);
end;


procedure _core_rmatrixlusolvem( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_rmatrixlusolvem(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlusolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure rmatrixlusolvem( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlusolvem(lua, p, n, b, m, info, rep, x, _xparams);
end;


procedure _core_rmatrixlusolvemfast( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_rmatrixlusolvemfast(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixlusolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
    end;
end;


procedure rmatrixlusolvemfast( lua: TMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rmatrixlusolvemfast(lua, p, n, b, m, info, _xparams);
end;


procedure _core_rmatrixmixedsolve( a: TMatrix;  lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_rmatrixmixedsolve(@_s_error_msg, @_d_a, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixmixedsolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure rmatrixmixedsolve( a: TMatrix;  lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixmixedsolve(a, lua, p, n, b, info, rep, x, _xparams);
end;


procedure _core_rmatrixmixedsolvem( a: TMatrix;  lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_rmatrixmixedsolvem(@_s_error_msg, @_d_a, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixmixedsolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure rmatrixmixedsolvem( a: TMatrix;  lua: TMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rmatrixmixedsolvem(a, lua, p, n, b, m, info, rep, x, _xparams);
end;


procedure _core_cmatrixsolvem( a: TCMatrix;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger;  rfs: Boolean; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_rfs: Byte;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _d_rfs := Bool2Byte(rfs);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_cmatrixsolvem(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_m, @_d_rfs, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixsolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure cmatrixsolvem( a: TCMatrix;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger;  rfs: Boolean; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixsolvem(a, n, b, m, rfs, info, rep, x, _xparams);
end;


procedure _core_cmatrixsolvemfast( a: TCMatrix;  n: TALGLIBInteger; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_cmatrixsolvemfast(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixsolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure cmatrixsolvemfast( a: TCMatrix;  n: TALGLIBInteger; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixsolvemfast(a, n, b, m, info, _xparams);
end;


procedure _core_cmatrixsolve( a: TCMatrix;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_cmatrixsolve(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixsolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure cmatrixsolve( a: TCMatrix;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
begin
    _core_cmatrixsolve(a, n, b, info, rep, x, _xparams);
end;


procedure _core_cmatrixsolvefast( a: TCMatrix;  n: TALGLIBInteger; var  b: TCVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_cmatrixsolvefast(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixsolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure cmatrixsolvefast( a: TCMatrix;  n: TALGLIBInteger; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixsolvefast(a, n, b, info, _xparams);
end;


procedure _core_cmatrixlusolvem( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_cmatrixlusolvem(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlusolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure cmatrixlusolvem( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlusolvem(lua, p, n, b, m, info, rep, x, _xparams);
end;


procedure _core_cmatrixlusolvemfast( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_cmatrixlusolvemfast(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlusolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
    end;
end;


procedure cmatrixlusolvemfast( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlusolvemfast(lua, p, n, b, m, info, _xparams);
end;


procedure _core_cmatrixlusolve( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_cmatrixlusolve(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlusolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure cmatrixlusolve( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlusolve(lua, p, n, b, info, rep, x, _xparams);
end;


procedure _core_cmatrixlusolvefast( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TCVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_cmatrixlusolvefast(@_s_error_msg, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixlusolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
    end;
end;


procedure cmatrixlusolvefast( lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_cmatrixlusolvefast(lua, p, n, b, info, _xparams);
end;


procedure _core_cmatrixmixedsolvem( a: TCMatrix;  lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_cmatrixmixedsolvem(@_s_error_msg, @_d_a, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixmixedsolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure cmatrixmixedsolvem( a: TCMatrix;  lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_cmatrixmixedsolvem(a, lua, p, n, b, m, info, rep, x, _xparams);
end;


procedure _core_cmatrixmixedsolve( a: TCMatrix;  lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_lua: x_matrix;
    _d_p: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_lua, lua, X_CREATE);
        x_from_array(_d_p, p, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_cmatrixmixedsolve(@_s_error_msg, @_d_a, @_d_lua, @_d_p, @_d_n, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixmixedsolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_lua);
        x_clear(_d_p);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure cmatrixmixedsolve( a: TCMatrix;  lua: TCMatrix;  p: TIVector;  n: TALGLIBInteger;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
begin
    _core_cmatrixmixedsolve(a, lua, p, n, b, info, rep, x, _xparams);
end;


procedure _core_spdmatrixsolvem( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_spdmatrixsolvem(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixsolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure spdmatrixsolvem( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixsolvem(a, n, isupper, b, m, info, rep, x, _xparams);
end;


procedure _core_spdmatrixsolvemfast( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_spdmatrixsolvemfast(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixsolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure spdmatrixsolvemfast( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixsolvemfast(a, n, isupper, b, m, info, _xparams);
end;


procedure _core_spdmatrixsolve( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_spdmatrixsolve(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixsolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure spdmatrixsolve( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixsolve(a, n, isupper, b, info, rep, x, _xparams);
end;


procedure _core_spdmatrixsolvefast( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_spdmatrixsolvefast(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixsolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure spdmatrixsolvefast( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixsolvefast(a, n, isupper, b, info, _xparams);
end;


procedure _core_spdmatrixcholeskysolvem( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_spdmatrixcholeskysolvem(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskysolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure spdmatrixcholeskysolvem( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskysolvem(cha, n, isupper, b, m, info, rep, x, _xparams);
end;


procedure _core_spdmatrixcholeskysolvemfast( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_spdmatrixcholeskysolvemfast(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskysolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
    end;
end;


procedure spdmatrixcholeskysolvemfast( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskysolvemfast(cha, n, isupper, b, m, info, _xparams);
end;


procedure _core_spdmatrixcholeskysolve( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_spdmatrixcholeskysolve(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskysolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure spdmatrixcholeskysolve( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskysolve(cha, n, isupper, b, info, rep, x, _xparams);
end;


procedure _core_spdmatrixcholeskysolvefast( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_spdmatrixcholeskysolvefast(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskysolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
    end;
end;


procedure spdmatrixcholeskysolvefast( cha: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spdmatrixcholeskysolvefast(cha, n, isupper, b, info, _xparams);
end;


procedure _core_hpdmatrixsolvem( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_hpdmatrixsolvem(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixsolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure hpdmatrixsolvem( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixsolvem(a, n, isupper, b, m, info, rep, x, _xparams);
end;


procedure _core_hpdmatrixsolvemfast( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_hpdmatrixsolvemfast(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixsolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure hpdmatrixsolvemfast( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixsolvemfast(a, n, isupper, b, m, info, _xparams);
end;


procedure _core_hpdmatrixsolve( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_hpdmatrixsolve(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixsolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure hpdmatrixsolve( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixsolve(a, n, isupper, b, info, rep, x, _xparams);
end;


procedure _core_hpdmatrixsolvefast( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_hpdmatrixsolvefast(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixsolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure hpdmatrixsolvefast( a: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixsolvefast(a, n, isupper, b, info, _xparams);
end;


procedure _core_hpdmatrixcholeskysolvem( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_hpdmatrixcholeskysolvem(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixcholeskysolvem call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure hpdmatrixcholeskysolvem( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCMatrix; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixcholeskysolvem(cha, n, isupper, b, m, info, rep, x, _xparams);
end;


procedure _core_hpdmatrixcholeskysolvemfast( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_matrix;
    _d_m: NativeInt;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_hpdmatrixcholeskysolvemfast(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_m, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixcholeskysolvemfast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
    end;
end;


procedure hpdmatrixcholeskysolvemfast( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCMatrix;  m: TALGLIBInteger; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixcholeskysolvemfast(cha, n, isupper, b, m, info, _xparams);
end;


procedure _core_hpdmatrixcholeskysolve( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
    _d_rep: x_densesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        x_densesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        _error_code := x_xv2_hpdmatrixcholeskysolve(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixcholeskysolve call');
        end;
        info := _d_info;
        x_densesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
        x_densesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure hpdmatrixcholeskysolve( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TCVector; out  info: TALGLIBInteger; out  rep: Tdensesolverreport; out  x: TCVector; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixcholeskysolve(cha, n, isupper, b, info, rep, x, _xparams);
end;


procedure _core_hpdmatrixcholeskysolvefast( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCVector; out  info: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_cha: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_info: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_cha, cha, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_hpdmatrixcholeskysolvefast(@_s_error_msg, @_d_cha, @_d_n, @_d_isupper, @_d_b, @_d_info, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hpdmatrixcholeskysolvefast call');
        end;
        x_to_array(_d_b, b);
        info := _d_info;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_cha);
        x_clear(_d_b);
    end;
end;


procedure hpdmatrixcholeskysolvefast( cha: TCMatrix;  n: TALGLIBInteger;  isupper: Boolean; var  b: TCVector; out  info: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_hpdmatrixcholeskysolvefast(cha, n, isupper, b, info, _xparams);
end;


procedure _core_rmatrixsolvels( a: TMatrix;  nrows: TALGLIBInteger;  ncols: TALGLIBInteger;  b: TVector;  threshold: Double; out  info: TALGLIBInteger; out  rep: Tdensesolverlsreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_nrows: NativeInt;
    _d_ncols: NativeInt;
    _d_b: x_vector;
    _d_threshold: Double;
    _d_info: NativeInt;
    _d_rep: x_densesolverlsreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_nrows := nrows;
        _d_ncols := ncols;
        x_from_array(_d_b, b, X_CREATE);
        _d_threshold := threshold;
        x_densesolverlsreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_rmatrixsolvels(@_s_error_msg, @_d_a, @_d_nrows, @_d_ncols, @_d_b, @_d_threshold, @_d_info, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixsolvels call');
        end;
        info := _d_info;
        x_densesolverlsreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_densesolverlsreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure rmatrixsolvels( a: TMatrix;  nrows: TALGLIBInteger;  ncols: TALGLIBInteger;  b: TVector;  threshold: Double; out  info: TALGLIBInteger; out  rep: Tdensesolverlsreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixsolvels(a, nrows, ncols, b, threshold, info, rep, x, _xparams);
end;

constructor Tminlbfgsstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminlbfgsstate.Destroy();
begin
    Deallocate();
end;

function Tminlbfgsstate.Clone():Tminlbfgsstate;
begin
    if ptr=nil then
        Result:=Tminlbfgsstate.Create(nil)
    else
        Result:=Tminlbfgsstate.Create(x_obj_copy_minlbfgsstate(ptr));
end;

procedure Tminlbfgsstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minlbfgsstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminlbfgsreport):Tminlbfgsreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfev := src.nfev;
    Result.terminationtype := src.terminationtype;
end;

procedure x_minlbfgsreport_init(var x: x_minlbfgsreport);
begin
    x.iterationscount.longval := 0;
    x.nfev.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_minlbfgsreport_clear(var x: x_minlbfgsreport);
begin
end;

procedure x_minlbfgsreport_init_from(var x: x_minlbfgsreport; const v: Tminlbfgsreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfev.longval := v.nfev;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_minlbfgsreport_to_record(const x: x_minlbfgsreport; var v: Tminlbfgsreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minlbfgscreate( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlbfgsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlbfgscreate(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgscreate call');
        end;
        state := Tminlbfgsstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlbfgsstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlbfgscreate( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlbfgscreate(n, m, x, state, _xparams);
end;


procedure minlbfgscreate( m: TALGLIBInteger;  x: TVector; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlbfgscreate(n, m, x, state, _xparams);

end;


procedure _core_minlbfgscreatef( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlbfgsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlbfgscreatef(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgscreatef call');
        end;
        state := Tminlbfgsstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlbfgsstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlbfgscreatef( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlbfgscreatef(n, m, x, diffstep, state, _xparams);
end;


procedure minlbfgscreatef( m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlbfgscreatef(n, m, x, diffstep, state, _xparams);

end;


procedure _core_minlbfgssetcond( state: Tminlbfgsstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsg: Double;
    _d_epsf: Double;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsg := epsg;
        _d_epsf := epsf;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minlbfgssetcond(@_s_error_msg, @_d_state, @_d_epsg, @_d_epsf, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgssetcond( state: Tminlbfgsstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetcond(state, epsg, epsf, epsx, maxits, _xparams);
end;


procedure _core_minlbfgssetxrep( state: Tminlbfgsstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_minlbfgssetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgssetxrep( state: Tminlbfgsstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetxrep(state, needxrep, _xparams);
end;


procedure _core_minlbfgssetstpmax( state: Tminlbfgsstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_minlbfgssetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgssetstpmax( state: Tminlbfgsstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetstpmax(state, stpmax, _xparams);
end;


procedure _core_minlbfgssetscale( state: Tminlbfgsstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minlbfgssetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minlbfgssetscale( state: Tminlbfgsstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetscale(state, s, _xparams);
end;


procedure _core_minlbfgssetprecdefault( state: Tminlbfgsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlbfgssetprecdefault(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetprecdefault call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgssetprecdefault( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetprecdefault(state, _xparams);
end;


procedure _core_minlbfgssetpreccholesky( state: Tminlbfgsstate;  p: TMatrix;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_p: x_matrix;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_p, p, X_CREATE);
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_minlbfgssetpreccholesky(@_s_error_msg, @_d_state, @_d_p, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetpreccholesky call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_p);
    end;
end;


procedure minlbfgssetpreccholesky( state: Tminlbfgsstate;  p: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetpreccholesky(state, p, isupper, _xparams);
end;


procedure _core_minlbfgssetprecdiag( state: Tminlbfgsstate;  d: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_d: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_d, d, X_CREATE);
        _error_code := x_xv2_minlbfgssetprecdiag(@_s_error_msg, @_d_state, @_d_d, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetprecdiag call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
    end;
end;


procedure minlbfgssetprecdiag( state: Tminlbfgsstate;  d: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetprecdiag(state, d, _xparams);
end;


procedure _core_minlbfgssetprecscale( state: Tminlbfgsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlbfgssetprecscale(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetprecscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgssetprecscale( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetprecscale(state, _xparams);
end;


function _core_minlbfgsiteration( state: Tminlbfgsstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlbfgsiteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsiteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function minlbfgsiteration( state: Tminlbfgsstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_minlbfgsiteration(state, _xparams);
end;

procedure minlbfgsoptimize(state: Tminlbfgsstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_needf: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in minlbfgsoptimize() (func is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_minlbfgsstate_get_x(_state, @_xc_arg);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minlbfgsiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minlbfgsstate_get_xupdated(_state, @_xc_xupdated);
        x_minlbfgsstate_get_needf(_state, @_xc_needf);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_minlbfgsstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minlbfgsstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minlbfgsoptimize (some derivatives were not provided?)');
    end;
end;
procedure minlbfgsoptimize(state: Tminlbfgsstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_needfg: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in minlbfgsoptimize() (grad is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_minlbfgsstate_get_x(_state, @_xc_arg);
    x_minlbfgsstate_get_g(_state, @_xc_g);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minlbfgsiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minlbfgsstate_get_xupdated(_state, @_xc_xupdated);
        x_minlbfgsstate_get_needfg(_state, @_xc_needfg);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_f, _pas_g, obj);
            x_minlbfgsstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minlbfgsstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minlbfgsoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_minlbfgsoptguardgradient( state: Tminlbfgsstate;  teststep: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_teststep: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_teststep := teststep;
        _error_code := x_xv2_minlbfgsoptguardgradient(@_s_error_msg, @_d_state, @_d_teststep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsoptguardgradient call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgsoptguardgradient( state: Tminlbfgsstate;  teststep: Double; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsoptguardgradient(state, teststep, _xparams);
end;


procedure _core_minlbfgsoptguardsmoothness( state: Tminlbfgsstate;  level: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_level: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_level := level;
        _error_code := x_xv2_minlbfgsoptguardsmoothness(@_s_error_msg, @_d_state, @_d_level, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsoptguardsmoothness call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgsoptguardsmoothness( state: Tminlbfgsstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minlbfgsoptguardsmoothness(state, level, _xparams);
end;


procedure minlbfgsoptguardsmoothness( state: Tminlbfgsstate; const _xparams: UInt64 = 0);overload;
var
    level: TALGLIBInteger;

begin

    level := 1;

    _core_minlbfgsoptguardsmoothness(state, level, _xparams);

end;


procedure _core_minlbfgsoptguardresults( state: Tminlbfgsstate; out  rep: Toptguardreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_rep: x_optguardreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardreport_init(_d_rep);
        _error_code := x_xv2_minlbfgsoptguardresults(@_s_error_msg, @_d_state, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsoptguardresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardreport_clear(_d_rep);
    end;
end;


procedure minlbfgsoptguardresults( state: Tminlbfgsstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsoptguardresults(state, rep, _xparams);
end;


procedure _core_minlbfgsoptguardnonc1test0results( state: Tminlbfgsstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test0report;
    _d_lngrep: x_optguardnonc1test0report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test0report_init(_d_strrep);
        x_optguardnonc1test0report_init(_d_lngrep);
        _error_code := x_xv2_minlbfgsoptguardnonc1test0results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsoptguardnonc1test0results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test0report_to_record(_d_strrep, strrep);
        x_optguardnonc1test0report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test0report_clear(_d_strrep);
        x_optguardnonc1test0report_clear(_d_lngrep);
    end;
end;


procedure minlbfgsoptguardnonc1test0results( state: Tminlbfgsstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsoptguardnonc1test0results(state, strrep, lngrep, _xparams);
end;


procedure _core_minlbfgsoptguardnonc1test1results( state: Tminlbfgsstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test1report;
    _d_lngrep: x_optguardnonc1test1report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test1report_init(_d_strrep);
        x_optguardnonc1test1report_init(_d_lngrep);
        _error_code := x_xv2_minlbfgsoptguardnonc1test1results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsoptguardnonc1test1results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test1report_to_record(_d_strrep, strrep);
        x_optguardnonc1test1report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test1report_clear(_d_strrep);
        x_optguardnonc1test1report_clear(_d_lngrep);
    end;
end;


procedure minlbfgsoptguardnonc1test1results( state: Tminlbfgsstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsoptguardnonc1test1results(state, strrep, lngrep, _xparams);
end;


procedure _core_minlbfgsresults( state: Tminlbfgsstate; out  x: TVector; out  rep: Tminlbfgsreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minlbfgsreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minlbfgsreport_init(_d_rep);
        _error_code := x_xv2_minlbfgsresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minlbfgsreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minlbfgsreport_clear(_d_rep);
    end;
end;


procedure minlbfgsresults( state: Tminlbfgsstate; out  x: TVector; out  rep: Tminlbfgsreport; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsresults(state, x, rep, _xparams);
end;


procedure _core_minlbfgsresultsbuf( state: Tminlbfgsstate; var  x: TVector;  rep: Tminlbfgsreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minlbfgsreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minlbfgsreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minlbfgsresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minlbfgsreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minlbfgsreport_clear(_d_rep);
    end;
end;


procedure minlbfgsresultsbuf( state: Tminlbfgsstate; var  x: TVector;  rep: Tminlbfgsreport; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsresultsbuf(state, x, rep, _xparams);
end;


procedure _core_minlbfgsrestartfrom( state: Tminlbfgsstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_minlbfgsrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure minlbfgsrestartfrom( state: Tminlbfgsstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsrestartfrom(state, x, _xparams);
end;


procedure _core_minlbfgsrequesttermination( state: Tminlbfgsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlbfgsrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgsrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgsrequesttermination( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
begin
    _core_minlbfgsrequesttermination(state, _xparams);
end;

constructor Tnormestimatorstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tnormestimatorstate.Destroy();
begin
    Deallocate();
end;

function Tnormestimatorstate.Clone():Tnormestimatorstate;
begin
    if ptr=nil then
        Result:=Tnormestimatorstate.Create(nil)
    else
        Result:=Tnormestimatorstate.Create(x_obj_copy_normestimatorstate(ptr));
end;

procedure Tnormestimatorstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_normestimatorstate(ptr);
    ptr:=nil;
end;


procedure _core_normestimatorcreate( m: TALGLIBInteger;  n: TALGLIBInteger;  nstart: TALGLIBInteger;  nits: TALGLIBInteger; out  state: Tnormestimatorstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_nstart: NativeInt;
    _d_nits: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_nstart := nstart;
        _d_nits := nits;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_normestimatorcreate(@_s_error_msg, @_d_m, @_d_n, @_d_nstart, @_d_nits, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during normestimatorcreate call');
        end;
        state := Tnormestimatorstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_normestimatorstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure normestimatorcreate( m: TALGLIBInteger;  n: TALGLIBInteger;  nstart: TALGLIBInteger;  nits: TALGLIBInteger; out  state: Tnormestimatorstate; const _xparams: UInt64 = 0);
begin
    _core_normestimatorcreate(m, n, nstart, nits, state, _xparams);
end;


procedure _core_normestimatorsetseed( state: Tnormestimatorstate;  seedval: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_seedval: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_seedval := seedval;
        _error_code := x_xv2_normestimatorsetseed(@_s_error_msg, @_d_state, @_d_seedval, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during normestimatorsetseed call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure normestimatorsetseed( state: Tnormestimatorstate;  seedval: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_normestimatorsetseed(state, seedval, _xparams);
end;


procedure _core_normestimatorestimatesparse( state: Tnormestimatorstate;  a: Tsparsematrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_a := a.ptr;
        _error_code := x_xv2_normestimatorestimatesparse(@_s_error_msg, @_d_state, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during normestimatorestimatesparse call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure normestimatorestimatesparse( state: Tnormestimatorstate;  a: Tsparsematrix; const _xparams: UInt64 = 0);
begin
    _core_normestimatorestimatesparse(state, a, _xparams);
end;


procedure _core_normestimatorresults( state: Tnormestimatorstate; out  nrm: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_nrm: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_normestimatorresults(@_s_error_msg, @_d_state, @_d_nrm, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during normestimatorresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        nrm := _d_nrm;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure normestimatorresults( state: Tnormestimatorstate; out  nrm: Double; const _xparams: UInt64 = 0);
begin
    _core_normestimatorresults(state, nrm, _xparams);
end;

constructor Tlinlsqrstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tlinlsqrstate.Destroy();
begin
    Deallocate();
end;

function Tlinlsqrstate.Clone():Tlinlsqrstate;
begin
    if ptr=nil then
        Result:=Tlinlsqrstate.Create(nil)
    else
        Result:=Tlinlsqrstate.Create(x_obj_copy_linlsqrstate(ptr));
end;

procedure Tlinlsqrstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_linlsqrstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tlinlsqrreport):Tlinlsqrreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nmv := src.nmv;
    Result.terminationtype := src.terminationtype;
end;

procedure x_linlsqrreport_init(var x: x_linlsqrreport);
begin
    x.iterationscount.longval := 0;
    x.nmv.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_linlsqrreport_clear(var x: x_linlsqrreport);
begin
end;

procedure x_linlsqrreport_init_from(var x: x_linlsqrreport; const v: Tlinlsqrreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nmv.longval := v.nmv;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_linlsqrreport_to_record(const x: x_linlsqrreport; var v: Tlinlsqrreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nmv := x.nmv.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_linlsqrcreate( m: TALGLIBInteger;  n: TALGLIBInteger; out  state: Tlinlsqrstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_linlsqrcreate(@_s_error_msg, @_d_m, @_d_n, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrcreate call');
        end;
        state := Tlinlsqrstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_linlsqrstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure linlsqrcreate( m: TALGLIBInteger;  n: TALGLIBInteger; out  state: Tlinlsqrstate; const _xparams: UInt64 = 0);
begin
    _core_linlsqrcreate(m, n, state, _xparams);
end;


procedure _core_linlsqrcreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  state: Tlinlsqrstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _d_n := n;
        _d_state := state.ptr;
        _error_code := x_xv2_linlsqrcreatebuf(@_s_error_msg, @_d_m, @_d_n, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrcreatebuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure linlsqrcreatebuf( m: TALGLIBInteger;  n: TALGLIBInteger;  state: Tlinlsqrstate; const _xparams: UInt64 = 0);
begin
    _core_linlsqrcreatebuf(m, n, state, _xparams);
end;


procedure _core_linlsqrsetprecunit( state: Tlinlsqrstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_linlsqrsetprecunit(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrsetprecunit call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure linlsqrsetprecunit( state: Tlinlsqrstate; const _xparams: UInt64 = 0);
begin
    _core_linlsqrsetprecunit(state, _xparams);
end;


procedure _core_linlsqrsetprecdiag( state: Tlinlsqrstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_linlsqrsetprecdiag(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrsetprecdiag call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure linlsqrsetprecdiag( state: Tlinlsqrstate; const _xparams: UInt64 = 0);
begin
    _core_linlsqrsetprecdiag(state, _xparams);
end;


procedure _core_linlsqrsetlambdai( state: Tlinlsqrstate;  lambdai: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_lambdai: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_lambdai := lambdai;
        _error_code := x_xv2_linlsqrsetlambdai(@_s_error_msg, @_d_state, @_d_lambdai, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrsetlambdai call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure linlsqrsetlambdai( state: Tlinlsqrstate;  lambdai: Double; const _xparams: UInt64 = 0);
begin
    _core_linlsqrsetlambdai(state, lambdai, _xparams);
end;


procedure _core_linlsqrsolvesparse( state: Tlinlsqrstate;  a: Tsparsematrix;  b: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a : Pointer;
    _d_b: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_a := a.ptr;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_linlsqrsolvesparse(@_s_error_msg, @_d_state, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrsolvesparse call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_b);
    end;
end;


procedure linlsqrsolvesparse( state: Tlinlsqrstate;  a: Tsparsematrix;  b: TVector; const _xparams: UInt64 = 0);
begin
    _core_linlsqrsolvesparse(state, a, b, _xparams);
end;


procedure _core_linlsqrsetcond( state: Tlinlsqrstate;  epsa: Double;  epsb: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsa: Double;
    _d_epsb: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsa := epsa;
        _d_epsb := epsb;
        _d_maxits := maxits;
        _error_code := x_xv2_linlsqrsetcond(@_s_error_msg, @_d_state, @_d_epsa, @_d_epsb, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure linlsqrsetcond( state: Tlinlsqrstate;  epsa: Double;  epsb: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_linlsqrsetcond(state, epsa, epsb, maxits, _xparams);
end;


procedure _core_linlsqrresults( state: Tlinlsqrstate; out  x: TVector; out  rep: Tlinlsqrreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_linlsqrreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_linlsqrreport_init(_d_rep);
        _error_code := x_xv2_linlsqrresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_linlsqrreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_linlsqrreport_clear(_d_rep);
    end;
end;


procedure linlsqrresults( state: Tlinlsqrstate; out  x: TVector; out  rep: Tlinlsqrreport; const _xparams: UInt64 = 0);
begin
    _core_linlsqrresults(state, x, rep, _xparams);
end;


procedure _core_linlsqrsetxrep( state: Tlinlsqrstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_linlsqrsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure linlsqrsetxrep( state: Tlinlsqrstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_linlsqrsetxrep(state, needxrep, _xparams);
end;


function _core_linlsqrpeekiterationscount( s: Tlinlsqrstate; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_linlsqrpeekiterationscount(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrpeekiterationscount call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function linlsqrpeekiterationscount( s: Tlinlsqrstate; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_linlsqrpeekiterationscount(s, _xparams);
end;


procedure _core_linlsqrrequesttermination( state: Tlinlsqrstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_linlsqrrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during linlsqrrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure linlsqrrequesttermination( state: Tlinlsqrstate; const _xparams: UInt64 = 0);
begin
    _core_linlsqrrequesttermination(state, _xparams);
end;

constructor Tminbleicstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminbleicstate.Destroy();
begin
    Deallocate();
end;

function Tminbleicstate.Clone():Tminbleicstate;
begin
    if ptr=nil then
        Result:=Tminbleicstate.Create(nil)
    else
        Result:=Tminbleicstate.Create(x_obj_copy_minbleicstate(ptr));
end;

procedure Tminbleicstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minbleicstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminbleicreport):Tminbleicreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfev := src.nfev;
    Result.varidx := src.varidx;
    Result.terminationtype := src.terminationtype;
    Result.debugeqerr := src.debugeqerr;
    Result.debugfs := src.debugfs;
    Result.debugff := src.debugff;
    Result.debugdx := src.debugdx;
    Result.debugfeasqpits := src.debugfeasqpits;
    Result.debugfeasgpaits := src.debugfeasgpaits;
    Result.inneriterationscount := src.inneriterationscount;
    Result.outeriterationscount := src.outeriterationscount;
end;

procedure x_minbleicreport_init(var x: x_minbleicreport);
begin
    x.iterationscount.longval := 0;
    x.nfev.longval := 0;
    x.varidx.longval := 0;
    x.terminationtype.longval := 0;
    x.debugeqerr := 0;
    x.debugfs := 0;
    x.debugff := 0;
    x.debugdx := 0;
    x.debugfeasqpits.longval := 0;
    x.debugfeasgpaits.longval := 0;
    x.inneriterationscount.longval := 0;
    x.outeriterationscount.longval := 0;
end;

procedure x_minbleicreport_clear(var x: x_minbleicreport);
begin
end;

procedure x_minbleicreport_init_from(var x: x_minbleicreport; const v: Tminbleicreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfev.longval := v.nfev;
    x.varidx.longval := v.varidx;
    x.terminationtype.longval := v.terminationtype;
    x.debugeqerr := v.debugeqerr;
    x.debugfs := v.debugfs;
    x.debugff := v.debugff;
    x.debugdx := v.debugdx;
    x.debugfeasqpits.longval := v.debugfeasqpits;
    x.debugfeasgpaits.longval := v.debugfeasgpaits;
    x.inneriterationscount.longval := v.inneriterationscount;
    x.outeriterationscount.longval := v.outeriterationscount;
end;

procedure x_minbleicreport_to_record(const x: x_minbleicreport; var v: Tminbleicreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.varidx := x.varidx.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.debugeqerr := x.debugeqerr;
    v.debugfs := x.debugfs;
    v.debugff := x.debugff;
    v.debugdx := x.debugdx;
    v.debugfeasqpits := x.debugfeasqpits.val; // long is silently truncated to TALGLIBInteger
    v.debugfeasgpaits := x.debugfeasgpaits.val; // long is silently truncated to TALGLIBInteger
    v.inneriterationscount := x.inneriterationscount.val; // long is silently truncated to TALGLIBInteger
    v.outeriterationscount := x.outeriterationscount.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minbleiccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminbleicstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minbleiccreate(@_s_error_msg, @_d_n, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleiccreate call');
        end;
        state := Tminbleicstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minbleicstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minbleiccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minbleiccreate(n, x, state, _xparams);
end;


procedure minbleiccreate( x: TVector; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minbleiccreate(n, x, state, _xparams);

end;


procedure _core_minbleiccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminbleicstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minbleiccreatef(@_s_error_msg, @_d_n, @_d_x, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleiccreatef call');
        end;
        state := Tminbleicstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minbleicstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minbleiccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minbleiccreatef(n, x, diffstep, state, _xparams);
end;


procedure minbleiccreatef( x: TVector;  diffstep: Double; out  state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minbleiccreatef(n, x, diffstep, state, _xparams);

end;


procedure _core_minbleicsetbc( state: Tminbleicstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minbleicsetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minbleicsetbc( state: Tminbleicstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetbc(state, bndl, bndu, _xparams);
end;


procedure _core_minbleicsetlc( state: Tminbleicstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minbleicsetlc(@_s_error_msg, @_d_state, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_clear(_d_ct);
    end;
end;


procedure minbleicsetlc( state: Tminbleicstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minbleicsetlc(state, c, ct, k, _xparams);
end;


procedure minbleicsetlc( state: Tminbleicstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(c)<>xlen(ct))) then
    raise Exception.Create('Error while calling minbleicsetlc: looks like one of arguments has wrong size');

    k := xrows(c);

    _core_minbleicsetlc(state, c, ct, k, _xparams);

end;


procedure _core_minbleicsetcond( state: Tminbleicstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsg: Double;
    _d_epsf: Double;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsg := epsg;
        _d_epsf := epsf;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minbleicsetcond(@_s_error_msg, @_d_state, @_d_epsg, @_d_epsf, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicsetcond( state: Tminbleicstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetcond(state, epsg, epsf, epsx, maxits, _xparams);
end;


procedure _core_minbleicsetscale( state: Tminbleicstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minbleicsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minbleicsetscale( state: Tminbleicstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetscale(state, s, _xparams);
end;


procedure _core_minbleicsetprecdefault( state: Tminbleicstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbleicsetprecdefault(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetprecdefault call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicsetprecdefault( state: Tminbleicstate; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetprecdefault(state, _xparams);
end;


procedure _core_minbleicsetprecdiag( state: Tminbleicstate;  d: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_d: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_d, d, X_CREATE);
        _error_code := x_xv2_minbleicsetprecdiag(@_s_error_msg, @_d_state, @_d_d, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetprecdiag call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
    end;
end;


procedure minbleicsetprecdiag( state: Tminbleicstate;  d: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetprecdiag(state, d, _xparams);
end;


procedure _core_minbleicsetprecscale( state: Tminbleicstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbleicsetprecscale(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetprecscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicsetprecscale( state: Tminbleicstate; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetprecscale(state, _xparams);
end;


procedure _core_minbleicsetxrep( state: Tminbleicstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_minbleicsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicsetxrep( state: Tminbleicstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetxrep(state, needxrep, _xparams);
end;


procedure _core_minbleicsetstpmax( state: Tminbleicstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_minbleicsetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicsetstpmax( state: Tminbleicstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetstpmax(state, stpmax, _xparams);
end;


function _core_minbleiciteration( state: Tminbleicstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbleiciteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleiciteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function minbleiciteration( state: Tminbleicstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_minbleiciteration(state, _xparams);
end;

procedure minbleicoptimize(state: Tminbleicstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_needf: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in minbleicoptimize() (func is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_minbleicstate_get_x(_state, @_xc_arg);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minbleiciteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleiciteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minbleicstate_get_xupdated(_state, @_xc_xupdated);
        x_minbleicstate_get_needf(_state, @_xc_needf);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_minbleicstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minbleicstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minbleicoptimize (some derivatives were not provided?)');
    end;
end;
procedure minbleicoptimize(state: Tminbleicstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_needfg: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in minbleicoptimize() (grad is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_minbleicstate_get_x(_state, @_xc_arg);
    x_minbleicstate_get_g(_state, @_xc_g);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minbleiciteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleiciteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minbleicstate_get_xupdated(_state, @_xc_xupdated);
        x_minbleicstate_get_needfg(_state, @_xc_needfg);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_f, _pas_g, obj);
            x_minbleicstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minbleicstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minbleicoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_minbleicoptguardgradient( state: Tminbleicstate;  teststep: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_teststep: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_teststep := teststep;
        _error_code := x_xv2_minbleicoptguardgradient(@_s_error_msg, @_d_state, @_d_teststep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicoptguardgradient call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicoptguardgradient( state: Tminbleicstate;  teststep: Double; const _xparams: UInt64 = 0);
begin
    _core_minbleicoptguardgradient(state, teststep, _xparams);
end;


procedure _core_minbleicoptguardsmoothness( state: Tminbleicstate;  level: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_level: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_level := level;
        _error_code := x_xv2_minbleicoptguardsmoothness(@_s_error_msg, @_d_state, @_d_level, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicoptguardsmoothness call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicoptguardsmoothness( state: Tminbleicstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minbleicoptguardsmoothness(state, level, _xparams);
end;


procedure minbleicoptguardsmoothness( state: Tminbleicstate; const _xparams: UInt64 = 0);overload;
var
    level: TALGLIBInteger;

begin

    level := 1;

    _core_minbleicoptguardsmoothness(state, level, _xparams);

end;


procedure _core_minbleicoptguardresults( state: Tminbleicstate; out  rep: Toptguardreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_rep: x_optguardreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardreport_init(_d_rep);
        _error_code := x_xv2_minbleicoptguardresults(@_s_error_msg, @_d_state, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicoptguardresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardreport_clear(_d_rep);
    end;
end;


procedure minbleicoptguardresults( state: Tminbleicstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
begin
    _core_minbleicoptguardresults(state, rep, _xparams);
end;


procedure _core_minbleicoptguardnonc1test0results( state: Tminbleicstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test0report;
    _d_lngrep: x_optguardnonc1test0report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test0report_init(_d_strrep);
        x_optguardnonc1test0report_init(_d_lngrep);
        _error_code := x_xv2_minbleicoptguardnonc1test0results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicoptguardnonc1test0results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test0report_to_record(_d_strrep, strrep);
        x_optguardnonc1test0report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test0report_clear(_d_strrep);
        x_optguardnonc1test0report_clear(_d_lngrep);
    end;
end;


procedure minbleicoptguardnonc1test0results( state: Tminbleicstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
begin
    _core_minbleicoptguardnonc1test0results(state, strrep, lngrep, _xparams);
end;


procedure _core_minbleicoptguardnonc1test1results( state: Tminbleicstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test1report;
    _d_lngrep: x_optguardnonc1test1report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test1report_init(_d_strrep);
        x_optguardnonc1test1report_init(_d_lngrep);
        _error_code := x_xv2_minbleicoptguardnonc1test1results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicoptguardnonc1test1results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test1report_to_record(_d_strrep, strrep);
        x_optguardnonc1test1report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test1report_clear(_d_strrep);
        x_optguardnonc1test1report_clear(_d_lngrep);
    end;
end;


procedure minbleicoptguardnonc1test1results( state: Tminbleicstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
begin
    _core_minbleicoptguardnonc1test1results(state, strrep, lngrep, _xparams);
end;


procedure _core_minbleicresults( state: Tminbleicstate; out  x: TVector; out  rep: Tminbleicreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minbleicreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minbleicreport_init(_d_rep);
        _error_code := x_xv2_minbleicresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minbleicreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minbleicreport_clear(_d_rep);
    end;
end;


procedure minbleicresults( state: Tminbleicstate; out  x: TVector; out  rep: Tminbleicreport; const _xparams: UInt64 = 0);
begin
    _core_minbleicresults(state, x, rep, _xparams);
end;


procedure _core_minbleicresultsbuf( state: Tminbleicstate; var  x: TVector;  rep: Tminbleicreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minbleicreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minbleicreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minbleicresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minbleicreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minbleicreport_clear(_d_rep);
    end;
end;


procedure minbleicresultsbuf( state: Tminbleicstate; var  x: TVector;  rep: Tminbleicreport; const _xparams: UInt64 = 0);
begin
    _core_minbleicresultsbuf(state, x, rep, _xparams);
end;


procedure _core_minbleicrestartfrom( state: Tminbleicstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_minbleicrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure minbleicrestartfrom( state: Tminbleicstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbleicrestartfrom(state, x, _xparams);
end;


procedure _core_minbleicrequesttermination( state: Tminbleicstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbleicrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicrequesttermination( state: Tminbleicstate; const _xparams: UInt64 = 0);
begin
    _core_minbleicrequesttermination(state, _xparams);
end;

constructor Tminqpstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminqpstate.Destroy();
begin
    Deallocate();
end;

function Tminqpstate.Clone():Tminqpstate;
begin
    if ptr=nil then
        Result:=Tminqpstate.Create(nil)
    else
        Result:=Tminqpstate.Create(x_obj_copy_minqpstate(ptr));
end;

procedure Tminqpstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minqpstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminqpreport):Tminqpreport;overload;
begin
    Result.inneriterationscount := src.inneriterationscount;
    Result.outeriterationscount := src.outeriterationscount;
    Result.nmv := src.nmv;
    Result.ncholesky := src.ncholesky;
    Result.terminationtype := src.terminationtype;
    Result.lagbc := Clone(src.lagbc);
    Result.laglc := Clone(src.laglc);
end;

procedure x_minqpreport_init(var x: x_minqpreport);
begin
    x.inneriterationscount.longval := 0;
    x.outeriterationscount.longval := 0;
    x.nmv.longval := 0;
    x.ncholesky.longval := 0;
    x.terminationtype.longval := 0;
    x_create_empty(x.lagbc, DT_REAL);
    x_create_empty(x.laglc, DT_REAL);
end;

procedure x_minqpreport_clear(var x: x_minqpreport);
begin
    x_clear(x.lagbc);
    x_clear(x.laglc);
end;

procedure x_minqpreport_init_from(var x: x_minqpreport; const v: Tminqpreport);
begin
    x.inneriterationscount.longval := v.inneriterationscount;
    x.outeriterationscount.longval := v.outeriterationscount;
    x.nmv.longval := v.nmv;
    x.ncholesky.longval := v.ncholesky;
    x.terminationtype.longval := v.terminationtype;
    x_from_array(x.lagbc, v.lagbc, X_CREATE);
    x_from_array(x.laglc, v.laglc, X_CREATE);
end;

procedure x_minqpreport_to_record(const x: x_minqpreport; var v: Tminqpreport);
begin
    v.inneriterationscount := x.inneriterationscount.val; // long is silently truncated to TALGLIBInteger
    v.outeriterationscount := x.outeriterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nmv := x.nmv.val; // long is silently truncated to TALGLIBInteger
    v.ncholesky := x.ncholesky.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.lagbc, v.lagbc);
    x_to_array(x.laglc, v.laglc);
end;


procedure _core_minqpcreate( n: TALGLIBInteger; out  state: Tminqpstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minqpcreate(@_s_error_msg, @_d_n, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpcreate call');
        end;
        state := Tminqpstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minqpstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minqpcreate( n: TALGLIBInteger; out  state: Tminqpstate; const _xparams: UInt64 = 0);
begin
    _core_minqpcreate(n, state, _xparams);
end;


procedure _core_minqpsetlinearterm( state: Tminqpstate;  b: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_b: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_minqpsetlinearterm(@_s_error_msg, @_d_state, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlinearterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_b);
    end;
end;


procedure minqpsetlinearterm( state: Tminqpstate;  b: TVector; const _xparams: UInt64 = 0);
begin
    _core_minqpsetlinearterm(state, b, _xparams);
end;


procedure _core_minqpsetquadraticterm( state: Tminqpstate;  a: TMatrix;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a: x_matrix;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_minqpsetquadraticterm(@_s_error_msg, @_d_state, @_d_a, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetquadraticterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure minqpsetquadraticterm( state: Tminqpstate;  a: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);overload;
begin
    _core_minqpsetquadraticterm(state, a, isupper, _xparams);
end;


procedure minqpsetquadraticterm( state: Tminqpstate;  a: TMatrix; const _xparams: UInt64 = 0);overload;
var
    isupper: Boolean;

begin
    if not xissymmetric(a) then
        raise Exception.Create('a parameter is not symmetric matrix');

    isupper := False;

    _core_minqpsetquadraticterm(state, a, isupper, _xparams);

end;


procedure _core_minqpsetquadratictermsparse( state: Tminqpstate;  a: Tsparsematrix;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a : Pointer;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_a := a.ptr;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_minqpsetquadratictermsparse(@_s_error_msg, @_d_state, @_d_a, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetquadratictermsparse call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetquadratictermsparse( state: Tminqpstate;  a: Tsparsematrix;  isupper: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minqpsetquadratictermsparse(state, a, isupper, _xparams);
end;


procedure _core_minqpsetstartingpoint( state: Tminqpstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_minqpsetstartingpoint(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetstartingpoint call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure minqpsetstartingpoint( state: Tminqpstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_minqpsetstartingpoint(state, x, _xparams);
end;


procedure _core_minqpsetorigin( state: Tminqpstate;  xorigin: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_xorigin: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_xorigin, xorigin, X_CREATE);
        _error_code := x_xv2_minqpsetorigin(@_s_error_msg, @_d_state, @_d_xorigin, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetorigin call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xorigin);
    end;
end;


procedure minqpsetorigin( state: Tminqpstate;  xorigin: TVector; const _xparams: UInt64 = 0);
begin
    _core_minqpsetorigin(state, xorigin, _xparams);
end;


procedure _core_minqpsetscale( state: Tminqpstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minqpsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minqpsetscale( state: Tminqpstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minqpsetscale(state, s, _xparams);
end;


procedure _core_minqpsetscaleautodiag( state: Tminqpstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minqpsetscaleautodiag(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetscaleautodiag call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetscaleautodiag( state: Tminqpstate; const _xparams: UInt64 = 0);
begin
    _core_minqpsetscaleautodiag(state, _xparams);
end;


procedure _core_minqpsetalgobleic( state: Tminqpstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsg: Double;
    _d_epsf: Double;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsg := epsg;
        _d_epsf := epsf;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minqpsetalgobleic(@_s_error_msg, @_d_state, @_d_epsg, @_d_epsf, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetalgobleic call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetalgobleic( state: Tminqpstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minqpsetalgobleic(state, epsg, epsf, epsx, maxits, _xparams);
end;


procedure _core_minqpsetalgodenseaul( state: Tminqpstate;  epsx: Double;  rho: Double;  itscnt: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsx: Double;
    _d_rho: Double;
    _d_itscnt: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsx := epsx;
        _d_rho := rho;
        _d_itscnt := itscnt;
        _error_code := x_xv2_minqpsetalgodenseaul(@_s_error_msg, @_d_state, @_d_epsx, @_d_rho, @_d_itscnt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetalgodenseaul call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetalgodenseaul( state: Tminqpstate;  epsx: Double;  rho: Double;  itscnt: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minqpsetalgodenseaul(state, epsx, rho, itscnt, _xparams);
end;


procedure _core_minqpsetalgodenseipm( state: Tminqpstate;  eps: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_eps: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_eps := eps;
        _error_code := x_xv2_minqpsetalgodenseipm(@_s_error_msg, @_d_state, @_d_eps, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetalgodenseipm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetalgodenseipm( state: Tminqpstate;  eps: Double; const _xparams: UInt64 = 0);
begin
    _core_minqpsetalgodenseipm(state, eps, _xparams);
end;


procedure _core_minqpsetalgosparseipm( state: Tminqpstate;  eps: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_eps: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_eps := eps;
        _error_code := x_xv2_minqpsetalgosparseipm(@_s_error_msg, @_d_state, @_d_eps, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetalgosparseipm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetalgosparseipm( state: Tminqpstate;  eps: Double; const _xparams: UInt64 = 0);
begin
    _core_minqpsetalgosparseipm(state, eps, _xparams);
end;


procedure _core_minqpsetalgoquickqp( state: Tminqpstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxouterits: TALGLIBInteger;  usenewton: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsg: Double;
    _d_epsf: Double;
    _d_epsx: Double;
    _d_maxouterits: NativeInt;
    _d_usenewton: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsg := epsg;
        _d_epsf := epsf;
        _d_epsx := epsx;
        _d_maxouterits := maxouterits;
        _d_usenewton := Bool2Byte(usenewton);
        _error_code := x_xv2_minqpsetalgoquickqp(@_s_error_msg, @_d_state, @_d_epsg, @_d_epsf, @_d_epsx, @_d_maxouterits, @_d_usenewton, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetalgoquickqp call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetalgoquickqp( state: Tminqpstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxouterits: TALGLIBInteger;  usenewton: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minqpsetalgoquickqp(state, epsg, epsf, epsx, maxouterits, usenewton, _xparams);
end;


procedure _core_minqpsetbc( state: Tminqpstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minqpsetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minqpsetbc( state: Tminqpstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minqpsetbc(state, bndl, bndu, _xparams);
end;


procedure _core_minqpsetbcall( state: Tminqpstate;  bndl: Double;  bndu: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: Double;
    _d_bndu: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_bndl := bndl;
        _d_bndu := bndu;
        _error_code := x_xv2_minqpsetbcall(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetbcall call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetbcall( state: Tminqpstate;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
begin
    _core_minqpsetbcall(state, bndl, bndu, _xparams);
end;


procedure _core_minqpsetbci( state: Tminqpstate;  i: TALGLIBInteger;  bndl: Double;  bndu: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_i: NativeInt;
    _d_bndl: Double;
    _d_bndu: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_i := i;
        _d_bndl := bndl;
        _d_bndu := bndu;
        _error_code := x_xv2_minqpsetbci(@_s_error_msg, @_d_state, @_d_i, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetbci call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpsetbci( state: Tminqpstate;  i: TALGLIBInteger;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
begin
    _core_minqpsetbci(state, i, bndl, bndu, _xparams);
end;


procedure _core_minqpsetlc( state: Tminqpstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minqpsetlc(@_s_error_msg, @_d_state, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_clear(_d_ct);
    end;
end;


procedure minqpsetlc( state: Tminqpstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minqpsetlc(state, c, ct, k, _xparams);
end;


procedure minqpsetlc( state: Tminqpstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(c)<>xlen(ct))) then
    raise Exception.Create('Error while calling minqpsetlc: looks like one of arguments has wrong size');

    k := xrows(c);

    _core_minqpsetlc(state, c, ct, k, _xparams);

end;


procedure _core_minqpsetlcsparse( state: Tminqpstate;  c: Tsparsematrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c : Pointer;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_c := c.ptr;
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minqpsetlcsparse(@_s_error_msg, @_d_state, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlcsparse call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_ct);
    end;
end;


procedure minqpsetlcsparse( state: Tminqpstate;  c: Tsparsematrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minqpsetlcsparse(state, c, ct, k, _xparams);
end;


procedure _core_minqpsetlcmixed( state: Tminqpstate;  sparsec: Tsparsematrix;  sparsect: TIVector;  sparsek: TALGLIBInteger;  densec: TMatrix;  densect: TIVector;  densek: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_sparsec : Pointer;
    _d_sparsect: x_vector;
    _d_sparsek: NativeInt;
    _d_densec: x_matrix;
    _d_densect: x_vector;
    _d_densek: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_sparsec := sparsec.ptr;
        x_from_array(_d_sparsect, sparsect, X_CREATE);
        _d_sparsek := sparsek;
        x_from_array(_d_densec, densec, X_CREATE);
        x_from_array(_d_densect, densect, X_CREATE);
        _d_densek := densek;
        _error_code := x_xv2_minqpsetlcmixed(@_s_error_msg, @_d_state, @_d_sparsec, @_d_sparsect, @_d_sparsek, @_d_densec, @_d_densect, @_d_densek, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlcmixed call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(sparsec.ptr=_d_sparsec, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_sparsect);
        x_clear(_d_densec);
        x_clear(_d_densect);
    end;
end;


procedure minqpsetlcmixed( state: Tminqpstate;  sparsec: Tsparsematrix;  sparsect: TIVector;  sparsek: TALGLIBInteger;  densec: TMatrix;  densect: TIVector;  densek: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minqpsetlcmixed(state, sparsec, sparsect, sparsek, densec, densect, densek, _xparams);
end;


procedure _core_minqpsetlcmixedlegacy( state: Tminqpstate;  densec: TMatrix;  densect: TIVector;  densek: TALGLIBInteger;  sparsec: Tsparsematrix;  sparsect: TIVector;  sparsek: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_densec: x_matrix;
    _d_densect: x_vector;
    _d_densek: NativeInt;
    _d_sparsec : Pointer;
    _d_sparsect: x_vector;
    _d_sparsek: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_densec, densec, X_CREATE);
        x_from_array(_d_densect, densect, X_CREATE);
        _d_densek := densek;
        _d_sparsec := sparsec.ptr;
        x_from_array(_d_sparsect, sparsect, X_CREATE);
        _d_sparsek := sparsek;
        _error_code := x_xv2_minqpsetlcmixedlegacy(@_s_error_msg, @_d_state, @_d_densec, @_d_densect, @_d_densek, @_d_sparsec, @_d_sparsect, @_d_sparsek, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlcmixedlegacy call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(sparsec.ptr=_d_sparsec, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_densec);
        x_clear(_d_densect);
        x_clear(_d_sparsect);
    end;
end;


procedure minqpsetlcmixedlegacy( state: Tminqpstate;  densec: TMatrix;  densect: TIVector;  densek: TALGLIBInteger;  sparsec: Tsparsematrix;  sparsect: TIVector;  sparsek: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minqpsetlcmixedlegacy(state, densec, densect, densek, sparsec, sparsect, sparsek, _xparams);
end;


procedure _core_minqpsetlc2dense( state: Tminqpstate;  a: TMatrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a: x_matrix;
    _d_al: x_vector;
    _d_au: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_al, al, X_CREATE);
        x_from_array(_d_au, au, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minqpsetlc2dense(@_s_error_msg, @_d_state, @_d_a, @_d_al, @_d_au, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlc2dense call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_al);
        x_clear(_d_au);
    end;
end;


procedure minqpsetlc2dense( state: Tminqpstate;  a: TMatrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minqpsetlc2dense(state, a, al, au, k, _xparams);
end;


procedure minqpsetlc2dense( state: Tminqpstate;  a: TMatrix;  al: TVector;  au: TVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(a)<>xlen(al))) or ((xrows(a)<>xlen(au))) then
    raise Exception.Create('Error while calling minqpsetlc2dense: looks like one of arguments has wrong size');

    k := xrows(a);

    _core_minqpsetlc2dense(state, a, al, au, k, _xparams);

end;


procedure _core_minqpsetlc2( state: Tminqpstate;  a: Tsparsematrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a : Pointer;
    _d_al: x_vector;
    _d_au: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_a := a.ptr;
        x_from_array(_d_al, al, X_CREATE);
        x_from_array(_d_au, au, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minqpsetlc2(@_s_error_msg, @_d_state, @_d_a, @_d_al, @_d_au, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlc2 call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_al);
        x_clear(_d_au);
    end;
end;


procedure minqpsetlc2( state: Tminqpstate;  a: Tsparsematrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minqpsetlc2(state, a, al, au, k, _xparams);
end;


procedure _core_minqpsetlc2mixed( state: Tminqpstate;  sparsea: Tsparsematrix;  ksparse: TALGLIBInteger;  densea: TMatrix;  kdense: TALGLIBInteger;  al: TVector;  au: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_sparsea : Pointer;
    _d_ksparse: NativeInt;
    _d_densea: x_matrix;
    _d_kdense: NativeInt;
    _d_al: x_vector;
    _d_au: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_sparsea := sparsea.ptr;
        _d_ksparse := ksparse;
        x_from_array(_d_densea, densea, X_CREATE);
        _d_kdense := kdense;
        x_from_array(_d_al, al, X_CREATE);
        x_from_array(_d_au, au, X_CREATE);
        _error_code := x_xv2_minqpsetlc2mixed(@_s_error_msg, @_d_state, @_d_sparsea, @_d_ksparse, @_d_densea, @_d_kdense, @_d_al, @_d_au, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpsetlc2mixed call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(sparsea.ptr=_d_sparsea, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_densea);
        x_clear(_d_al);
        x_clear(_d_au);
    end;
end;


procedure minqpsetlc2mixed( state: Tminqpstate;  sparsea: Tsparsematrix;  ksparse: TALGLIBInteger;  densea: TMatrix;  kdense: TALGLIBInteger;  al: TVector;  au: TVector; const _xparams: UInt64 = 0);
begin
    _core_minqpsetlc2mixed(state, sparsea, ksparse, densea, kdense, al, au, _xparams);
end;


procedure _core_minqpaddlc2dense( state: Tminqpstate;  a: TVector;  al: Double;  au: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a: x_vector;
    _d_al: Double;
    _d_au: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_al := al;
        _d_au := au;
        _error_code := x_xv2_minqpaddlc2dense(@_s_error_msg, @_d_state, @_d_a, @_d_al, @_d_au, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpaddlc2dense call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure minqpaddlc2dense( state: Tminqpstate;  a: TVector;  al: Double;  au: Double; const _xparams: UInt64 = 0);
begin
    _core_minqpaddlc2dense(state, a, al, au, _xparams);
end;


procedure _core_minqpaddlc2( state: Tminqpstate;  idxa: TIVector;  vala: TVector;  nnz: TALGLIBInteger;  al: Double;  au: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_idxa: x_vector;
    _d_vala: x_vector;
    _d_nnz: NativeInt;
    _d_al: Double;
    _d_au: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_idxa, idxa, X_CREATE);
        x_from_array(_d_vala, vala, X_CREATE);
        _d_nnz := nnz;
        _d_al := al;
        _d_au := au;
        _error_code := x_xv2_minqpaddlc2(@_s_error_msg, @_d_state, @_d_idxa, @_d_vala, @_d_nnz, @_d_al, @_d_au, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpaddlc2 call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_idxa);
        x_clear(_d_vala);
    end;
end;


procedure minqpaddlc2( state: Tminqpstate;  idxa: TIVector;  vala: TVector;  nnz: TALGLIBInteger;  al: Double;  au: Double; const _xparams: UInt64 = 0);
begin
    _core_minqpaddlc2(state, idxa, vala, nnz, al, au, _xparams);
end;


procedure _core_minqpoptimize( state: Tminqpstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minqpoptimize(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpoptimize call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minqpoptimize( state: Tminqpstate; const _xparams: UInt64 = 0);
begin
    _core_minqpoptimize(state, _xparams);
end;


procedure _core_minqpresults( state: Tminqpstate; out  x: TVector; out  rep: Tminqpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minqpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minqpreport_init(_d_rep);
        _error_code := x_xv2_minqpresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minqpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minqpreport_clear(_d_rep);
    end;
end;


procedure minqpresults( state: Tminqpstate; out  x: TVector; out  rep: Tminqpreport; const _xparams: UInt64 = 0);
begin
    _core_minqpresults(state, x, rep, _xparams);
end;


procedure _core_minqpresultsbuf( state: Tminqpstate; var  x: TVector;  rep: Tminqpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minqpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minqpreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minqpresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minqpresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minqpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minqpreport_clear(_d_rep);
    end;
end;


procedure minqpresultsbuf( state: Tminqpstate; var  x: TVector;  rep: Tminqpreport; const _xparams: UInt64 = 0);
begin
    _core_minqpresultsbuf(state, x, rep, _xparams);
end;

constructor Tminlpstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminlpstate.Destroy();
begin
    Deallocate();
end;

function Tminlpstate.Clone():Tminlpstate;
begin
    if ptr=nil then
        Result:=Tminlpstate.Create(nil)
    else
        Result:=Tminlpstate.Create(x_obj_copy_minlpstate(ptr));
end;

procedure Tminlpstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minlpstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminlpreport):Tminlpreport;overload;
begin
    Result.f := src.f;
    Result.y := Clone(src.y);
    Result.stats := Clone(src.stats);
    Result.primalerror := src.primalerror;
    Result.dualerror := src.dualerror;
    Result.iterationscount := src.iterationscount;
    Result.terminationtype := src.terminationtype;
end;

procedure x_minlpreport_init(var x: x_minlpreport);
begin
    x.f := 0;
    x_create_empty(x.y, DT_REAL);
    x_create_empty(x.stats, DT_INT);
    x.primalerror := 0;
    x.dualerror := 0;
    x.iterationscount.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_minlpreport_clear(var x: x_minlpreport);
begin
    x_clear(x.y);
    x_clear(x.stats);
end;

procedure x_minlpreport_init_from(var x: x_minlpreport; const v: Tminlpreport);
begin
    x.f := v.f;
    x_from_array(x.y, v.y, X_CREATE);
    x_from_array(x.stats, v.stats, X_CREATE);
    x.primalerror := v.primalerror;
    x.dualerror := v.dualerror;
    x.iterationscount.longval := v.iterationscount;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_minlpreport_to_record(const x: x_minlpreport; var v: Tminlpreport);
begin
    v.f := x.f;
    x_to_array(x.y, v.y);
    x_to_array(x.stats, v.stats);
    v.primalerror := x.primalerror;
    v.dualerror := x.dualerror;
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minlpcreate( n: TALGLIBInteger; out  state: Tminlpstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlpcreate(@_s_error_msg, @_d_n, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpcreate call');
        end;
        state := Tminlpstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlpstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlpcreate( n: TALGLIBInteger; out  state: Tminlpstate; const _xparams: UInt64 = 0);
begin
    _core_minlpcreate(n, state, _xparams);
end;


procedure _core_minlpsetcost( state: Tminlpstate;  c: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_c, c, X_CREATE);
        _error_code := x_xv2_minlpsetcost(@_s_error_msg, @_d_state, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetcost call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


procedure minlpsetcost( state: Tminlpstate;  c: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlpsetcost(state, c, _xparams);
end;


procedure _core_minlpsetscale( state: Tminlpstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minlpsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minlpsetscale( state: Tminlpstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlpsetscale(state, s, _xparams);
end;


procedure _core_minlpsetbc( state: Tminlpstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minlpsetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minlpsetbc( state: Tminlpstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlpsetbc(state, bndl, bndu, _xparams);
end;


procedure _core_minlpsetbcall( state: Tminlpstate;  bndl: Double;  bndu: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: Double;
    _d_bndu: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_bndl := bndl;
        _d_bndu := bndu;
        _error_code := x_xv2_minlpsetbcall(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetbcall call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlpsetbcall( state: Tminlpstate;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
begin
    _core_minlpsetbcall(state, bndl, bndu, _xparams);
end;


procedure _core_minlpsetbci( state: Tminlpstate;  i: TALGLIBInteger;  bndl: Double;  bndu: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_i: NativeInt;
    _d_bndl: Double;
    _d_bndu: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_i := i;
        _d_bndl := bndl;
        _d_bndu := bndu;
        _error_code := x_xv2_minlpsetbci(@_s_error_msg, @_d_state, @_d_i, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetbci call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlpsetbci( state: Tminlpstate;  i: TALGLIBInteger;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
begin
    _core_minlpsetbci(state, i, bndl, bndu, _xparams);
end;


procedure _core_minlpsetlc( state: Tminlpstate;  a: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minlpsetlc(@_s_error_msg, @_d_state, @_d_a, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_ct);
    end;
end;


procedure minlpsetlc( state: Tminlpstate;  a: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minlpsetlc(state, a, ct, k, _xparams);
end;


procedure minlpsetlc( state: Tminlpstate;  a: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(a)<>xlen(ct))) then
    raise Exception.Create('Error while calling minlpsetlc: looks like one of arguments has wrong size');

    k := xrows(a);

    _core_minlpsetlc(state, a, ct, k, _xparams);

end;


procedure _core_minlpsetlc2dense( state: Tminlpstate;  a: TMatrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a: x_matrix;
    _d_al: x_vector;
    _d_au: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_al, al, X_CREATE);
        x_from_array(_d_au, au, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minlpsetlc2dense(@_s_error_msg, @_d_state, @_d_a, @_d_al, @_d_au, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetlc2dense call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_al);
        x_clear(_d_au);
    end;
end;


procedure minlpsetlc2dense( state: Tminlpstate;  a: TMatrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minlpsetlc2dense(state, a, al, au, k, _xparams);
end;


procedure minlpsetlc2dense( state: Tminlpstate;  a: TMatrix;  al: TVector;  au: TVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(a)<>xlen(al))) or ((xrows(a)<>xlen(au))) then
    raise Exception.Create('Error while calling minlpsetlc2dense: looks like one of arguments has wrong size');

    k := xrows(a);

    _core_minlpsetlc2dense(state, a, al, au, k, _xparams);

end;


procedure _core_minlpsetlc2( state: Tminlpstate;  a: Tsparsematrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a : Pointer;
    _d_al: x_vector;
    _d_au: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_a := a.ptr;
        x_from_array(_d_al, al, X_CREATE);
        x_from_array(_d_au, au, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minlpsetlc2(@_s_error_msg, @_d_state, @_d_a, @_d_al, @_d_au, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpsetlc2 call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_al);
        x_clear(_d_au);
    end;
end;


procedure minlpsetlc2( state: Tminlpstate;  a: Tsparsematrix;  al: TVector;  au: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minlpsetlc2(state, a, al, au, k, _xparams);
end;


procedure _core_minlpaddlc2dense( state: Tminlpstate;  a: TVector;  al: Double;  au: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a: x_vector;
    _d_al: Double;
    _d_au: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_al := al;
        _d_au := au;
        _error_code := x_xv2_minlpaddlc2dense(@_s_error_msg, @_d_state, @_d_a, @_d_al, @_d_au, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpaddlc2dense call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure minlpaddlc2dense( state: Tminlpstate;  a: TVector;  al: Double;  au: Double; const _xparams: UInt64 = 0);
begin
    _core_minlpaddlc2dense(state, a, al, au, _xparams);
end;


procedure _core_minlpaddlc2( state: Tminlpstate;  idxa: TIVector;  vala: TVector;  nnz: TALGLIBInteger;  al: Double;  au: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_idxa: x_vector;
    _d_vala: x_vector;
    _d_nnz: NativeInt;
    _d_al: Double;
    _d_au: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_idxa, idxa, X_CREATE);
        x_from_array(_d_vala, vala, X_CREATE);
        _d_nnz := nnz;
        _d_al := al;
        _d_au := au;
        _error_code := x_xv2_minlpaddlc2(@_s_error_msg, @_d_state, @_d_idxa, @_d_vala, @_d_nnz, @_d_al, @_d_au, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpaddlc2 call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_idxa);
        x_clear(_d_vala);
    end;
end;


procedure minlpaddlc2( state: Tminlpstate;  idxa: TIVector;  vala: TVector;  nnz: TALGLIBInteger;  al: Double;  au: Double; const _xparams: UInt64 = 0);
begin
    _core_minlpaddlc2(state, idxa, vala, nnz, al, au, _xparams);
end;


procedure _core_minlpoptimize( state: Tminlpstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlpoptimize(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpoptimize call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlpoptimize( state: Tminlpstate; const _xparams: UInt64 = 0);
begin
    _core_minlpoptimize(state, _xparams);
end;


procedure _core_minlpresults( state: Tminlpstate; out  x: TVector; out  rep: Tminlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minlpreport_init(_d_rep);
        _error_code := x_xv2_minlpresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minlpreport_clear(_d_rep);
    end;
end;


procedure minlpresults( state: Tminlpstate; out  x: TVector; out  rep: Tminlpreport; const _xparams: UInt64 = 0);
begin
    _core_minlpresults(state, x, rep, _xparams);
end;


procedure _core_minlpresultsbuf( state: Tminlpstate; var  x: TVector;  rep: Tminlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minlpreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minlpresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlpresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minlpreport_clear(_d_rep);
    end;
end;


procedure minlpresultsbuf( state: Tminlpstate; var  x: TVector;  rep: Tminlpreport; const _xparams: UInt64 = 0);
begin
    _core_minlpresultsbuf(state, x, rep, _xparams);
end;

constructor Tminnlcstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminnlcstate.Destroy();
begin
    Deallocate();
end;

function Tminnlcstate.Clone():Tminnlcstate;
begin
    if ptr=nil then
        Result:=Tminnlcstate.Create(nil)
    else
        Result:=Tminnlcstate.Create(x_obj_copy_minnlcstate(ptr));
end;

procedure Tminnlcstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minnlcstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminnlcreport):Tminnlcreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfev := src.nfev;
    Result.terminationtype := src.terminationtype;
    Result.bcerr := src.bcerr;
    Result.bcidx := src.bcidx;
    Result.lcerr := src.lcerr;
    Result.lcidx := src.lcidx;
    Result.nlcerr := src.nlcerr;
    Result.nlcidx := src.nlcidx;
    Result.dbgphase0its := src.dbgphase0its;
end;

procedure x_minnlcreport_init(var x: x_minnlcreport);
begin
    x.iterationscount.longval := 0;
    x.nfev.longval := 0;
    x.terminationtype.longval := 0;
    x.bcerr := 0;
    x.bcidx.longval := 0;
    x.lcerr := 0;
    x.lcidx.longval := 0;
    x.nlcerr := 0;
    x.nlcidx.longval := 0;
    x.dbgphase0its.longval := 0;
end;

procedure x_minnlcreport_clear(var x: x_minnlcreport);
begin
end;

procedure x_minnlcreport_init_from(var x: x_minnlcreport; const v: Tminnlcreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfev.longval := v.nfev;
    x.terminationtype.longval := v.terminationtype;
    x.bcerr := v.bcerr;
    x.bcidx.longval := v.bcidx;
    x.lcerr := v.lcerr;
    x.lcidx.longval := v.lcidx;
    x.nlcerr := v.nlcerr;
    x.nlcidx.longval := v.nlcidx;
    x.dbgphase0its.longval := v.dbgphase0its;
end;

procedure x_minnlcreport_to_record(const x: x_minnlcreport; var v: Tminnlcreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.bcerr := x.bcerr;
    v.bcidx := x.bcidx.val; // long is silently truncated to TALGLIBInteger
    v.lcerr := x.lcerr;
    v.lcidx := x.lcidx.val; // long is silently truncated to TALGLIBInteger
    v.nlcerr := x.nlcerr;
    v.nlcidx := x.nlcidx.val; // long is silently truncated to TALGLIBInteger
    v.dbgphase0its := x.dbgphase0its.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minnlccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminnlcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minnlccreate(@_s_error_msg, @_d_n, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlccreate call');
        end;
        state := Tminnlcstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minnlcstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minnlccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minnlccreate(n, x, state, _xparams);
end;


procedure minnlccreate( x: TVector; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minnlccreate(n, x, state, _xparams);

end;


procedure _core_minnlccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminnlcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minnlccreatef(@_s_error_msg, @_d_n, @_d_x, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlccreatef call');
        end;
        state := Tminnlcstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minnlcstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minnlccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minnlccreatef(n, x, diffstep, state, _xparams);
end;


procedure minnlccreatef( x: TVector;  diffstep: Double; out  state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minnlccreatef(n, x, diffstep, state, _xparams);

end;


procedure _core_minnlcsetbc( state: Tminnlcstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minnlcsetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minnlcsetbc( state: Tminnlcstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetbc(state, bndl, bndu, _xparams);
end;


procedure _core_minnlcsetlc( state: Tminnlcstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minnlcsetlc(@_s_error_msg, @_d_state, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_clear(_d_ct);
    end;
end;


procedure minnlcsetlc( state: Tminnlcstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minnlcsetlc(state, c, ct, k, _xparams);
end;


procedure minnlcsetlc( state: Tminnlcstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(c)<>xlen(ct))) then
    raise Exception.Create('Error while calling minnlcsetlc: looks like one of arguments has wrong size');

    k := xrows(c);

    _core_minnlcsetlc(state, c, ct, k, _xparams);

end;


procedure _core_minnlcsetnlc( state: Tminnlcstate;  nlec: TALGLIBInteger;  nlic: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_nlec: NativeInt;
    _d_nlic: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_nlec := nlec;
        _d_nlic := nlic;
        _error_code := x_xv2_minnlcsetnlc(@_s_error_msg, @_d_state, @_d_nlec, @_d_nlic, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetnlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetnlc( state: Tminnlcstate;  nlec: TALGLIBInteger;  nlic: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetnlc(state, nlec, nlic, _xparams);
end;


procedure _core_minnlcsetcond( state: Tminnlcstate;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minnlcsetcond(@_s_error_msg, @_d_state, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetcond( state: Tminnlcstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetcond(state, epsx, maxits, _xparams);
end;


procedure _core_minnlcsetscale( state: Tminnlcstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minnlcsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minnlcsetscale( state: Tminnlcstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetscale(state, s, _xparams);
end;


procedure _core_minnlcsetprecinexact( state: Tminnlcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnlcsetprecinexact(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetprecinexact call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetprecinexact( state: Tminnlcstate; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetprecinexact(state, _xparams);
end;


procedure _core_minnlcsetprecexactlowrank( state: Tminnlcstate;  updatefreq: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_updatefreq: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_updatefreq := updatefreq;
        _error_code := x_xv2_minnlcsetprecexactlowrank(@_s_error_msg, @_d_state, @_d_updatefreq, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetprecexactlowrank call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetprecexactlowrank( state: Tminnlcstate;  updatefreq: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetprecexactlowrank(state, updatefreq, _xparams);
end;


procedure _core_minnlcsetprecexactrobust( state: Tminnlcstate;  updatefreq: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_updatefreq: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_updatefreq := updatefreq;
        _error_code := x_xv2_minnlcsetprecexactrobust(@_s_error_msg, @_d_state, @_d_updatefreq, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetprecexactrobust call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetprecexactrobust( state: Tminnlcstate;  updatefreq: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetprecexactrobust(state, updatefreq, _xparams);
end;


procedure _core_minnlcsetprecnone( state: Tminnlcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnlcsetprecnone(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetprecnone call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetprecnone( state: Tminnlcstate; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetprecnone(state, _xparams);
end;


procedure _core_minnlcsetstpmax( state: Tminnlcstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_minnlcsetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetstpmax( state: Tminnlcstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetstpmax(state, stpmax, _xparams);
end;


procedure _core_minnlcsetalgoaul( state: Tminnlcstate;  rho: Double;  itscnt: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_rho: Double;
    _d_itscnt: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_rho := rho;
        _d_itscnt := itscnt;
        _error_code := x_xv2_minnlcsetalgoaul(@_s_error_msg, @_d_state, @_d_rho, @_d_itscnt, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetalgoaul call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetalgoaul( state: Tminnlcstate;  rho: Double;  itscnt: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetalgoaul(state, rho, itscnt, _xparams);
end;


procedure _core_minnlcsetalgoslp( state: Tminnlcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnlcsetalgoslp(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetalgoslp call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetalgoslp( state: Tminnlcstate; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetalgoslp(state, _xparams);
end;


procedure _core_minnlcsetalgosqp( state: Tminnlcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnlcsetalgosqp(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetalgosqp call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetalgosqp( state: Tminnlcstate; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetalgosqp(state, _xparams);
end;


procedure _core_minnlcsetxrep( state: Tminnlcstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_minnlcsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcsetxrep( state: Tminnlcstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minnlcsetxrep(state, needxrep, _xparams);
end;


function _core_minnlciteration( state: Tminnlcstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnlciteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlciteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function minnlciteration( state: Tminnlcstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_minnlciteration(state, _xparams);
end;

procedure minnlcoptimize(state: Tminnlcstate; fvec: Tndimensional_fvec; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_needfi: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @fvec=nil then
        raise Exception.Create('ALGLIB: error in minnlcoptimize() (fvec is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_minnlcstate_get_x(_state, @_xc_arg);
    x_minnlcstate_get_fi(_state, @_xc_fi);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_fi, _xc_fi.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minnlciteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlciteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minnlcstate_get_xupdated(_state, @_xc_xupdated);
        x_minnlcstate_get_needfi(_state, @_xc_needfi);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfi<>0 then
        begin
            fvec(_pas_arg, _pas_fi, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minnlcstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minnlcoptimize (some derivatives were not provided?)');
    end;
end;
procedure minnlcoptimize(state: Tminnlcstate; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_j: x_matrix;
    _pas_j: TMatrix;
    _xc_needfij: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @jac=nil then
        raise Exception.Create('ALGLIB: error in minnlcoptimize() (jac is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_create_empty(_xc_j, DT_REAL);
    x_minnlcstate_get_x(_state, @_xc_arg);
    x_minnlcstate_get_fi(_state, @_xc_fi);
    x_minnlcstate_get_j(_state, @_xc_j);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_fi, _xc_fi.cnt);
    SetLength(_pas_j, _xc_j.rows, _xc_j.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minnlciteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlciteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minnlcstate_get_xupdated(_state, @_xc_xupdated);
        x_minnlcstate_get_needfij(_state, @_xc_needfij);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfij<>0 then
        begin
            jac(_pas_arg, _pas_fi, _pas_j, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            x_from_array(_xc_j,  _pas_j,  X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minnlcstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minnlcoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_minnlcoptguardgradient( state: Tminnlcstate;  teststep: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_teststep: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_teststep := teststep;
        _error_code := x_xv2_minnlcoptguardgradient(@_s_error_msg, @_d_state, @_d_teststep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcoptguardgradient call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcoptguardgradient( state: Tminnlcstate;  teststep: Double; const _xparams: UInt64 = 0);
begin
    _core_minnlcoptguardgradient(state, teststep, _xparams);
end;


procedure _core_minnlcoptguardsmoothness( state: Tminnlcstate;  level: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_level: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_level := level;
        _error_code := x_xv2_minnlcoptguardsmoothness(@_s_error_msg, @_d_state, @_d_level, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcoptguardsmoothness call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcoptguardsmoothness( state: Tminnlcstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minnlcoptguardsmoothness(state, level, _xparams);
end;


procedure minnlcoptguardsmoothness( state: Tminnlcstate; const _xparams: UInt64 = 0);overload;
var
    level: TALGLIBInteger;

begin

    level := 1;

    _core_minnlcoptguardsmoothness(state, level, _xparams);

end;


procedure _core_minnlcoptguardresults( state: Tminnlcstate; out  rep: Toptguardreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_rep: x_optguardreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardreport_init(_d_rep);
        _error_code := x_xv2_minnlcoptguardresults(@_s_error_msg, @_d_state, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcoptguardresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardreport_clear(_d_rep);
    end;
end;


procedure minnlcoptguardresults( state: Tminnlcstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
begin
    _core_minnlcoptguardresults(state, rep, _xparams);
end;


procedure _core_minnlcoptguardnonc1test0results( state: Tminnlcstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test0report;
    _d_lngrep: x_optguardnonc1test0report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test0report_init(_d_strrep);
        x_optguardnonc1test0report_init(_d_lngrep);
        _error_code := x_xv2_minnlcoptguardnonc1test0results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcoptguardnonc1test0results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test0report_to_record(_d_strrep, strrep);
        x_optguardnonc1test0report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test0report_clear(_d_strrep);
        x_optguardnonc1test0report_clear(_d_lngrep);
    end;
end;


procedure minnlcoptguardnonc1test0results( state: Tminnlcstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
begin
    _core_minnlcoptguardnonc1test0results(state, strrep, lngrep, _xparams);
end;


procedure _core_minnlcoptguardnonc1test1results( state: Tminnlcstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test1report;
    _d_lngrep: x_optguardnonc1test1report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test1report_init(_d_strrep);
        x_optguardnonc1test1report_init(_d_lngrep);
        _error_code := x_xv2_minnlcoptguardnonc1test1results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcoptguardnonc1test1results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test1report_to_record(_d_strrep, strrep);
        x_optguardnonc1test1report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test1report_clear(_d_strrep);
        x_optguardnonc1test1report_clear(_d_lngrep);
    end;
end;


procedure minnlcoptguardnonc1test1results( state: Tminnlcstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
begin
    _core_minnlcoptguardnonc1test1results(state, strrep, lngrep, _xparams);
end;


procedure _core_minnlcresults( state: Tminnlcstate; out  x: TVector; out  rep: Tminnlcreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minnlcreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minnlcreport_init(_d_rep);
        _error_code := x_xv2_minnlcresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minnlcreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minnlcreport_clear(_d_rep);
    end;
end;


procedure minnlcresults( state: Tminnlcstate; out  x: TVector; out  rep: Tminnlcreport; const _xparams: UInt64 = 0);
begin
    _core_minnlcresults(state, x, rep, _xparams);
end;


procedure _core_minnlcresultsbuf( state: Tminnlcstate; var  x: TVector;  rep: Tminnlcreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minnlcreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minnlcreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minnlcresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minnlcreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minnlcreport_clear(_d_rep);
    end;
end;


procedure minnlcresultsbuf( state: Tminnlcstate; var  x: TVector;  rep: Tminnlcreport; const _xparams: UInt64 = 0);
begin
    _core_minnlcresultsbuf(state, x, rep, _xparams);
end;


procedure _core_minnlcrequesttermination( state: Tminnlcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnlcrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnlcrequesttermination( state: Tminnlcstate; const _xparams: UInt64 = 0);
begin
    _core_minnlcrequesttermination(state, _xparams);
end;


procedure _core_minnlcrestartfrom( state: Tminnlcstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_minnlcrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnlcrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure minnlcrestartfrom( state: Tminnlcstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_minnlcrestartfrom(state, x, _xparams);
end;

constructor Tminbcstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminbcstate.Destroy();
begin
    Deallocate();
end;

function Tminbcstate.Clone():Tminbcstate;
begin
    if ptr=nil then
        Result:=Tminbcstate.Create(nil)
    else
        Result:=Tminbcstate.Create(x_obj_copy_minbcstate(ptr));
end;

procedure Tminbcstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minbcstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminbcreport):Tminbcreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfev := src.nfev;
    Result.varidx := src.varidx;
    Result.terminationtype := src.terminationtype;
end;

procedure x_minbcreport_init(var x: x_minbcreport);
begin
    x.iterationscount.longval := 0;
    x.nfev.longval := 0;
    x.varidx.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_minbcreport_clear(var x: x_minbcreport);
begin
end;

procedure x_minbcreport_init_from(var x: x_minbcreport; const v: Tminbcreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfev.longval := v.nfev;
    x.varidx.longval := v.varidx;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_minbcreport_to_record(const x: x_minbcreport; var v: Tminbcreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.varidx := x.varidx.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minbccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminbcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minbccreate(@_s_error_msg, @_d_n, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbccreate call');
        end;
        state := Tminbcstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minbcstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minbccreate( n: TALGLIBInteger;  x: TVector; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minbccreate(n, x, state, _xparams);
end;


procedure minbccreate( x: TVector; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minbccreate(n, x, state, _xparams);

end;


procedure _core_minbccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminbcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minbccreatef(@_s_error_msg, @_d_n, @_d_x, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbccreatef call');
        end;
        state := Tminbcstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minbcstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minbccreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minbccreatef(n, x, diffstep, state, _xparams);
end;


procedure minbccreatef( x: TVector;  diffstep: Double; out  state: Tminbcstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minbccreatef(n, x, diffstep, state, _xparams);

end;


procedure _core_minbcsetbc( state: Tminbcstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minbcsetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minbcsetbc( state: Tminbcstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbcsetbc(state, bndl, bndu, _xparams);
end;


procedure _core_minbcsetcond( state: Tminbcstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsg: Double;
    _d_epsf: Double;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsg := epsg;
        _d_epsf := epsf;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minbcsetcond(@_s_error_msg, @_d_state, @_d_epsg, @_d_epsf, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcsetcond( state: Tminbcstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minbcsetcond(state, epsg, epsf, epsx, maxits, _xparams);
end;


procedure _core_minbcsetscale( state: Tminbcstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minbcsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minbcsetscale( state: Tminbcstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbcsetscale(state, s, _xparams);
end;


procedure _core_minbcsetprecdefault( state: Tminbcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbcsetprecdefault(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetprecdefault call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcsetprecdefault( state: Tminbcstate; const _xparams: UInt64 = 0);
begin
    _core_minbcsetprecdefault(state, _xparams);
end;


procedure _core_minbcsetprecdiag( state: Tminbcstate;  d: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_d: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_d, d, X_CREATE);
        _error_code := x_xv2_minbcsetprecdiag(@_s_error_msg, @_d_state, @_d_d, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetprecdiag call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
    end;
end;


procedure minbcsetprecdiag( state: Tminbcstate;  d: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbcsetprecdiag(state, d, _xparams);
end;


procedure _core_minbcsetprecscale( state: Tminbcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbcsetprecscale(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetprecscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcsetprecscale( state: Tminbcstate; const _xparams: UInt64 = 0);
begin
    _core_minbcsetprecscale(state, _xparams);
end;


procedure _core_minbcsetxrep( state: Tminbcstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_minbcsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcsetxrep( state: Tminbcstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minbcsetxrep(state, needxrep, _xparams);
end;


procedure _core_minbcsetstpmax( state: Tminbcstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_minbcsetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcsetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcsetstpmax( state: Tminbcstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_minbcsetstpmax(state, stpmax, _xparams);
end;


function _core_minbciteration( state: Tminbcstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbciteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbciteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function minbciteration( state: Tminbcstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_minbciteration(state, _xparams);
end;

procedure minbcoptimize(state: Tminbcstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_needf: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in minbcoptimize() (func is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_minbcstate_get_x(_state, @_xc_arg);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minbciteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbciteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minbcstate_get_xupdated(_state, @_xc_xupdated);
        x_minbcstate_get_needf(_state, @_xc_needf);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_minbcstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minbcstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minbcoptimize (some derivatives were not provided?)');
    end;
end;
procedure minbcoptimize(state: Tminbcstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_needfg: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in minbcoptimize() (grad is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_minbcstate_get_x(_state, @_xc_arg);
    x_minbcstate_get_g(_state, @_xc_g);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minbciteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbciteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minbcstate_get_xupdated(_state, @_xc_xupdated);
        x_minbcstate_get_needfg(_state, @_xc_needfg);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_f, _pas_g, obj);
            x_minbcstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minbcstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minbcoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_minbcoptguardgradient( state: Tminbcstate;  teststep: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_teststep: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_teststep := teststep;
        _error_code := x_xv2_minbcoptguardgradient(@_s_error_msg, @_d_state, @_d_teststep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcoptguardgradient call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcoptguardgradient( state: Tminbcstate;  teststep: Double; const _xparams: UInt64 = 0);
begin
    _core_minbcoptguardgradient(state, teststep, _xparams);
end;


procedure _core_minbcoptguardsmoothness( state: Tminbcstate;  level: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_level: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_level := level;
        _error_code := x_xv2_minbcoptguardsmoothness(@_s_error_msg, @_d_state, @_d_level, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcoptguardsmoothness call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcoptguardsmoothness( state: Tminbcstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minbcoptguardsmoothness(state, level, _xparams);
end;


procedure minbcoptguardsmoothness( state: Tminbcstate; const _xparams: UInt64 = 0);overload;
var
    level: TALGLIBInteger;

begin

    level := 1;

    _core_minbcoptguardsmoothness(state, level, _xparams);

end;


procedure _core_minbcoptguardresults( state: Tminbcstate; out  rep: Toptguardreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_rep: x_optguardreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardreport_init(_d_rep);
        _error_code := x_xv2_minbcoptguardresults(@_s_error_msg, @_d_state, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcoptguardresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardreport_clear(_d_rep);
    end;
end;


procedure minbcoptguardresults( state: Tminbcstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
begin
    _core_minbcoptguardresults(state, rep, _xparams);
end;


procedure _core_minbcoptguardnonc1test0results( state: Tminbcstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test0report;
    _d_lngrep: x_optguardnonc1test0report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test0report_init(_d_strrep);
        x_optguardnonc1test0report_init(_d_lngrep);
        _error_code := x_xv2_minbcoptguardnonc1test0results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcoptguardnonc1test0results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test0report_to_record(_d_strrep, strrep);
        x_optguardnonc1test0report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test0report_clear(_d_strrep);
        x_optguardnonc1test0report_clear(_d_lngrep);
    end;
end;


procedure minbcoptguardnonc1test0results( state: Tminbcstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
begin
    _core_minbcoptguardnonc1test0results(state, strrep, lngrep, _xparams);
end;


procedure _core_minbcoptguardnonc1test1results( state: Tminbcstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test1report;
    _d_lngrep: x_optguardnonc1test1report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test1report_init(_d_strrep);
        x_optguardnonc1test1report_init(_d_lngrep);
        _error_code := x_xv2_minbcoptguardnonc1test1results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcoptguardnonc1test1results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test1report_to_record(_d_strrep, strrep);
        x_optguardnonc1test1report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test1report_clear(_d_strrep);
        x_optguardnonc1test1report_clear(_d_lngrep);
    end;
end;


procedure minbcoptguardnonc1test1results( state: Tminbcstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
begin
    _core_minbcoptguardnonc1test1results(state, strrep, lngrep, _xparams);
end;


procedure _core_minbcresults( state: Tminbcstate; out  x: TVector; out  rep: Tminbcreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minbcreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minbcreport_init(_d_rep);
        _error_code := x_xv2_minbcresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minbcreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minbcreport_clear(_d_rep);
    end;
end;


procedure minbcresults( state: Tminbcstate; out  x: TVector; out  rep: Tminbcreport; const _xparams: UInt64 = 0);
begin
    _core_minbcresults(state, x, rep, _xparams);
end;


procedure _core_minbcresultsbuf( state: Tminbcstate; var  x: TVector;  rep: Tminbcreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minbcreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minbcreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minbcresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minbcreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minbcreport_clear(_d_rep);
    end;
end;


procedure minbcresultsbuf( state: Tminbcstate; var  x: TVector;  rep: Tminbcreport; const _xparams: UInt64 = 0);
begin
    _core_minbcresultsbuf(state, x, rep, _xparams);
end;


procedure _core_minbcrestartfrom( state: Tminbcstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_minbcrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure minbcrestartfrom( state: Tminbcstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_minbcrestartfrom(state, x, _xparams);
end;


procedure _core_minbcrequesttermination( state: Tminbcstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minbcrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbcrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbcrequesttermination( state: Tminbcstate; const _xparams: UInt64 = 0);
begin
    _core_minbcrequesttermination(state, _xparams);
end;

constructor Tminnsstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminnsstate.Destroy();
begin
    Deallocate();
end;

function Tminnsstate.Clone():Tminnsstate;
begin
    if ptr=nil then
        Result:=Tminnsstate.Create(nil)
    else
        Result:=Tminnsstate.Create(x_obj_copy_minnsstate(ptr));
end;

procedure Tminnsstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minnsstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminnsreport):Tminnsreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfev := src.nfev;
    Result.cerr := src.cerr;
    Result.lcerr := src.lcerr;
    Result.nlcerr := src.nlcerr;
    Result.terminationtype := src.terminationtype;
    Result.varidx := src.varidx;
    Result.funcidx := src.funcidx;
end;

procedure x_minnsreport_init(var x: x_minnsreport);
begin
    x.iterationscount.longval := 0;
    x.nfev.longval := 0;
    x.cerr := 0;
    x.lcerr := 0;
    x.nlcerr := 0;
    x.terminationtype.longval := 0;
    x.varidx.longval := 0;
    x.funcidx.longval := 0;
end;

procedure x_minnsreport_clear(var x: x_minnsreport);
begin
end;

procedure x_minnsreport_init_from(var x: x_minnsreport; const v: Tminnsreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfev.longval := v.nfev;
    x.cerr := v.cerr;
    x.lcerr := v.lcerr;
    x.nlcerr := v.nlcerr;
    x.terminationtype.longval := v.terminationtype;
    x.varidx.longval := v.varidx;
    x.funcidx.longval := v.funcidx;
end;

procedure x_minnsreport_to_record(const x: x_minnsreport; var v: Tminnsreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.cerr := x.cerr;
    v.lcerr := x.lcerr;
    v.nlcerr := x.nlcerr;
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.varidx := x.varidx.val; // long is silently truncated to TALGLIBInteger
    v.funcidx := x.funcidx.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minnscreate( n: TALGLIBInteger;  x: TVector; out  state: Tminnsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minnscreate(@_s_error_msg, @_d_n, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnscreate call');
        end;
        state := Tminnsstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minnsstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minnscreate( n: TALGLIBInteger;  x: TVector; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minnscreate(n, x, state, _xparams);
end;


procedure minnscreate( x: TVector; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minnscreate(n, x, state, _xparams);

end;


procedure _core_minnscreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminnsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minnscreatef(@_s_error_msg, @_d_n, @_d_x, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnscreatef call');
        end;
        state := Tminnsstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minnsstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minnscreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minnscreatef(n, x, diffstep, state, _xparams);
end;


procedure minnscreatef( x: TVector;  diffstep: Double; out  state: Tminnsstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minnscreatef(n, x, diffstep, state, _xparams);

end;


procedure _core_minnssetbc( state: Tminnsstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minnssetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnssetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minnssetbc( state: Tminnsstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minnssetbc(state, bndl, bndu, _xparams);
end;


procedure _core_minnssetlc( state: Tminnsstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minnssetlc(@_s_error_msg, @_d_state, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnssetlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_clear(_d_ct);
    end;
end;


procedure minnssetlc( state: Tminnsstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minnssetlc(state, c, ct, k, _xparams);
end;


procedure minnssetlc( state: Tminnsstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(c)<>xlen(ct))) then
    raise Exception.Create('Error while calling minnssetlc: looks like one of arguments has wrong size');

    k := xrows(c);

    _core_minnssetlc(state, c, ct, k, _xparams);

end;


procedure _core_minnssetnlc( state: Tminnsstate;  nlec: TALGLIBInteger;  nlic: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_nlec: NativeInt;
    _d_nlic: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_nlec := nlec;
        _d_nlic := nlic;
        _error_code := x_xv2_minnssetnlc(@_s_error_msg, @_d_state, @_d_nlec, @_d_nlic, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnssetnlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnssetnlc( state: Tminnsstate;  nlec: TALGLIBInteger;  nlic: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minnssetnlc(state, nlec, nlic, _xparams);
end;


procedure _core_minnssetcond( state: Tminnsstate;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minnssetcond(@_s_error_msg, @_d_state, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnssetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnssetcond( state: Tminnsstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minnssetcond(state, epsx, maxits, _xparams);
end;


procedure _core_minnssetscale( state: Tminnsstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minnssetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnssetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minnssetscale( state: Tminnsstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minnssetscale(state, s, _xparams);
end;


procedure _core_minnssetalgoags( state: Tminnsstate;  radius: Double;  penalty: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_radius: Double;
    _d_penalty: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_radius := radius;
        _d_penalty := penalty;
        _error_code := x_xv2_minnssetalgoags(@_s_error_msg, @_d_state, @_d_radius, @_d_penalty, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnssetalgoags call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnssetalgoags( state: Tminnsstate;  radius: Double;  penalty: Double; const _xparams: UInt64 = 0);
begin
    _core_minnssetalgoags(state, radius, penalty, _xparams);
end;


procedure _core_minnssetxrep( state: Tminnsstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_minnssetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnssetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnssetxrep( state: Tminnsstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minnssetxrep(state, needxrep, _xparams);
end;


procedure _core_minnsrequesttermination( state: Tminnsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnsrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnsrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minnsrequesttermination( state: Tminnsstate; const _xparams: UInt64 = 0);
begin
    _core_minnsrequesttermination(state, _xparams);
end;


function _core_minnsiteration( state: Tminnsstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minnsiteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnsiteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function minnsiteration( state: Tminnsstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_minnsiteration(state, _xparams);
end;

procedure minnsoptimize(state: Tminnsstate; fvec: Tndimensional_fvec; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_needfi: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @fvec=nil then
        raise Exception.Create('ALGLIB: error in minnsoptimize() (fvec is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_minnsstate_get_x(_state, @_xc_arg);
    x_minnsstate_get_fi(_state, @_xc_fi);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_fi, _xc_fi.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minnsiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnsiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minnsstate_get_xupdated(_state, @_xc_xupdated);
        x_minnsstate_get_needfi(_state, @_xc_needfi);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfi<>0 then
        begin
            fvec(_pas_arg, _pas_fi, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minnsstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minnsoptimize (some derivatives were not provided?)');
    end;
end;
procedure minnsoptimize(state: Tminnsstate; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_j: x_matrix;
    _pas_j: TMatrix;
    _xc_needfij: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @jac=nil then
        raise Exception.Create('ALGLIB: error in minnsoptimize() (jac is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_create_empty(_xc_j, DT_REAL);
    x_minnsstate_get_x(_state, @_xc_arg);
    x_minnsstate_get_fi(_state, @_xc_fi);
    x_minnsstate_get_j(_state, @_xc_j);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_fi, _xc_fi.cnt);
    SetLength(_pas_j, _xc_j.rows, _xc_j.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minnsiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnsiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minnsstate_get_xupdated(_state, @_xc_xupdated);
        x_minnsstate_get_needfij(_state, @_xc_needfij);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfij<>0 then
        begin
            jac(_pas_arg, _pas_fi, _pas_j, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            x_from_array(_xc_j,  _pas_j,  X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minnsstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minnsoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_minnsresults( state: Tminnsstate; out  x: TVector; out  rep: Tminnsreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minnsreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minnsreport_init(_d_rep);
        _error_code := x_xv2_minnsresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnsresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minnsreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minnsreport_clear(_d_rep);
    end;
end;


procedure minnsresults( state: Tminnsstate; out  x: TVector; out  rep: Tminnsreport; const _xparams: UInt64 = 0);
begin
    _core_minnsresults(state, x, rep, _xparams);
end;


procedure _core_minnsresultsbuf( state: Tminnsstate; var  x: TVector;  rep: Tminnsreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minnsreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minnsreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minnsresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnsresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minnsreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minnsreport_clear(_d_rep);
    end;
end;


procedure minnsresultsbuf( state: Tminnsstate; var  x: TVector;  rep: Tminnsreport; const _xparams: UInt64 = 0);
begin
    _core_minnsresultsbuf(state, x, rep, _xparams);
end;


procedure _core_minnsrestartfrom( state: Tminnsstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_minnsrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minnsrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure minnsrestartfrom( state: Tminnsstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_minnsrestartfrom(state, x, _xparams);
end;

constructor Tminasastate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminasastate.Destroy();
begin
    Deallocate();
end;

function Tminasastate.Clone():Tminasastate;
begin
    if ptr=nil then
        Result:=Tminasastate.Create(nil)
    else
        Result:=Tminasastate.Create(x_obj_copy_minasastate(ptr));
end;

procedure Tminasastate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minasastate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminasareport):Tminasareport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfev := src.nfev;
    Result.terminationtype := src.terminationtype;
    Result.activeconstraints := src.activeconstraints;
end;

procedure x_minasareport_init(var x: x_minasareport);
begin
    x.iterationscount.longval := 0;
    x.nfev.longval := 0;
    x.terminationtype.longval := 0;
    x.activeconstraints.longval := 0;
end;

procedure x_minasareport_clear(var x: x_minasareport);
begin
end;

procedure x_minasareport_init_from(var x: x_minasareport; const v: Tminasareport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfev.longval := v.nfev;
    x.terminationtype.longval := v.terminationtype;
    x.activeconstraints.longval := v.activeconstraints;
end;

procedure x_minasareport_to_record(const x: x_minasareport; var v: Tminasareport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.activeconstraints := x.activeconstraints.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minlbfgssetdefaultpreconditioner( state: Tminlbfgsstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlbfgssetdefaultpreconditioner(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetdefaultpreconditioner call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlbfgssetdefaultpreconditioner( state: Tminlbfgsstate; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetdefaultpreconditioner(state, _xparams);
end;


procedure _core_minlbfgssetcholeskypreconditioner( state: Tminlbfgsstate;  p: TMatrix;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_p: x_matrix;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_p, p, X_CREATE);
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_minlbfgssetcholeskypreconditioner(@_s_error_msg, @_d_state, @_d_p, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlbfgssetcholeskypreconditioner call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_p);
    end;
end;


procedure minlbfgssetcholeskypreconditioner( state: Tminlbfgsstate;  p: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minlbfgssetcholeskypreconditioner(state, p, isupper, _xparams);
end;


procedure _core_minbleicsetbarrierwidth( state: Tminbleicstate;  mu: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_mu: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_mu := mu;
        _error_code := x_xv2_minbleicsetbarrierwidth(@_s_error_msg, @_d_state, @_d_mu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetbarrierwidth call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicsetbarrierwidth( state: Tminbleicstate;  mu: Double; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetbarrierwidth(state, mu, _xparams);
end;


procedure _core_minbleicsetbarrierdecay( state: Tminbleicstate;  mudecay: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_mudecay: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_mudecay := mudecay;
        _error_code := x_xv2_minbleicsetbarrierdecay(@_s_error_msg, @_d_state, @_d_mudecay, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minbleicsetbarrierdecay call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minbleicsetbarrierdecay( state: Tminbleicstate;  mudecay: Double; const _xparams: UInt64 = 0);
begin
    _core_minbleicsetbarrierdecay(state, mudecay, _xparams);
end;


procedure _core_minasacreate( n: TALGLIBInteger;  x: TVector;  bndl: TVector;  bndu: TVector; out  state: Tminasastate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minasacreate(@_s_error_msg, @_d_n, @_d_x, @_d_bndl, @_d_bndu, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasacreate call');
        end;
        state := Tminasastate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minasastate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minasacreate( n: TALGLIBInteger;  x: TVector;  bndl: TVector;  bndu: TVector; out  state: Tminasastate; const _xparams: UInt64 = 0);overload;
begin
    _core_minasacreate(n, x, bndl, bndu, state, _xparams);
end;


procedure minasacreate( x: TVector;  bndl: TVector;  bndu: TVector; out  state: Tminasastate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(bndl))) or ((xlen(x)<>xlen(bndu))) then
    raise Exception.Create('Error while calling minasacreate: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_minasacreate(n, x, bndl, bndu, state, _xparams);

end;


procedure _core_minasasetcond( state: Tminasastate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsg: Double;
    _d_epsf: Double;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsg := epsg;
        _d_epsf := epsf;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minasasetcond(@_s_error_msg, @_d_state, @_d_epsg, @_d_epsf, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasasetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minasasetcond( state: Tminasastate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minasasetcond(state, epsg, epsf, epsx, maxits, _xparams);
end;


procedure _core_minasasetxrep( state: Tminasastate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_minasasetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasasetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minasasetxrep( state: Tminasastate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minasasetxrep(state, needxrep, _xparams);
end;


procedure _core_minasasetalgorithm( state: Tminasastate;  algotype: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_algotype: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_algotype := algotype;
        _error_code := x_xv2_minasasetalgorithm(@_s_error_msg, @_d_state, @_d_algotype, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasasetalgorithm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minasasetalgorithm( state: Tminasastate;  algotype: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minasasetalgorithm(state, algotype, _xparams);
end;


procedure _core_minasasetstpmax( state: Tminasastate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_minasasetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasasetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minasasetstpmax( state: Tminasastate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_minasasetstpmax(state, stpmax, _xparams);
end;


function _core_minasaiteration( state: Tminasastate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minasaiteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasaiteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function minasaiteration( state: Tminasastate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_minasaiteration(state, _xparams);
end;

procedure minasaoptimize(state: Tminasastate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_needfg: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in minasaoptimize() (grad is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_minasastate_get_x(_state, @_xc_arg);
    x_minasastate_get_g(_state, @_xc_g);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minasaiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasaiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minasastate_get_xupdated(_state, @_xc_xupdated);
        x_minasastate_get_needfg(_state, @_xc_needfg);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_f, _pas_g, obj);
            x_minasastate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minasastate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minasaoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_minasaresults( state: Tminasastate; out  x: TVector; out  rep: Tminasareport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minasareport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minasareport_init(_d_rep);
        _error_code := x_xv2_minasaresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasaresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minasareport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minasareport_clear(_d_rep);
    end;
end;


procedure minasaresults( state: Tminasastate; out  x: TVector; out  rep: Tminasareport; const _xparams: UInt64 = 0);
begin
    _core_minasaresults(state, x, rep, _xparams);
end;


procedure _core_minasaresultsbuf( state: Tminasastate; var  x: TVector;  rep: Tminasareport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minasareport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minasareport_init_from(_d_rep, rep);
        _error_code := x_xv2_minasaresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasaresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minasareport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minasareport_clear(_d_rep);
    end;
end;


procedure minasaresultsbuf( state: Tminasastate; var  x: TVector;  rep: Tminasareport; const _xparams: UInt64 = 0);
begin
    _core_minasaresultsbuf(state, x, rep, _xparams);
end;


procedure _core_minasarestartfrom( state: Tminasastate;  x: TVector;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minasarestartfrom(@_s_error_msg, @_d_state, @_d_x, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minasarestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minasarestartfrom( state: Tminasastate;  x: TVector;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minasarestartfrom(state, x, bndl, bndu, _xparams);
end;

constructor Tmincgstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tmincgstate.Destroy();
begin
    Deallocate();
end;

function Tmincgstate.Clone():Tmincgstate;
begin
    if ptr=nil then
        Result:=Tmincgstate.Create(nil)
    else
        Result:=Tmincgstate.Create(x_obj_copy_mincgstate(ptr));
end;

procedure Tmincgstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_mincgstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tmincgreport):Tmincgreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfev := src.nfev;
    Result.terminationtype := src.terminationtype;
end;

procedure x_mincgreport_init(var x: x_mincgreport);
begin
    x.iterationscount.longval := 0;
    x.nfev.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_mincgreport_clear(var x: x_mincgreport);
begin
end;

procedure x_mincgreport_init_from(var x: x_mincgreport; const v: Tmincgreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfev.longval := v.nfev;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_mincgreport_to_record(const x: x_mincgreport; var v: Tmincgreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_mincgcreate( n: TALGLIBInteger;  x: TVector; out  state: Tmincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_mincgcreate(@_s_error_msg, @_d_n, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgcreate call');
        end;
        state := Tmincgstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_mincgstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mincgcreate( n: TALGLIBInteger;  x: TVector; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
begin
    _core_mincgcreate(n, x, state, _xparams);
end;


procedure mincgcreate( x: TVector; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_mincgcreate(n, x, state, _xparams);

end;


procedure _core_mincgcreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tmincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_mincgcreatef(@_s_error_msg, @_d_n, @_d_x, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgcreatef call');
        end;
        state := Tmincgstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_mincgstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mincgcreatef( n: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
begin
    _core_mincgcreatef(n, x, diffstep, state, _xparams);
end;


procedure mincgcreatef( x: TVector;  diffstep: Double; out  state: Tmincgstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_mincgcreatef(n, x, diffstep, state, _xparams);

end;


procedure _core_mincgsetcond( state: Tmincgstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsg: Double;
    _d_epsf: Double;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsg := epsg;
        _d_epsf := epsf;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_mincgsetcond(@_s_error_msg, @_d_state, @_d_epsg, @_d_epsf, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgsetcond( state: Tmincgstate;  epsg: Double;  epsf: Double;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mincgsetcond(state, epsg, epsf, epsx, maxits, _xparams);
end;


procedure _core_mincgsetscale( state: Tmincgstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_mincgsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure mincgsetscale( state: Tmincgstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_mincgsetscale(state, s, _xparams);
end;


procedure _core_mincgsetxrep( state: Tmincgstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_mincgsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgsetxrep( state: Tmincgstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_mincgsetxrep(state, needxrep, _xparams);
end;


procedure _core_mincgsetcgtype( state: Tmincgstate;  cgtype: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_cgtype: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_cgtype := cgtype;
        _error_code := x_xv2_mincgsetcgtype(@_s_error_msg, @_d_state, @_d_cgtype, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetcgtype call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgsetcgtype( state: Tmincgstate;  cgtype: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mincgsetcgtype(state, cgtype, _xparams);
end;


procedure _core_mincgsetstpmax( state: Tmincgstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_mincgsetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgsetstpmax( state: Tmincgstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_mincgsetstpmax(state, stpmax, _xparams);
end;


procedure _core_mincgsuggeststep( state: Tmincgstate;  stp: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stp: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stp := stp;
        _error_code := x_xv2_mincgsuggeststep(@_s_error_msg, @_d_state, @_d_stp, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsuggeststep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgsuggeststep( state: Tmincgstate;  stp: Double; const _xparams: UInt64 = 0);
begin
    _core_mincgsuggeststep(state, stp, _xparams);
end;


procedure _core_mincgsetprecdefault( state: Tmincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_mincgsetprecdefault(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetprecdefault call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgsetprecdefault( state: Tmincgstate; const _xparams: UInt64 = 0);
begin
    _core_mincgsetprecdefault(state, _xparams);
end;


procedure _core_mincgsetprecdiag( state: Tmincgstate;  d: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_d: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_d, d, X_CREATE);
        _error_code := x_xv2_mincgsetprecdiag(@_s_error_msg, @_d_state, @_d_d, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetprecdiag call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
    end;
end;


procedure mincgsetprecdiag( state: Tmincgstate;  d: TVector; const _xparams: UInt64 = 0);
begin
    _core_mincgsetprecdiag(state, d, _xparams);
end;


procedure _core_mincgsetprecscale( state: Tmincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_mincgsetprecscale(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgsetprecscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgsetprecscale( state: Tmincgstate; const _xparams: UInt64 = 0);
begin
    _core_mincgsetprecscale(state, _xparams);
end;


function _core_mincgiteration( state: Tmincgstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_mincgiteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgiteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mincgiteration( state: Tmincgstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_mincgiteration(state, _xparams);
end;

procedure mincgoptimize(state: Tmincgstate; func: Tndimensional_func; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_needf: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in mincgoptimize() (func is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_mincgstate_get_x(_state, @_xc_arg);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_mincgiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_mincgstate_get_xupdated(_state, @_xc_xupdated);
        x_mincgstate_get_needf(_state, @_xc_needf);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_mincgstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_mincgstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in mincgoptimize (some derivatives were not provided?)');
    end;
end;
procedure mincgoptimize(state: Tmincgstate; grad: Tndimensional_grad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_needfg: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in mincgoptimize() (grad is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_mincgstate_get_x(_state, @_xc_arg);
    x_mincgstate_get_g(_state, @_xc_g);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_mincgiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_mincgstate_get_xupdated(_state, @_xc_xupdated);
        x_mincgstate_get_needfg(_state, @_xc_needfg);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_f, _pas_g, obj);
            x_mincgstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_mincgstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in mincgoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_mincgoptguardgradient( state: Tmincgstate;  teststep: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_teststep: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_teststep := teststep;
        _error_code := x_xv2_mincgoptguardgradient(@_s_error_msg, @_d_state, @_d_teststep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgoptguardgradient call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgoptguardgradient( state: Tmincgstate;  teststep: Double; const _xparams: UInt64 = 0);
begin
    _core_mincgoptguardgradient(state, teststep, _xparams);
end;


procedure _core_mincgoptguardsmoothness( state: Tmincgstate;  level: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_level: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_level := level;
        _error_code := x_xv2_mincgoptguardsmoothness(@_s_error_msg, @_d_state, @_d_level, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgoptguardsmoothness call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgoptguardsmoothness( state: Tmincgstate;  level: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_mincgoptguardsmoothness(state, level, _xparams);
end;


procedure mincgoptguardsmoothness( state: Tmincgstate; const _xparams: UInt64 = 0);overload;
var
    level: TALGLIBInteger;

begin

    level := 1;

    _core_mincgoptguardsmoothness(state, level, _xparams);

end;


procedure _core_mincgoptguardresults( state: Tmincgstate; out  rep: Toptguardreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_rep: x_optguardreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardreport_init(_d_rep);
        _error_code := x_xv2_mincgoptguardresults(@_s_error_msg, @_d_state, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgoptguardresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardreport_clear(_d_rep);
    end;
end;


procedure mincgoptguardresults( state: Tmincgstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
begin
    _core_mincgoptguardresults(state, rep, _xparams);
end;


procedure _core_mincgoptguardnonc1test0results( state: Tmincgstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test0report;
    _d_lngrep: x_optguardnonc1test0report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test0report_init(_d_strrep);
        x_optguardnonc1test0report_init(_d_lngrep);
        _error_code := x_xv2_mincgoptguardnonc1test0results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgoptguardnonc1test0results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test0report_to_record(_d_strrep, strrep);
        x_optguardnonc1test0report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test0report_clear(_d_strrep);
        x_optguardnonc1test0report_clear(_d_lngrep);
    end;
end;


procedure mincgoptguardnonc1test0results( state: Tmincgstate; out  strrep: Toptguardnonc1test0report; out  lngrep: Toptguardnonc1test0report; const _xparams: UInt64 = 0);
begin
    _core_mincgoptguardnonc1test0results(state, strrep, lngrep, _xparams);
end;


procedure _core_mincgoptguardnonc1test1results( state: Tmincgstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_strrep: x_optguardnonc1test1report;
    _d_lngrep: x_optguardnonc1test1report;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardnonc1test1report_init(_d_strrep);
        x_optguardnonc1test1report_init(_d_lngrep);
        _error_code := x_xv2_mincgoptguardnonc1test1results(@_s_error_msg, @_d_state, @_d_strrep, @_d_lngrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgoptguardnonc1test1results call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardnonc1test1report_to_record(_d_strrep, strrep);
        x_optguardnonc1test1report_to_record(_d_lngrep, lngrep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardnonc1test1report_clear(_d_strrep);
        x_optguardnonc1test1report_clear(_d_lngrep);
    end;
end;


procedure mincgoptguardnonc1test1results( state: Tmincgstate; out  strrep: Toptguardnonc1test1report; out  lngrep: Toptguardnonc1test1report; const _xparams: UInt64 = 0);
begin
    _core_mincgoptguardnonc1test1results(state, strrep, lngrep, _xparams);
end;


procedure _core_mincgresults( state: Tmincgstate; out  x: TVector; out  rep: Tmincgreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_mincgreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_mincgreport_init(_d_rep);
        _error_code := x_xv2_mincgresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_mincgreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_mincgreport_clear(_d_rep);
    end;
end;


procedure mincgresults( state: Tmincgstate; out  x: TVector; out  rep: Tmincgreport; const _xparams: UInt64 = 0);
begin
    _core_mincgresults(state, x, rep, _xparams);
end;


procedure _core_mincgresultsbuf( state: Tmincgstate; var  x: TVector;  rep: Tmincgreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_mincgreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_mincgreport_init_from(_d_rep, rep);
        _error_code := x_xv2_mincgresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_mincgreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_mincgreport_clear(_d_rep);
    end;
end;


procedure mincgresultsbuf( state: Tmincgstate; var  x: TVector;  rep: Tmincgreport; const _xparams: UInt64 = 0);
begin
    _core_mincgresultsbuf(state, x, rep, _xparams);
end;


procedure _core_mincgrestartfrom( state: Tmincgstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_mincgrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure mincgrestartfrom( state: Tmincgstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_mincgrestartfrom(state, x, _xparams);
end;


procedure _core_mincgrequesttermination( state: Tmincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_mincgrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mincgrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mincgrequesttermination( state: Tmincgstate; const _xparams: UInt64 = 0);
begin
    _core_mincgrequesttermination(state, _xparams);
end;

constructor Tminlmstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tminlmstate.Destroy();
begin
    Deallocate();
end;

function Tminlmstate.Clone():Tminlmstate;
begin
    if ptr=nil then
        Result:=Tminlmstate.Create(nil)
    else
        Result:=Tminlmstate.Create(x_obj_copy_minlmstate(ptr));
end;

procedure Tminlmstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_minlmstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tminlmreport):Tminlmreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.terminationtype := src.terminationtype;
    Result.nfunc := src.nfunc;
    Result.njac := src.njac;
    Result.ngrad := src.ngrad;
    Result.nhess := src.nhess;
    Result.ncholesky := src.ncholesky;
end;

procedure x_minlmreport_init(var x: x_minlmreport);
begin
    x.iterationscount.longval := 0;
    x.terminationtype.longval := 0;
    x.nfunc.longval := 0;
    x.njac.longval := 0;
    x.ngrad.longval := 0;
    x.nhess.longval := 0;
    x.ncholesky.longval := 0;
end;

procedure x_minlmreport_clear(var x: x_minlmreport);
begin
end;

procedure x_minlmreport_init_from(var x: x_minlmreport; const v: Tminlmreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.terminationtype.longval := v.terminationtype;
    x.nfunc.longval := v.nfunc;
    x.njac.longval := v.njac;
    x.ngrad.longval := v.ngrad;
    x.nhess.longval := v.nhess;
    x.ncholesky.longval := v.ncholesky;
end;

procedure x_minlmreport_to_record(const x: x_minlmreport; var v: Tminlmreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.nfunc := x.nfunc.val; // long is silently truncated to TALGLIBInteger
    v.njac := x.njac.val; // long is silently truncated to TALGLIBInteger
    v.ngrad := x.ngrad.val; // long is silently truncated to TALGLIBInteger
    v.nhess := x.nhess.val; // long is silently truncated to TALGLIBInteger
    v.ncholesky := x.ncholesky.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_minlmcreatevj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlmcreatevj(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmcreatevj call');
        end;
        state := Tminlmstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlmcreatevj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlmcreatevj(n, m, x, state, _xparams);
end;


procedure minlmcreatevj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlmcreatevj(n, m, x, state, _xparams);

end;


procedure _core_minlmcreatev( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlmstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlmcreatev(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmcreatev call');
        end;
        state := Tminlmstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlmcreatev( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlmcreatev(n, m, x, diffstep, state, _xparams);
end;


procedure minlmcreatev( m: TALGLIBInteger;  x: TVector;  diffstep: Double; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlmcreatev(n, m, x, diffstep, state, _xparams);

end;


procedure _core_minlmcreatefgh( n: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlmcreatefgh(@_s_error_msg, @_d_n, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmcreatefgh call');
        end;
        state := Tminlmstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlmcreatefgh( n: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlmcreatefgh(n, x, state, _xparams);
end;


procedure minlmcreatefgh( x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlmcreatefgh(n, x, state, _xparams);

end;


procedure _core_minlmsetcond( state: Tminlmstate;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_minlmsetcond(@_s_error_msg, @_d_state, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlmsetcond( state: Tminlmstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minlmsetcond(state, epsx, maxits, _xparams);
end;


procedure _core_minlmsetxrep( state: Tminlmstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_minlmsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlmsetxrep( state: Tminlmstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_minlmsetxrep(state, needxrep, _xparams);
end;


procedure _core_minlmsetstpmax( state: Tminlmstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_minlmsetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmsetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlmsetstpmax( state: Tminlmstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_minlmsetstpmax(state, stpmax, _xparams);
end;


procedure _core_minlmsetscale( state: Tminlmstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_minlmsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure minlmsetscale( state: Tminlmstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlmsetscale(state, s, _xparams);
end;


procedure _core_minlmsetbc( state: Tminlmstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_minlmsetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmsetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure minlmsetbc( state: Tminlmstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlmsetbc(state, bndl, bndu, _xparams);
end;


procedure _core_minlmsetlc( state: Tminlmstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_minlmsetlc(@_s_error_msg, @_d_state, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmsetlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_clear(_d_ct);
    end;
end;


procedure minlmsetlc( state: Tminlmstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_minlmsetlc(state, c, ct, k, _xparams);
end;


procedure minlmsetlc( state: Tminlmstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(c)<>xlen(ct))) then
    raise Exception.Create('Error while calling minlmsetlc: looks like one of arguments has wrong size');

    k := xrows(c);

    _core_minlmsetlc(state, c, ct, k, _xparams);

end;


procedure _core_minlmsetacctype( state: Tminlmstate;  acctype: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_acctype: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_acctype := acctype;
        _error_code := x_xv2_minlmsetacctype(@_s_error_msg, @_d_state, @_d_acctype, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmsetacctype call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlmsetacctype( state: Tminlmstate;  acctype: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_minlmsetacctype(state, acctype, _xparams);
end;


function _core_minlmiteration( state: Tminlmstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlmiteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmiteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function minlmiteration( state: Tminlmstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_minlmiteration(state, _xparams);
end;

procedure minlmoptimize(state: Tminlmstate; fvec: Tndimensional_fvec; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_needfi: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @fvec=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (fvec is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_minlmstate_get_x(_state, @_xc_arg);
    x_minlmstate_get_fi(_state, @_xc_fi);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_fi, _xc_fi.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minlmiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minlmstate_get_xupdated(_state, @_xc_xupdated);
        x_minlmstate_get_needfi(_state, @_xc_needfi);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfi<>0 then
        begin
            fvec(_pas_arg, _pas_fi, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minlmstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minlmoptimize (some derivatives were not provided?)');
    end;
end;
procedure minlmoptimize(state: Tminlmstate; fvec: Tndimensional_fvec; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_j: x_matrix;
    _pas_j: TMatrix;
    _xc_needfi: Byte;
    _xc_needfij: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @fvec=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (fvec is nil)');
    if @jac=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (jac is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_create_empty(_xc_j, DT_REAL);
    x_minlmstate_get_x(_state, @_xc_arg);
    x_minlmstate_get_fi(_state, @_xc_fi);
    x_minlmstate_get_j(_state, @_xc_j);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_fi, _xc_fi.cnt);
    SetLength(_pas_j, _xc_j.rows, _xc_j.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minlmiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minlmstate_get_xupdated(_state, @_xc_xupdated);
        x_minlmstate_get_needfi(_state, @_xc_needfi);
        x_minlmstate_get_needfij(_state, @_xc_needfij);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needfi<>0 then
        begin
            fvec(_pas_arg, _pas_fi, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            Continue;
        end;
        if _xc_needfij<>0 then
        begin
            jac(_pas_arg, _pas_fi, _pas_j, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            x_from_array(_xc_j,  _pas_j,  X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minlmstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minlmoptimize (some derivatives were not provided?)');
    end;
end;
procedure minlmoptimize(state: Tminlmstate; func: Tndimensional_func; grad: Tndimensional_grad; hess: Tndimensional_hess; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_h: x_matrix;
    _pas_h: TMatrix;
    _xc_needf: Byte;
    _xc_needfg: Byte;
    _xc_needfgh: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (func is nil)');
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (grad is nil)');
    if @hess=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (hess is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_create_empty(_xc_h, DT_REAL);
    x_minlmstate_get_x(_state, @_xc_arg);
    x_minlmstate_get_g(_state, @_xc_g);
    x_minlmstate_get_h(_state, @_xc_h);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);
    SetLength(_pas_h, _xc_h.rows, _xc_h.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minlmiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minlmstate_get_xupdated(_state, @_xc_xupdated);
        x_minlmstate_get_needf(_state, @_xc_needf);
        x_minlmstate_get_needfg(_state, @_xc_needfg);
        x_minlmstate_get_needfgh(_state, @_xc_needfgh);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_minlmstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_f, _pas_g, obj);
            x_minlmstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_needfgh<>0 then
        begin
            hess(_pas_arg, _pas_f, _pas_g, _pas_h, obj);
            x_minlmstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            x_from_array(_xc_h, _pas_h, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minlmstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minlmoptimize (some derivatives were not provided?)');
    end;
end;
procedure minlmoptimize(state: Tminlmstate; func: Tndimensional_func; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_j: x_matrix;
    _pas_j: TMatrix;
    _xc_needf: Byte;
    _xc_needfij: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (func is nil)');
    if @jac=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (jac is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_create_empty(_xc_j, DT_REAL);
    x_minlmstate_get_x(_state, @_xc_arg);
    x_minlmstate_get_fi(_state, @_xc_fi);
    x_minlmstate_get_j(_state, @_xc_j);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_fi, _xc_fi.cnt);
    SetLength(_pas_j, _xc_j.rows, _xc_j.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minlmiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minlmstate_get_xupdated(_state, @_xc_xupdated);
        x_minlmstate_get_needf(_state, @_xc_needf);
        x_minlmstate_get_needfij(_state, @_xc_needfij);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_minlmstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_needfij<>0 then
        begin
            jac(_pas_arg, _pas_fi, _pas_j, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            x_from_array(_xc_j,  _pas_j,  X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minlmstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minlmoptimize (some derivatives were not provided?)');
    end;
end;
procedure minlmoptimize(state: Tminlmstate; func: Tndimensional_func; grad: Tndimensional_grad; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_j: x_matrix;
    _pas_j: TMatrix;
    _xc_needf: Byte;
    _xc_needfg: Byte;
    _xc_needfij: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (func is nil)');
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (grad is nil)');
    if @jac=nil then
        raise Exception.Create('ALGLIB: error in minlmoptimize() (jac is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_create_empty(_xc_j, DT_REAL);
    x_minlmstate_get_x(_state, @_xc_arg);
    x_minlmstate_get_g(_state, @_xc_g);
    x_minlmstate_get_fi(_state, @_xc_fi);
    x_minlmstate_get_j(_state, @_xc_j);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);
    SetLength(_pas_fi, _xc_fi.cnt);
    SetLength(_pas_j, _xc_j.rows, _xc_j.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_minlmiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_minlmstate_get_xupdated(_state, @_xc_xupdated);
        x_minlmstate_get_needf(_state, @_xc_needf);
        x_minlmstate_get_needfg(_state, @_xc_needfg);
        x_minlmstate_get_needfij(_state, @_xc_needfij);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_minlmstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_f, _pas_g, obj);
            x_minlmstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_needfij<>0 then
        begin
            jac(_pas_arg, _pas_fi, _pas_j, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            x_from_array(_xc_j,  _pas_j,  X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_minlmstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in minlmoptimize (some derivatives were not provided?)');
    end;
end;


procedure _core_minlmoptguardgradient( state: Tminlmstate;  teststep: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_teststep: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_teststep := teststep;
        _error_code := x_xv2_minlmoptguardgradient(@_s_error_msg, @_d_state, @_d_teststep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmoptguardgradient call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlmoptguardgradient( state: Tminlmstate;  teststep: Double; const _xparams: UInt64 = 0);
begin
    _core_minlmoptguardgradient(state, teststep, _xparams);
end;


procedure _core_minlmoptguardresults( state: Tminlmstate; out  rep: Toptguardreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_rep: x_optguardreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_optguardreport_init(_d_rep);
        _error_code := x_xv2_minlmoptguardresults(@_s_error_msg, @_d_state, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmoptguardresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_optguardreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_optguardreport_clear(_d_rep);
    end;
end;


procedure minlmoptguardresults( state: Tminlmstate; out  rep: Toptguardreport; const _xparams: UInt64 = 0);
begin
    _core_minlmoptguardresults(state, rep, _xparams);
end;


procedure _core_minlmresults( state: Tminlmstate; out  x: TVector; out  rep: Tminlmreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minlmreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_minlmreport_init(_d_rep);
        _error_code := x_xv2_minlmresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minlmreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minlmreport_clear(_d_rep);
    end;
end;


procedure minlmresults( state: Tminlmstate; out  x: TVector; out  rep: Tminlmreport; const _xparams: UInt64 = 0);
begin
    _core_minlmresults(state, x, rep, _xparams);
end;


procedure _core_minlmresultsbuf( state: Tminlmstate; var  x: TVector;  rep: Tminlmreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_minlmreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_minlmreport_init_from(_d_rep, rep);
        _error_code := x_xv2_minlmresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_minlmreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_minlmreport_clear(_d_rep);
    end;
end;


procedure minlmresultsbuf( state: Tminlmstate; var  x: TVector;  rep: Tminlmreport; const _xparams: UInt64 = 0);
begin
    _core_minlmresultsbuf(state, x, rep, _xparams);
end;


procedure _core_minlmrestartfrom( state: Tminlmstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_minlmrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure minlmrestartfrom( state: Tminlmstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_minlmrestartfrom(state, x, _xparams);
end;


procedure _core_minlmrequesttermination( state: Tminlmstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_minlmrequesttermination(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmrequesttermination call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure minlmrequesttermination( state: Tminlmstate; const _xparams: UInt64 = 0);
begin
    _core_minlmrequesttermination(state, _xparams);
end;


procedure _core_minlmcreatevgj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlmcreatevgj(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmcreatevgj call');
        end;
        state := Tminlmstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlmcreatevgj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlmcreatevgj(n, m, x, state, _xparams);
end;


procedure minlmcreatevgj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlmcreatevgj(n, m, x, state, _xparams);

end;


procedure _core_minlmcreatefgj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlmcreatefgj(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmcreatefgj call');
        end;
        state := Tminlmstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlmcreatefgj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlmcreatefgj(n, m, x, state, _xparams);
end;


procedure minlmcreatefgj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlmcreatefgj(n, m, x, state, _xparams);

end;


procedure _core_minlmcreatefj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_minlmcreatefj(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during minlmcreatefj call');
        end;
        state := Tminlmstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure minlmcreatefj( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
begin
    _core_minlmcreatefj(n, m, x, state, _xparams);
end;


procedure minlmcreatefj( m: TALGLIBInteger;  x: TVector; out  state: Tminlmstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_minlmcreatefj(n, m, x, state, _xparams);

end;

constructor Teigsubspacestate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Teigsubspacestate.Destroy();
begin
    Deallocate();
end;

function Teigsubspacestate.Clone():Teigsubspacestate;
begin
    if ptr=nil then
        Result:=Teigsubspacestate.Create(nil)
    else
        Result:=Teigsubspacestate.Create(x_obj_copy_eigsubspacestate(ptr));
end;

procedure Teigsubspacestate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_eigsubspacestate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Teigsubspacereport):Teigsubspacereport;overload;
begin
    Result.iterationscount := src.iterationscount;
end;

procedure x_eigsubspacereport_init(var x: x_eigsubspacereport);
begin
    x.iterationscount.longval := 0;
end;

procedure x_eigsubspacereport_clear(var x: x_eigsubspacereport);
begin
end;

procedure x_eigsubspacereport_init_from(var x: x_eigsubspacereport; const v: Teigsubspacereport);
begin
    x.iterationscount.longval := v.iterationscount;
end;

procedure x_eigsubspacereport_to_record(const x: x_eigsubspacereport; var v: Teigsubspacereport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_eigsubspacecreate( n: TALGLIBInteger;  k: TALGLIBInteger; out  state: Teigsubspacestate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_k := k;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_eigsubspacecreate(@_s_error_msg, @_d_n, @_d_k, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspacecreate call');
        end;
        state := Teigsubspacestate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_eigsubspacestate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure eigsubspacecreate( n: TALGLIBInteger;  k: TALGLIBInteger; out  state: Teigsubspacestate; const _xparams: UInt64 = 0);
begin
    _core_eigsubspacecreate(n, k, state, _xparams);
end;


procedure _core_eigsubspacecreatebuf( n: TALGLIBInteger;  k: TALGLIBInteger;  state: Teigsubspacestate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_k: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_k := k;
        _d_state := state.ptr;
        _error_code := x_xv2_eigsubspacecreatebuf(@_s_error_msg, @_d_n, @_d_k, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspacecreatebuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure eigsubspacecreatebuf( n: TALGLIBInteger;  k: TALGLIBInteger;  state: Teigsubspacestate; const _xparams: UInt64 = 0);
begin
    _core_eigsubspacecreatebuf(n, k, state, _xparams);
end;


procedure _core_eigsubspacesetcond( state: Teigsubspacestate;  eps: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_eps: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_eps := eps;
        _d_maxits := maxits;
        _error_code := x_xv2_eigsubspacesetcond(@_s_error_msg, @_d_state, @_d_eps, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspacesetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure eigsubspacesetcond( state: Teigsubspacestate;  eps: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_eigsubspacesetcond(state, eps, maxits, _xparams);
end;


procedure _core_eigsubspacesetwarmstart( state: Teigsubspacestate;  usewarmstart: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_usewarmstart: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_usewarmstart := Bool2Byte(usewarmstart);
        _error_code := x_xv2_eigsubspacesetwarmstart(@_s_error_msg, @_d_state, @_d_usewarmstart, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspacesetwarmstart call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure eigsubspacesetwarmstart( state: Teigsubspacestate;  usewarmstart: Boolean; const _xparams: UInt64 = 0);
begin
    _core_eigsubspacesetwarmstart(state, usewarmstart, _xparams);
end;


procedure _core_eigsubspaceoocstart( state: Teigsubspacestate;  mtype: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_mtype: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_mtype := mtype;
        _error_code := x_xv2_eigsubspaceoocstart(@_s_error_msg, @_d_state, @_d_mtype, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspaceoocstart call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure eigsubspaceoocstart( state: Teigsubspacestate;  mtype: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_eigsubspaceoocstart(state, mtype, _xparams);
end;


function _core_eigsubspaceooccontinue( state: Teigsubspacestate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_eigsubspaceooccontinue(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspaceooccontinue call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function eigsubspaceooccontinue( state: Teigsubspacestate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_eigsubspaceooccontinue(state, _xparams);
end;


procedure _core_eigsubspaceoocgetrequestinfo( state: Teigsubspacestate; out  requesttype: TALGLIBInteger; out  requestsize: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_requesttype: NativeInt;
    _d_requestsize: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_eigsubspaceoocgetrequestinfo(@_s_error_msg, @_d_state, @_d_requesttype, @_d_requestsize, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspaceoocgetrequestinfo call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        requesttype := _d_requesttype;
        requestsize := _d_requestsize;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure eigsubspaceoocgetrequestinfo( state: Teigsubspacestate; out  requesttype: TALGLIBInteger; out  requestsize: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_eigsubspaceoocgetrequestinfo(state, requesttype, requestsize, _xparams);
end;


procedure _core_eigsubspaceoocgetrequestdata( state: Teigsubspacestate; var  x: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_eigsubspaceoocgetrequestdata(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspaceoocgetrequestdata call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure eigsubspaceoocgetrequestdata( state: Teigsubspacestate; var  x: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_eigsubspaceoocgetrequestdata(state, x, _xparams);
end;


procedure _core_eigsubspaceoocsendresult( state: Teigsubspacestate;  ax: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_ax: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_ax, ax, X_CREATE);
        _error_code := x_xv2_eigsubspaceoocsendresult(@_s_error_msg, @_d_state, @_d_ax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspaceoocsendresult call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_ax);
    end;
end;


procedure eigsubspaceoocsendresult( state: Teigsubspacestate;  ax: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_eigsubspaceoocsendresult(state, ax, _xparams);
end;


procedure _core_eigsubspaceoocstop( state: Teigsubspacestate; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_w: x_vector;
    _d_z: x_matrix;
    _d_rep: x_eigsubspacereport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_z, DT_REAL);
        z := nil;
        x_eigsubspacereport_init(_d_rep);
        _error_code := x_xv2_eigsubspaceoocstop(@_s_error_msg, @_d_state, @_d_w, @_d_z, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspaceoocstop call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_w, w);
        x_to_array(_d_z, z);
        x_eigsubspacereport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_w);
        x_clear(_d_z);
        x_eigsubspacereport_clear(_d_rep);
    end;
end;


procedure eigsubspaceoocstop( state: Teigsubspacestate; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; const _xparams: UInt64 = 0);
begin
    _core_eigsubspaceoocstop(state, w, z, rep, _xparams);
end;


procedure _core_eigsubspacesolvedenses( state: Teigsubspacestate;  a: TMatrix;  isupper: Boolean; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a: x_matrix;
    _d_isupper: Byte;
    _d_w: x_vector;
    _d_z: x_matrix;
    _d_rep: x_eigsubspacereport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_isupper := Bool2Byte(isupper);
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_z, DT_REAL);
        z := nil;
        x_eigsubspacereport_init(_d_rep);
        _error_code := x_xv2_eigsubspacesolvedenses(@_s_error_msg, @_d_state, @_d_a, @_d_isupper, @_d_w, @_d_z, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspacesolvedenses call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_w, w);
        x_to_array(_d_z, z);
        x_eigsubspacereport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_w);
        x_clear(_d_z);
        x_eigsubspacereport_clear(_d_rep);
    end;
end;


procedure eigsubspacesolvedenses( state: Teigsubspacestate;  a: TMatrix;  isupper: Boolean; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; const _xparams: UInt64 = 0);
begin
    _core_eigsubspacesolvedenses(state, a, isupper, w, z, rep, _xparams);
end;


procedure _core_eigsubspacesolvesparses( state: Teigsubspacestate;  a: Tsparsematrix;  isupper: Boolean; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a : Pointer;
    _d_isupper: Byte;
    _d_w: x_vector;
    _d_z: x_matrix;
    _d_rep: x_eigsubspacereport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_a := a.ptr;
        _d_isupper := Bool2Byte(isupper);
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_z, DT_REAL);
        z := nil;
        x_eigsubspacereport_init(_d_rep);
        _error_code := x_xv2_eigsubspacesolvesparses(@_s_error_msg, @_d_state, @_d_a, @_d_isupper, @_d_w, @_d_z, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during eigsubspacesolvesparses call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_w, w);
        x_to_array(_d_z, z);
        x_eigsubspacereport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_w);
        x_clear(_d_z);
        x_eigsubspacereport_clear(_d_rep);
    end;
end;


procedure eigsubspacesolvesparses( state: Teigsubspacestate;  a: Tsparsematrix;  isupper: Boolean; out  w: TVector; out  z: TMatrix; out  rep: Teigsubspacereport; const _xparams: UInt64 = 0);
begin
    _core_eigsubspacesolvesparses(state, a, isupper, w, z, rep, _xparams);
end;


function _core_smatrixevd( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean; out  d: TVector; out  z: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_isupper: Byte;
    _d_d: x_vector;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_isupper := Bool2Byte(isupper);
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        x_create_empty(_d_z, DT_REAL);
        z := nil;
        _error_code := x_xv2_smatrixevd(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_zneeded, @_d_isupper, @_d_d, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixevd call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_d, d);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_d);
        x_clear(_d_z);
    end;
end;


function smatrixevd( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean; out  d: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixevd(a, n, zneeded, isupper, d, z, _xparams);
end;


function _core_smatrixevdr( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  b1: Double;  b2: Double; out  m: TALGLIBInteger; out  w: TVector; out  z: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_isupper: Byte;
    _d_b1: Double;
    _d_b2: Double;
    _d_m: NativeInt;
    _d_w: x_vector;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_isupper := Bool2Byte(isupper);
        _d_b1 := b1;
        _d_b2 := b2;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_z, DT_REAL);
        z := nil;
        _error_code := x_xv2_smatrixevdr(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_zneeded, @_d_isupper, @_d_b1, @_d_b2, @_d_m, @_d_w, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixevdr call');
        end;
        result := Byte2Bool(_d_result);
        m := _d_m;
        x_to_array(_d_w, w);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_w);
        x_clear(_d_z);
    end;
end;


function smatrixevdr( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  b1: Double;  b2: Double; out  m: TALGLIBInteger; out  w: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixevdr(a, n, zneeded, isupper, b1, b2, m, w, z, _xparams);
end;


function _core_smatrixevdi( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  i1: TALGLIBInteger;  i2: TALGLIBInteger; out  w: TVector; out  z: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_isupper: Byte;
    _d_i1: NativeInt;
    _d_i2: NativeInt;
    _d_w: x_vector;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_isupper := Bool2Byte(isupper);
        _d_i1 := i1;
        _d_i2 := i2;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_z, DT_REAL);
        z := nil;
        _error_code := x_xv2_smatrixevdi(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_zneeded, @_d_isupper, @_d_i1, @_d_i2, @_d_w, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixevdi call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_w, w);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_w);
        x_clear(_d_z);
    end;
end;


function smatrixevdi( a: TMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  i1: TALGLIBInteger;  i2: TALGLIBInteger; out  w: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixevdi(a, n, zneeded, isupper, i1, i2, w, z, _xparams);
end;


function _core_hmatrixevd( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean; out  d: TVector; out  z: TCMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_isupper: Byte;
    _d_d: x_vector;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_isupper := Bool2Byte(isupper);
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        x_create_empty(_d_z, DT_COMPLEX);
        z := nil;
        _error_code := x_xv2_hmatrixevd(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_zneeded, @_d_isupper, @_d_d, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hmatrixevd call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_d, d);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_d);
        x_clear(_d_z);
    end;
end;


function hmatrixevd( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean; out  d: TVector; out  z: TCMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_hmatrixevd(a, n, zneeded, isupper, d, z, _xparams);
end;


function _core_hmatrixevdr( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  b1: Double;  b2: Double; out  m: TALGLIBInteger; out  w: TVector; out  z: TCMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_isupper: Byte;
    _d_b1: Double;
    _d_b2: Double;
    _d_m: NativeInt;
    _d_w: x_vector;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_isupper := Bool2Byte(isupper);
        _d_b1 := b1;
        _d_b2 := b2;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_z, DT_COMPLEX);
        z := nil;
        _error_code := x_xv2_hmatrixevdr(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_zneeded, @_d_isupper, @_d_b1, @_d_b2, @_d_m, @_d_w, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hmatrixevdr call');
        end;
        result := Byte2Bool(_d_result);
        m := _d_m;
        x_to_array(_d_w, w);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_w);
        x_clear(_d_z);
    end;
end;


function hmatrixevdr( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  b1: Double;  b2: Double; out  m: TALGLIBInteger; out  w: TVector; out  z: TCMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_hmatrixevdr(a, n, zneeded, isupper, b1, b2, m, w, z, _xparams);
end;


function _core_hmatrixevdi( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  i1: TALGLIBInteger;  i2: TALGLIBInteger; out  w: TVector; out  z: TCMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_isupper: Byte;
    _d_i1: NativeInt;
    _d_i2: NativeInt;
    _d_w: x_vector;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_isupper := Bool2Byte(isupper);
        _d_i1 := i1;
        _d_i2 := i2;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        x_create_empty(_d_z, DT_COMPLEX);
        z := nil;
        _error_code := x_xv2_hmatrixevdi(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_zneeded, @_d_isupper, @_d_i1, @_d_i2, @_d_w, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hmatrixevdi call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_w, w);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_w);
        x_clear(_d_z);
    end;
end;


function hmatrixevdi( a: TCMatrix;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  isupper: Boolean;  i1: TALGLIBInteger;  i2: TALGLIBInteger; out  w: TVector; out  z: TCMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_hmatrixevdi(a, n, zneeded, isupper, i1, i2, w, z, _xparams);
end;


function _core_smatrixtdevd(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger; var  z: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_d: x_vector;
    _d_e: x_vector;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_d, d, X_CREATE);
        x_from_array(_d_e, e, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        x_from_array(_d_z, z, X_CREATE);
        _error_code := x_xv2_smatrixtdevd(@_s_error_msg, @_d_result, @_d_d, @_d_e, @_d_n, @_d_zneeded, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixtdevd call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_d, d);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
        x_clear(_d_e);
        x_clear(_d_z);
    end;
end;


function smatrixtdevd(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger; var  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixtdevd(d, e, n, zneeded, z, _xparams);
end;


function _core_smatrixtdevdr(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  a: Double;  b: Double; out  m: TALGLIBInteger; var  z: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_d: x_vector;
    _d_e: x_vector;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_m: NativeInt;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_d, d, X_CREATE);
        x_from_array(_d_e, e, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_a := a;
        _d_b := b;
        x_from_array(_d_z, z, X_CREATE);
        _error_code := x_xv2_smatrixtdevdr(@_s_error_msg, @_d_result, @_d_d, @_d_e, @_d_n, @_d_zneeded, @_d_a, @_d_b, @_d_m, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixtdevdr call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_d, d);
        m := _d_m;
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
        x_clear(_d_e);
        x_clear(_d_z);
    end;
end;


function smatrixtdevdr(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  a: Double;  b: Double; out  m: TALGLIBInteger; var  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixtdevdr(d, e, n, zneeded, a, b, m, z, _xparams);
end;


function _core_smatrixtdevdi(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  i1: TALGLIBInteger;  i2: TALGLIBInteger; var  z: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_d: x_vector;
    _d_e: x_vector;
    _d_n: NativeInt;
    _d_zneeded: NativeInt;
    _d_i1: NativeInt;
    _d_i2: NativeInt;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_d, d, X_CREATE);
        x_from_array(_d_e, e, X_CREATE);
        _d_n := n;
        _d_zneeded := zneeded;
        _d_i1 := i1;
        _d_i2 := i2;
        x_from_array(_d_z, z, X_CREATE);
        _error_code := x_xv2_smatrixtdevdi(@_s_error_msg, @_d_result, @_d_d, @_d_e, @_d_n, @_d_zneeded, @_d_i1, @_d_i2, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixtdevdi call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_d, d);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
        x_clear(_d_e);
        x_clear(_d_z);
    end;
end;


function smatrixtdevdi(var  d: TVector;  e: TVector;  n: TALGLIBInteger;  zneeded: TALGLIBInteger;  i1: TALGLIBInteger;  i2: TALGLIBInteger; var  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixtdevdi(d, e, n, zneeded, i1, i2, z, _xparams);
end;


function _core_rmatrixevd( a: TMatrix;  n: TALGLIBInteger;  vneeded: TALGLIBInteger; out  wr: TVector; out  wi: TVector; out  vl: TMatrix; out  vr: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_vneeded: NativeInt;
    _d_wr: x_vector;
    _d_wi: x_vector;
    _d_vl: x_matrix;
    _d_vr: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_vneeded := vneeded;
        x_create_empty(_d_wr, DT_REAL);
        wr := nil;
        x_create_empty(_d_wi, DT_REAL);
        wi := nil;
        x_create_empty(_d_vl, DT_REAL);
        vl := nil;
        x_create_empty(_d_vr, DT_REAL);
        vr := nil;
        _error_code := x_xv2_rmatrixevd(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_vneeded, @_d_wr, @_d_wi, @_d_vl, @_d_vr, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixevd call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_wr, wr);
        x_to_array(_d_wi, wi);
        x_to_array(_d_vl, vl);
        x_to_array(_d_vr, vr);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_wr);
        x_clear(_d_wi);
        x_clear(_d_vl);
        x_clear(_d_vr);
    end;
end;


function rmatrixevd( a: TMatrix;  n: TALGLIBInteger;  vneeded: TALGLIBInteger; out  wr: TVector; out  wi: TVector; out  vl: TMatrix; out  vr: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_rmatrixevd(a, n, vneeded, wr, wi, vl, vr, _xparams);
end;


procedure _core_samplemoments( x: TVector;  n: TALGLIBInteger; out  mean: Double; out  variance: Double; out  skewness: Double; out  kurtosis: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_mean: Double;
    _d_variance: Double;
    _d_skewness: Double;
    _d_kurtosis: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_samplemoments(@_s_error_msg, @_d_x, @_d_n, @_d_mean, @_d_variance, @_d_skewness, @_d_kurtosis, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during samplemoments call');
        end;
        mean := _d_mean;
        variance := _d_variance;
        skewness := _d_skewness;
        kurtosis := _d_kurtosis;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure samplemoments( x: TVector;  n: TALGLIBInteger; out  mean: Double; out  variance: Double; out  skewness: Double; out  kurtosis: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_samplemoments(x, n, mean, variance, skewness, kurtosis, _xparams);
end;


procedure samplemoments( x: TVector; out  mean: Double; out  variance: Double; out  skewness: Double; out  kurtosis: Double; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_samplemoments(x, n, mean, variance, skewness, kurtosis, _xparams);

end;


function _core_samplemean( x: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_samplemean(@_s_error_msg, @_d_result, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during samplemean call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function samplemean( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_samplemean(x, n, _xparams);
end;


function samplemean( x: TVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    Result := _core_samplemean(x, n, _xparams);

end;


function _core_samplevariance( x: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_samplevariance(@_s_error_msg, @_d_result, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during samplevariance call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function samplevariance( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_samplevariance(x, n, _xparams);
end;


function samplevariance( x: TVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    Result := _core_samplevariance(x, n, _xparams);

end;


function _core_sampleskewness( x: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_sampleskewness(@_s_error_msg, @_d_result, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sampleskewness call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function sampleskewness( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_sampleskewness(x, n, _xparams);
end;


function sampleskewness( x: TVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    Result := _core_sampleskewness(x, n, _xparams);

end;


function _core_samplekurtosis( x: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_samplekurtosis(@_s_error_msg, @_d_result, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during samplekurtosis call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function samplekurtosis( x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_samplekurtosis(x, n, _xparams);
end;


function samplekurtosis( x: TVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    Result := _core_samplekurtosis(x, n, _xparams);

end;


procedure _core_sampleadev( x: TVector;  n: TALGLIBInteger; out  adev: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_adev: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_sampleadev(@_s_error_msg, @_d_x, @_d_n, @_d_adev, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sampleadev call');
        end;
        adev := _d_adev;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure sampleadev( x: TVector;  n: TALGLIBInteger; out  adev: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_sampleadev(x, n, adev, _xparams);
end;


procedure sampleadev( x: TVector; out  adev: Double; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_sampleadev(x, n, adev, _xparams);

end;


procedure _core_samplemedian( x: TVector;  n: TALGLIBInteger; out  median: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_median: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_samplemedian(@_s_error_msg, @_d_x, @_d_n, @_d_median, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during samplemedian call');
        end;
        median := _d_median;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure samplemedian( x: TVector;  n: TALGLIBInteger; out  median: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_samplemedian(x, n, median, _xparams);
end;


procedure samplemedian( x: TVector; out  median: Double; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_samplemedian(x, n, median, _xparams);

end;


procedure _core_samplepercentile( x: TVector;  n: TALGLIBInteger;  p: Double; out  v: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_p: Double;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_p := p;
        _error_code := x_xv2_samplepercentile(@_s_error_msg, @_d_x, @_d_n, @_d_p, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during samplepercentile call');
        end;
        v := _d_v;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure samplepercentile( x: TVector;  n: TALGLIBInteger;  p: Double; out  v: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_samplepercentile(x, n, p, v, _xparams);
end;


procedure samplepercentile( x: TVector;  p: Double; out  v: Double; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_samplepercentile(x, n, p, v, _xparams);

end;


function _core_cov2( x: TVector;  y: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_cov2(@_s_error_msg, @_d_result, @_d_x, @_d_y, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cov2 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


function cov2( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_cov2(x, y, n, _xparams);
end;


function cov2( x: TVector;  y: TVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling cov2: looks like one of arguments has wrong size');

    n := xlen(x);

    Result := _core_cov2(x, y, n, _xparams);

end;


function _core_pearsoncorr2( x: TVector;  y: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_pearsoncorr2(@_s_error_msg, @_d_result, @_d_x, @_d_y, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pearsoncorr2 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


function pearsoncorr2( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_pearsoncorr2(x, y, n, _xparams);
end;


function pearsoncorr2( x: TVector;  y: TVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling pearsoncorr2: looks like one of arguments has wrong size');

    n := xlen(x);

    Result := _core_pearsoncorr2(x, y, n, _xparams);

end;


function _core_spearmancorr2( x: TVector;  y: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_spearmancorr2(@_s_error_msg, @_d_result, @_d_x, @_d_y, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spearmancorr2 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


function spearmancorr2( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_spearmancorr2(x, y, n, _xparams);
end;


function spearmancorr2( x: TVector;  y: TVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spearmancorr2: looks like one of arguments has wrong size');

    n := xlen(x);

    Result := _core_spearmancorr2(x, y, n, _xparams);

end;


procedure _core_covm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_c: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_m := m;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_covm(@_s_error_msg, @_d_x, @_d_n, @_d_m, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during covm call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_c);
    end;
end;


procedure covm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
begin
    _core_covm(x, n, m, c, _xparams);
end;


procedure covm( x: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;

begin

    n := xrows(x);
    m := xcols(x);

    _core_covm(x, n, m, c, _xparams);

end;


procedure _core_pearsoncorrm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_c: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_m := m;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_pearsoncorrm(@_s_error_msg, @_d_x, @_d_n, @_d_m, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pearsoncorrm call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_c);
    end;
end;


procedure pearsoncorrm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
begin
    _core_pearsoncorrm(x, n, m, c, _xparams);
end;


procedure pearsoncorrm( x: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;

begin

    n := xrows(x);
    m := xcols(x);

    _core_pearsoncorrm(x, n, m, c, _xparams);

end;


procedure _core_spearmancorrm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_c: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_m := m;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_spearmancorrm(@_s_error_msg, @_d_x, @_d_n, @_d_m, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spearmancorrm call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_c);
    end;
end;


procedure spearmancorrm( x: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
begin
    _core_spearmancorrm(x, n, m, c, _xparams);
end;


procedure spearmancorrm( x: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;

begin

    n := xrows(x);
    m := xcols(x);

    _core_spearmancorrm(x, n, m, c, _xparams);

end;


procedure _core_covm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_matrix;
    _d_n: NativeInt;
    _d_m1: NativeInt;
    _d_m2: NativeInt;
    _d_c: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m1 := m1;
        _d_m2 := m2;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_covm2(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m1, @_d_m2, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during covm2 call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_c);
    end;
end;


procedure covm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
begin
    _core_covm2(x, y, n, m1, m2, c, _xparams);
end;


procedure covm2( x: TMatrix;  y: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m1: TALGLIBInteger;
    m2: TALGLIBInteger;

begin
    if ((xrows(x)<>xrows(y))) then
    raise Exception.Create('Error while calling covm2: looks like one of arguments has wrong size');

    n := xrows(x);
    m1 := xcols(x);
    m2 := xcols(y);

    _core_covm2(x, y, n, m1, m2, c, _xparams);

end;


procedure _core_pearsoncorrm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_matrix;
    _d_n: NativeInt;
    _d_m1: NativeInt;
    _d_m2: NativeInt;
    _d_c: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m1 := m1;
        _d_m2 := m2;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_pearsoncorrm2(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m1, @_d_m2, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pearsoncorrm2 call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_c);
    end;
end;


procedure pearsoncorrm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
begin
    _core_pearsoncorrm2(x, y, n, m1, m2, c, _xparams);
end;


procedure pearsoncorrm2( x: TMatrix;  y: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m1: TALGLIBInteger;
    m2: TALGLIBInteger;

begin
    if ((xrows(x)<>xrows(y))) then
    raise Exception.Create('Error while calling pearsoncorrm2: looks like one of arguments has wrong size');

    n := xrows(x);
    m1 := xcols(x);
    m2 := xcols(y);

    _core_pearsoncorrm2(x, y, n, m1, m2, c, _xparams);

end;


procedure _core_spearmancorrm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_matrix;
    _d_n: NativeInt;
    _d_m1: NativeInt;
    _d_m2: NativeInt;
    _d_c: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m1 := m1;
        _d_m2 := m2;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_spearmancorrm2(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m1, @_d_m2, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spearmancorrm2 call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_c);
    end;
end;


procedure spearmancorrm2( x: TMatrix;  y: TMatrix;  n: TALGLIBInteger;  m1: TALGLIBInteger;  m2: TALGLIBInteger; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
begin
    _core_spearmancorrm2(x, y, n, m1, m2, c, _xparams);
end;


procedure spearmancorrm2( x: TMatrix;  y: TMatrix; out  c: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m1: TALGLIBInteger;
    m2: TALGLIBInteger;

begin
    if ((xrows(x)<>xrows(y))) then
    raise Exception.Create('Error while calling spearmancorrm2: looks like one of arguments has wrong size');

    n := xrows(x);
    m1 := xcols(x);
    m2 := xcols(y);

    _core_spearmancorrm2(x, y, n, m1, m2, c, _xparams);

end;


procedure _core_rankdata(var  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nfeatures: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nfeatures := nfeatures;
        _error_code := x_xv2_rankdata(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nfeatures, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rankdata call');
        end;
        x_to_array(_d_xy, xy);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure rankdata(var  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_rankdata(xy, npoints, nfeatures, _xparams);
end;


procedure rankdata(var  xy: TMatrix; const _xparams: UInt64 = 0);overload;
var
    npoints: TALGLIBInteger;
    nfeatures: TALGLIBInteger;

begin

    npoints := xrows(xy);
    nfeatures := xcols(xy);

    _core_rankdata(xy, npoints, nfeatures, _xparams);

end;


procedure _core_rankdatacentered(var  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nfeatures: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nfeatures := nfeatures;
        _error_code := x_xv2_rankdatacentered(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nfeatures, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rankdatacentered call');
        end;
        x_to_array(_d_xy, xy);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure rankdatacentered(var  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_rankdatacentered(xy, npoints, nfeatures, _xparams);
end;


procedure rankdatacentered(var  xy: TMatrix; const _xparams: UInt64 = 0);overload;
var
    npoints: TALGLIBInteger;
    nfeatures: TALGLIBInteger;

begin

    npoints := xrows(xy);
    nfeatures := xcols(xy);

    _core_rankdatacentered(xy, npoints, nfeatures, _xparams);

end;


function _core_pearsoncorrelation( x: TVector;  y: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_pearsoncorrelation(@_s_error_msg, @_d_result, @_d_x, @_d_y, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pearsoncorrelation call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


function pearsoncorrelation( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_pearsoncorrelation(x, y, n, _xparams);
end;


function _core_spearmanrankcorrelation( x: TVector;  y: TVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_spearmanrankcorrelation(@_s_error_msg, @_d_result, @_d_x, @_d_y, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spearmanrankcorrelation call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


function spearmanrankcorrelation( x: TVector;  y: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spearmanrankcorrelation(x, y, n, _xparams);
end;


procedure _core_pcabuildbasis( x: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_info: NativeInt;
    _d_s2: x_vector;
    _d_v: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        x_create_empty(_d_s2, DT_REAL);
        s2 := nil;
        x_create_empty(_d_v, DT_REAL);
        v := nil;
        _error_code := x_xv2_pcabuildbasis(@_s_error_msg, @_d_x, @_d_npoints, @_d_nvars, @_d_info, @_d_s2, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pcabuildbasis call');
        end;
        info := _d_info;
        x_to_array(_d_s2, s2);
        x_to_array(_d_v, v);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_s2);
        x_clear(_d_v);
    end;
end;


procedure pcabuildbasis( x: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_pcabuildbasis(x, npoints, nvars, info, s2, v, _xparams);
end;


procedure _core_pcatruncatedsubspace( x: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nneeded: TALGLIBInteger;  eps: Double;  maxits: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nneeded: NativeInt;
    _d_eps: Double;
    _d_maxits: NativeInt;
    _d_s2: x_vector;
    _d_v: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nneeded := nneeded;
        _d_eps := eps;
        _d_maxits := maxits;
        x_create_empty(_d_s2, DT_REAL);
        s2 := nil;
        x_create_empty(_d_v, DT_REAL);
        v := nil;
        _error_code := x_xv2_pcatruncatedsubspace(@_s_error_msg, @_d_x, @_d_npoints, @_d_nvars, @_d_nneeded, @_d_eps, @_d_maxits, @_d_s2, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pcatruncatedsubspace call');
        end;
        x_to_array(_d_s2, s2);
        x_to_array(_d_v, v);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_s2);
        x_clear(_d_v);
    end;
end;


procedure pcatruncatedsubspace( x: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nneeded: TALGLIBInteger;  eps: Double;  maxits: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_pcatruncatedsubspace(x, npoints, nvars, nneeded, eps, maxits, s2, v, _xparams);
end;


procedure _core_pcatruncatedsubspacesparse( x: Tsparsematrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nneeded: TALGLIBInteger;  eps: Double;  maxits: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x : Pointer;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nneeded: NativeInt;
    _d_eps: Double;
    _d_maxits: NativeInt;
    _d_s2: x_vector;
    _d_v: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x.ptr;
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nneeded := nneeded;
        _d_eps := eps;
        _d_maxits := maxits;
        x_create_empty(_d_s2, DT_REAL);
        s2 := nil;
        x_create_empty(_d_v, DT_REAL);
        v := nil;
        _error_code := x_xv2_pcatruncatedsubspacesparse(@_s_error_msg, @_d_x, @_d_npoints, @_d_nvars, @_d_nneeded, @_d_eps, @_d_maxits, @_d_s2, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pcatruncatedsubspacesparse call');
        end;
        Assert(x.ptr=_d_x, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_s2, s2);
        x_to_array(_d_v, v);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s2);
        x_clear(_d_v);
    end;
end;


procedure pcatruncatedsubspacesparse( x: Tsparsematrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nneeded: TALGLIBInteger;  eps: Double;  maxits: TALGLIBInteger; out  s2: TVector; out  v: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_pcatruncatedsubspacesparse(x, npoints, nvars, nneeded, eps, maxits, s2, v, _xparams);
end;


procedure _core_dsoptimalsplit2( a: TVector;  c: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  threshold: Double; out  pal: Double; out  pbl: Double; out  par: Double; out  pbr: Double; out  cve: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_threshold: Double;
    _d_pal: Double;
    _d_pbl: Double;
    _d_par: Double;
    _d_pbr: Double;
    _d_cve: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_dsoptimalsplit2(@_s_error_msg, @_d_a, @_d_c, @_d_n, @_d_info, @_d_threshold, @_d_pal, @_d_pbl, @_d_par, @_d_pbr, @_d_cve, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dsoptimalsplit2 call');
        end;
        info := _d_info;
        threshold := _d_threshold;
        pal := _d_pal;
        pbl := _d_pbl;
        par := _d_par;
        pbr := _d_pbr;
        cve := _d_cve;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_c);
    end;
end;


procedure dsoptimalsplit2( a: TVector;  c: TIVector;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  threshold: Double; out  pal: Double; out  pbl: Double; out  par: Double; out  pbr: Double; out  cve: Double; const _xparams: UInt64 = 0);
begin
    _core_dsoptimalsplit2(a, c, n, info, threshold, pal, pbl, par, pbr, cve, _xparams);
end;


procedure _core_dsoptimalsplit2fast(var  a: TVector; var  c: TIVector; var  tiesbuf: TIVector; var  cntbuf: TIVector; var  bufr: TVector; var  bufi: TIVector;  n: TALGLIBInteger;  nc: TALGLIBInteger;  alpha: Double; out  info: TALGLIBInteger; out  threshold: Double; out  rms: Double; out  cvrms: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_c: x_vector;
    _d_tiesbuf: x_vector;
    _d_cntbuf: x_vector;
    _d_bufr: x_vector;
    _d_bufi: x_vector;
    _d_n: NativeInt;
    _d_nc: NativeInt;
    _d_alpha: Double;
    _d_info: NativeInt;
    _d_threshold: Double;
    _d_rms: Double;
    _d_cvrms: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_tiesbuf, tiesbuf, X_CREATE);
        x_from_array(_d_cntbuf, cntbuf, X_CREATE);
        x_from_array(_d_bufr, bufr, X_CREATE);
        x_from_array(_d_bufi, bufi, X_CREATE);
        _d_n := n;
        _d_nc := nc;
        _d_alpha := alpha;
        _error_code := x_xv2_dsoptimalsplit2fast(@_s_error_msg, @_d_a, @_d_c, @_d_tiesbuf, @_d_cntbuf, @_d_bufr, @_d_bufi, @_d_n, @_d_nc, @_d_alpha, @_d_info, @_d_threshold, @_d_rms, @_d_cvrms, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dsoptimalsplit2fast call');
        end;
        x_to_array(_d_a, a);
        x_to_array(_d_c, c);
        x_to_array(_d_tiesbuf, tiesbuf);
        x_to_array(_d_cntbuf, cntbuf);
        x_to_array(_d_bufr, bufr);
        x_to_array(_d_bufi, bufi);
        info := _d_info;
        threshold := _d_threshold;
        rms := _d_rms;
        cvrms := _d_cvrms;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_c);
        x_clear(_d_tiesbuf);
        x_clear(_d_cntbuf);
        x_clear(_d_bufr);
        x_clear(_d_bufi);
    end;
end;


procedure dsoptimalsplit2fast(var  a: TVector; var  c: TIVector; var  tiesbuf: TIVector; var  cntbuf: TIVector; var  bufr: TVector; var  bufi: TIVector;  n: TALGLIBInteger;  nc: TALGLIBInteger;  alpha: Double; out  info: TALGLIBInteger; out  threshold: Double; out  rms: Double; out  cvrms: Double; const _xparams: UInt64 = 0);
begin
    _core_dsoptimalsplit2fast(a, c, tiesbuf, cntbuf, bufr, bufi, n, nc, alpha, info, threshold, rms, cvrms, _xparams);
end;

function Clone(const Src: Tmodelerrors):Tmodelerrors;overload;
begin
    Result.relclserror := src.relclserror;
    Result.avgce := src.avgce;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
end;

procedure x_modelerrors_init(var x: x_modelerrors);
begin
    x.relclserror := 0;
    x.avgce := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
end;

procedure x_modelerrors_clear(var x: x_modelerrors);
begin
end;

procedure x_modelerrors_init_from(var x: x_modelerrors; const v: Tmodelerrors);
begin
    x.relclserror := v.relclserror;
    x.avgce := v.avgce;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
end;

procedure x_modelerrors_to_record(const x: x_modelerrors; var v: Tmodelerrors);
begin
    v.relclserror := x.relclserror;
    v.avgce := x.avgce;
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
end;

constructor Tmultilayerperceptron.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tmultilayerperceptron.Destroy();
begin
    Deallocate();
end;

function Tmultilayerperceptron.Clone():Tmultilayerperceptron;
begin
    if ptr=nil then
        Result:=Tmultilayerperceptron.Create(nil)
    else
        Result:=Tmultilayerperceptron.Create(x_obj_copy_multilayerperceptron(ptr));
end;

procedure Tmultilayerperceptron.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_multilayerperceptron(ptr);
    ptr:=nil;
end;

procedure mlpserialize(const obj: Tmultilayerperceptron; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_mlpserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure mlpunserialize(const s_in: AnsiString; out obj: Tmultilayerperceptron);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_mlpunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpunserialize() call');
        end;
        obj:=Tmultilayerperceptron.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_multilayerperceptron(_x);
    end;
end;

procedure mlpserialize(const obj: Tmultilayerperceptron; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_mlpserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during mlpserialize_stream() call');
    end;
end;

procedure mlpunserialize(stream: TStream; out obj: Tmultilayerperceptron);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_mlpunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpunserialize_stream() call');
        end;
        obj:=Tmultilayerperceptron.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_multilayerperceptron(_x);
    end;
end;


procedure _core_mlpcreate0( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreate0(@_s_error_msg, @_d_nin, @_d_nout, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreate0 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreate0( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreate0(nin, nout, network, _xparams);
end;


procedure _core_mlpcreate1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreate1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreate1 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreate1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreate1(nin, nhid, nout, network, _xparams);
end;


procedure _core_mlpcreate2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreate2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreate2 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreate2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreate2(nin, nhid1, nhid2, nout, network, _xparams);
end;


procedure _core_mlpcreateb0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_b: Double;
    _d_d: Double;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_b := b;
        _d_d := d;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreateb0(@_s_error_msg, @_d_nin, @_d_nout, @_d_b, @_d_d, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreateb0 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreateb0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreateb0(nin, nout, b, d, network, _xparams);
end;


procedure _core_mlpcreateb1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_b: Double;
    _d_d: Double;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_b := b;
        _d_d := d;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreateb1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_b, @_d_d, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreateb1 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreateb1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreateb1(nin, nhid, nout, b, d, network, _xparams);
end;


procedure _core_mlpcreateb2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_b: Double;
    _d_d: Double;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_b := b;
        _d_d := d;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreateb2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_b, @_d_d, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreateb2 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreateb2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreateb2(nin, nhid1, nhid2, nout, b, d, network, _xparams);
end;


procedure _core_mlpcreater0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_a := a;
        _d_b := b;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreater0(@_s_error_msg, @_d_nin, @_d_nout, @_d_a, @_d_b, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreater0 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreater0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreater0(nin, nout, a, b, network, _xparams);
end;


procedure _core_mlpcreater1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_a := a;
        _d_b := b;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreater1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_a, @_d_b, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreater1 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreater1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreater1(nin, nhid, nout, a, b, network, _xparams);
end;


procedure _core_mlpcreater2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_a := a;
        _d_b := b;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreater2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_a, @_d_b, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreater2 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreater2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreater2(nin, nhid1, nhid2, nout, a, b, network, _xparams);
end;


procedure _core_mlpcreatec0( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreatec0(@_s_error_msg, @_d_nin, @_d_nout, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreatec0 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreatec0( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreatec0(nin, nout, network, _xparams);
end;


procedure _core_mlpcreatec1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreatec1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreatec1 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreatec1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreatec1(nin, nhid, nout, network, _xparams);
end;


procedure _core_mlpcreatec2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_network := nil;
        network := nil;
        _error_code := x_xv2_mlpcreatec2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreatec2 call');
        end;
        network := Tmultilayerperceptron.Create(_d_network);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network<>nil) and (network=nil) then
            x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreatec2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger; out  network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcreatec2(nin, nhid1, nhid2, nout, network, _xparams);
end;


procedure _core_mlpcopy( network1: Tmultilayerperceptron; out  network2: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network1 : Pointer;
    _d_network2 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network1 := network1.ptr;
        _d_network2 := nil;
        network2 := nil;
        _error_code := x_xv2_mlpcopy(@_s_error_msg, @_d_network1, @_d_network2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcopy call');
        end;
        Assert(network1.ptr=_d_network1, 'ALGLIB: internal error (reference changed for non-out X-object)');
        network2 := Tmultilayerperceptron.Create(_d_network2);
    finally
        SetXExceptionMask(fpumask);
        if (_d_network2<>nil) and (network2=nil) then
            x_obj_free_multilayerperceptron(_d_network2); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcopy( network1: Tmultilayerperceptron; out  network2: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcopy(network1, network2, _xparams);
end;


procedure _core_mlpcopytunableparameters( network1: Tmultilayerperceptron;  network2: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network1 : Pointer;
    _d_network2 : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network1 := network1.ptr;
        _d_network2 := network2.ptr;
        _error_code := x_xv2_mlpcopytunableparameters(@_s_error_msg, @_d_network1, @_d_network2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcopytunableparameters call');
        end;
        Assert(network1.ptr=_d_network1, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(network2.ptr=_d_network2, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpcopytunableparameters( network1: Tmultilayerperceptron;  network2: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlpcopytunableparameters(network1, network2, _xparams);
end;


procedure _core_mlprandomize( network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlprandomize(@_s_error_msg, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlprandomize call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlprandomize( network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlprandomize(network, _xparams);
end;


procedure _core_mlprandomizefull( network: Tmultilayerperceptron; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlprandomizefull(@_s_error_msg, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlprandomizefull call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlprandomizefull( network: Tmultilayerperceptron; const _xparams: UInt64 = 0);
begin
    _core_mlprandomizefull(network, _xparams);
end;


procedure _core_mlpinitpreprocessor( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_ssize: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_ssize := ssize;
        _error_code := x_xv2_mlpinitpreprocessor(@_s_error_msg, @_d_network, @_d_xy, @_d_ssize, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpinitpreprocessor call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure mlpinitpreprocessor( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mlpinitpreprocessor(network, xy, ssize, _xparams);
end;


procedure _core_mlpproperties( network: Tmultilayerperceptron; out  nin: TALGLIBInteger; out  nout: TALGLIBInteger; out  wcount: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_wcount: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlpproperties(@_s_error_msg, @_d_network, @_d_nin, @_d_nout, @_d_wcount, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpproperties call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        nin := _d_nin;
        nout := _d_nout;
        wcount := _d_wcount;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpproperties( network: Tmultilayerperceptron; out  nin: TALGLIBInteger; out  nout: TALGLIBInteger; out  wcount: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mlpproperties(network, nin, nout, wcount, _xparams);
end;


function _core_mlpgetinputscount( network: Tmultilayerperceptron; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlpgetinputscount(@_s_error_msg, @_d_result, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetinputscount call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpgetinputscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_mlpgetinputscount(network, _xparams);
end;


function _core_mlpgetoutputscount( network: Tmultilayerperceptron; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlpgetoutputscount(@_s_error_msg, @_d_result, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetoutputscount call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpgetoutputscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_mlpgetoutputscount(network, _xparams);
end;


function _core_mlpgetweightscount( network: Tmultilayerperceptron; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlpgetweightscount(@_s_error_msg, @_d_result, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetweightscount call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpgetweightscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_mlpgetweightscount(network, _xparams);
end;


function _core_mlpissoftmax( network: Tmultilayerperceptron; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlpissoftmax(@_s_error_msg, @_d_result, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpissoftmax call');
        end;
        result := Byte2Bool(_d_result);
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpissoftmax( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_mlpissoftmax(network, _xparams);
end;


function _core_mlpgetlayerscount( network: Tmultilayerperceptron; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _error_code := x_xv2_mlpgetlayerscount(@_s_error_msg, @_d_result, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetlayerscount call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpgetlayerscount( network: Tmultilayerperceptron; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_mlpgetlayerscount(network, _xparams);
end;


function _core_mlpgetlayersize( network: Tmultilayerperceptron;  k: TALGLIBInteger; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_network : Pointer;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_k := k;
        _error_code := x_xv2_mlpgetlayersize(@_s_error_msg, @_d_result, @_d_network, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetlayersize call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpgetlayersize( network: Tmultilayerperceptron;  k: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_mlpgetlayersize(network, k, _xparams);
end;


procedure _core_mlpgetinputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger; out  mean: Double; out  sigma: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_i: NativeInt;
    _d_mean: Double;
    _d_sigma: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_i := i;
        _error_code := x_xv2_mlpgetinputscaling(@_s_error_msg, @_d_network, @_d_i, @_d_mean, @_d_sigma, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetinputscaling call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        mean := _d_mean;
        sigma := _d_sigma;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpgetinputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger; out  mean: Double; out  sigma: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpgetinputscaling(network, i, mean, sigma, _xparams);
end;


procedure _core_mlpgetoutputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger; out  mean: Double; out  sigma: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_i: NativeInt;
    _d_mean: Double;
    _d_sigma: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_i := i;
        _error_code := x_xv2_mlpgetoutputscaling(@_s_error_msg, @_d_network, @_d_i, @_d_mean, @_d_sigma, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetoutputscaling call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        mean := _d_mean;
        sigma := _d_sigma;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpgetoutputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger; out  mean: Double; out  sigma: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpgetoutputscaling(network, i, mean, sigma, _xparams);
end;


procedure _core_mlpgetneuroninfo( network: Tmultilayerperceptron;  k: TALGLIBInteger;  i: TALGLIBInteger; out  fkind: TALGLIBInteger; out  threshold: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_k: NativeInt;
    _d_i: NativeInt;
    _d_fkind: NativeInt;
    _d_threshold: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_k := k;
        _d_i := i;
        _error_code := x_xv2_mlpgetneuroninfo(@_s_error_msg, @_d_network, @_d_k, @_d_i, @_d_fkind, @_d_threshold, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetneuroninfo call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        fkind := _d_fkind;
        threshold := _d_threshold;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpgetneuroninfo( network: Tmultilayerperceptron;  k: TALGLIBInteger;  i: TALGLIBInteger; out  fkind: TALGLIBInteger; out  threshold: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpgetneuroninfo(network, k, i, fkind, threshold, _xparams);
end;


function _core_mlpgetweight( network: Tmultilayerperceptron;  k0: TALGLIBInteger;  i0: TALGLIBInteger;  k1: TALGLIBInteger;  i1: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_k0: NativeInt;
    _d_i0: NativeInt;
    _d_k1: NativeInt;
    _d_i1: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_k0 := k0;
        _d_i0 := i0;
        _d_k1 := k1;
        _d_i1 := i1;
        _error_code := x_xv2_mlpgetweight(@_s_error_msg, @_d_result, @_d_network, @_d_k0, @_d_i0, @_d_k1, @_d_i1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgetweight call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpgetweight( network: Tmultilayerperceptron;  k0: TALGLIBInteger;  i0: TALGLIBInteger;  k1: TALGLIBInteger;  i1: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpgetweight(network, k0, i0, k1, i1, _xparams);
end;


procedure _core_mlpsetinputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger;  mean: Double;  sigma: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_i: NativeInt;
    _d_mean: Double;
    _d_sigma: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_i := i;
        _d_mean := mean;
        _d_sigma := sigma;
        _error_code := x_xv2_mlpsetinputscaling(@_s_error_msg, @_d_network, @_d_i, @_d_mean, @_d_sigma, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetinputscaling call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetinputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger;  mean: Double;  sigma: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpsetinputscaling(network, i, mean, sigma, _xparams);
end;


procedure _core_mlpsetoutputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger;  mean: Double;  sigma: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_i: NativeInt;
    _d_mean: Double;
    _d_sigma: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_i := i;
        _d_mean := mean;
        _d_sigma := sigma;
        _error_code := x_xv2_mlpsetoutputscaling(@_s_error_msg, @_d_network, @_d_i, @_d_mean, @_d_sigma, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetoutputscaling call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetoutputscaling( network: Tmultilayerperceptron;  i: TALGLIBInteger;  mean: Double;  sigma: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpsetoutputscaling(network, i, mean, sigma, _xparams);
end;


procedure _core_mlpsetneuroninfo( network: Tmultilayerperceptron;  k: TALGLIBInteger;  i: TALGLIBInteger;  fkind: TALGLIBInteger;  threshold: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_k: NativeInt;
    _d_i: NativeInt;
    _d_fkind: NativeInt;
    _d_threshold: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_k := k;
        _d_i := i;
        _d_fkind := fkind;
        _d_threshold := threshold;
        _error_code := x_xv2_mlpsetneuroninfo(@_s_error_msg, @_d_network, @_d_k, @_d_i, @_d_fkind, @_d_threshold, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetneuroninfo call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetneuroninfo( network: Tmultilayerperceptron;  k: TALGLIBInteger;  i: TALGLIBInteger;  fkind: TALGLIBInteger;  threshold: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpsetneuroninfo(network, k, i, fkind, threshold, _xparams);
end;


procedure _core_mlpsetweight( network: Tmultilayerperceptron;  k0: TALGLIBInteger;  i0: TALGLIBInteger;  k1: TALGLIBInteger;  i1: TALGLIBInteger;  w: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_k0: NativeInt;
    _d_i0: NativeInt;
    _d_k1: NativeInt;
    _d_i1: NativeInt;
    _d_w: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_k0 := k0;
        _d_i0 := i0;
        _d_k1 := k1;
        _d_i1 := i1;
        _d_w := w;
        _error_code := x_xv2_mlpsetweight(@_s_error_msg, @_d_network, @_d_k0, @_d_i0, @_d_k1, @_d_i1, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetweight call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetweight( network: Tmultilayerperceptron;  k0: TALGLIBInteger;  i0: TALGLIBInteger;  k1: TALGLIBInteger;  i1: TALGLIBInteger;  w: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpsetweight(network, k0, i0, k1, i1, w, _xparams);
end;


procedure _core_mlpactivationfunction( net: Double;  k: TALGLIBInteger; out  f: Double; out  df: Double; out  d2f: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_net: Double;
    _d_k: NativeInt;
    _d_f: Double;
    _d_df: Double;
    _d_d2f: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_net := net;
        _d_k := k;
        _error_code := x_xv2_mlpactivationfunction(@_s_error_msg, @_d_net, @_d_k, @_d_f, @_d_df, @_d_d2f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpactivationfunction call');
        end;
        f := _d_f;
        df := _d_df;
        d2f := _d_d2f;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpactivationfunction( net: Double;  k: TALGLIBInteger; out  f: Double; out  df: Double; out  d2f: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpactivationfunction(net, k, f, df, d2f, _xparams);
end;


procedure _core_mlpprocess( network: Tmultilayerperceptron;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_mlpprocess(@_s_error_msg, @_d_network, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpprocess call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure mlpprocess( network: Tmultilayerperceptron;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpprocess(network, x, y, _xparams);
end;


procedure _core_mlpprocessi( network: Tmultilayerperceptron;  x: TVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_mlpprocessi(@_s_error_msg, @_d_network, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpprocessi call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure mlpprocessi( network: Tmultilayerperceptron;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpprocessi(network, x, y, _xparams);
end;


function _core_mlperror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlperror(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlperror call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlperror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlperror(network, xy, npoints, _xparams);
end;


function _core_mlperrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_npoints := npoints;
        _error_code := x_xv2_mlperrorsparse(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlperrorsparse call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlperrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlperrorsparse(network, xy, npoints, _xparams);
end;


function _core_mlperrorn( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_ssize: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_ssize := ssize;
        _error_code := x_xv2_mlperrorn(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_ssize, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlperrorn call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlperrorn( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlperrorn(network, xy, ssize, _xparams);
end;


function _core_mlpclserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpclserror(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpclserror call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpclserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_mlpclserror(network, xy, npoints, _xparams);
end;


function _core_mlprelclserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlprelclserror(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlprelclserror call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlprelclserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlprelclserror(network, xy, npoints, _xparams);
end;


function _core_mlprelclserrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_npoints := npoints;
        _error_code := x_xv2_mlprelclserrorsparse(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlprelclserrorsparse call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlprelclserrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlprelclserrorsparse(network, xy, npoints, _xparams);
end;


function _core_mlpavgce( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpavgce(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpavgce call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpavgce( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpavgce(network, xy, npoints, _xparams);
end;


function _core_mlpavgcesparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_npoints := npoints;
        _error_code := x_xv2_mlpavgcesparse(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpavgcesparse call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpavgcesparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpavgcesparse(network, xy, npoints, _xparams);
end;


function _core_mlprmserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlprmserror(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlprmserror call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlprmserror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlprmserror(network, xy, npoints, _xparams);
end;


function _core_mlprmserrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_npoints := npoints;
        _error_code := x_xv2_mlprmserrorsparse(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlprmserrorsparse call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlprmserrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlprmserrorsparse(network, xy, npoints, _xparams);
end;


function _core_mlpavgerror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpavgerror(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpavgerror call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpavgerror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpavgerror(network, xy, npoints, _xparams);
end;


function _core_mlpavgerrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_npoints := npoints;
        _error_code := x_xv2_mlpavgerrorsparse(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpavgerrorsparse call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpavgerrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpavgerrorsparse(network, xy, npoints, _xparams);
end;


function _core_mlpavgrelerror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpavgrelerror(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpavgrelerror call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpavgrelerror( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpavgrelerror(network, xy, npoints, _xparams);
end;


function _core_mlpavgrelerrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_npoints := npoints;
        _error_code := x_xv2_mlpavgrelerrorsparse(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpavgrelerrorsparse call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpavgrelerrorsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpavgrelerrorsparse(network, xy, npoints, _xparams);
end;


procedure _core_mlpgrad( network: Tmultilayerperceptron;  x: TVector;  desiredy: TVector; out  e: Double; var  grad: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_x: x_vector;
    _d_desiredy: x_vector;
    _d_e: Double;
    _d_grad: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_desiredy, desiredy, X_CREATE);
        x_from_array(_d_grad, grad, X_CREATE);
        _error_code := x_xv2_mlpgrad(@_s_error_msg, @_d_network, @_d_x, @_d_desiredy, @_d_e, @_d_grad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgrad call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_desiredy);
        x_clear(_d_grad);
    end;
end;


procedure mlpgrad( network: Tmultilayerperceptron;  x: TVector;  desiredy: TVector; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpgrad(network, x, desiredy, e, grad, _xparams);
end;


procedure _core_mlpgradn( network: Tmultilayerperceptron;  x: TVector;  desiredy: TVector; out  e: Double; var  grad: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_x: x_vector;
    _d_desiredy: x_vector;
    _d_e: Double;
    _d_grad: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_desiredy, desiredy, X_CREATE);
        x_from_array(_d_grad, grad, X_CREATE);
        _error_code := x_xv2_mlpgradn(@_s_error_msg, @_d_network, @_d_x, @_d_desiredy, @_d_e, @_d_grad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgradn call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_desiredy);
        x_clear(_d_grad);
    end;
end;


procedure mlpgradn( network: Tmultilayerperceptron;  x: TVector;  desiredy: TVector; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpgradn(network, x, desiredy, e, grad, _xparams);
end;


procedure _core_mlpgradbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_ssize: NativeInt;
    _d_e: Double;
    _d_grad: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_ssize := ssize;
        x_from_array(_d_grad, grad, X_CREATE);
        _error_code := x_xv2_mlpgradbatch(@_s_error_msg, @_d_network, @_d_xy, @_d_ssize, @_d_e, @_d_grad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgradbatch call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_grad);
    end;
end;


procedure mlpgradbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpgradbatch(network, xy, ssize, e, grad, _xparams);
end;


procedure _core_mlpgradbatchsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_ssize: NativeInt;
    _d_e: Double;
    _d_grad: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_ssize := ssize;
        x_from_array(_d_grad, grad, X_CREATE);
        _error_code := x_xv2_mlpgradbatchsparse(@_s_error_msg, @_d_network, @_d_xy, @_d_ssize, @_d_e, @_d_grad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgradbatchsparse call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_grad);
    end;
end;


procedure mlpgradbatchsparse( network: Tmultilayerperceptron;  xy: Tsparsematrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpgradbatchsparse(network, xy, ssize, e, grad, _xparams);
end;


procedure _core_mlpgradbatchsubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  idx: TIVector;  subsetsize: TALGLIBInteger; out  e: Double; var  grad: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_setsize: NativeInt;
    _d_idx: x_vector;
    _d_subsetsize: NativeInt;
    _d_e: Double;
    _d_grad: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_setsize := setsize;
        x_from_array(_d_idx, idx, X_CREATE);
        _d_subsetsize := subsetsize;
        x_from_array(_d_grad, grad, X_CREATE);
        _error_code := x_xv2_mlpgradbatchsubset(@_s_error_msg, @_d_network, @_d_xy, @_d_setsize, @_d_idx, @_d_subsetsize, @_d_e, @_d_grad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgradbatchsubset call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_idx);
        x_clear(_d_grad);
    end;
end;


procedure mlpgradbatchsubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  idx: TIVector;  subsetsize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpgradbatchsubset(network, xy, setsize, idx, subsetsize, e, grad, _xparams);
end;


procedure _core_mlpgradbatchsparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  idx: TIVector;  subsetsize: TALGLIBInteger; out  e: Double; var  grad: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_setsize: NativeInt;
    _d_idx: x_vector;
    _d_subsetsize: NativeInt;
    _d_e: Double;
    _d_grad: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_setsize := setsize;
        x_from_array(_d_idx, idx, X_CREATE);
        _d_subsetsize := subsetsize;
        x_from_array(_d_grad, grad, X_CREATE);
        _error_code := x_xv2_mlpgradbatchsparsesubset(@_s_error_msg, @_d_network, @_d_xy, @_d_setsize, @_d_idx, @_d_subsetsize, @_d_e, @_d_grad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgradbatchsparsesubset call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_idx);
        x_clear(_d_grad);
    end;
end;


procedure mlpgradbatchsparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  idx: TIVector;  subsetsize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpgradbatchsparsesubset(network, xy, setsize, idx, subsetsize, e, grad, _xparams);
end;


procedure _core_mlpgradnbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_ssize: NativeInt;
    _d_e: Double;
    _d_grad: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_ssize := ssize;
        x_from_array(_d_grad, grad, X_CREATE);
        _error_code := x_xv2_mlpgradnbatch(@_s_error_msg, @_d_network, @_d_xy, @_d_ssize, @_d_e, @_d_grad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpgradnbatch call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_grad);
    end;
end;


procedure mlpgradnbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpgradnbatch(network, xy, ssize, e, grad, _xparams);
end;


procedure _core_mlphessiannbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; var  h: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_ssize: NativeInt;
    _d_e: Double;
    _d_grad: x_vector;
    _d_h: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_ssize := ssize;
        x_from_array(_d_grad, grad, X_CREATE);
        x_from_array(_d_h, h, X_CREATE);
        _error_code := x_xv2_mlphessiannbatch(@_s_error_msg, @_d_network, @_d_xy, @_d_ssize, @_d_e, @_d_grad, @_d_h, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlphessiannbatch call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
        x_to_array(_d_h, h);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_grad);
        x_clear(_d_h);
    end;
end;


procedure mlphessiannbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; var  h: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_mlphessiannbatch(network, xy, ssize, e, grad, h, _xparams);
end;


procedure _core_mlphessianbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; var  h: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_ssize: NativeInt;
    _d_e: Double;
    _d_grad: x_vector;
    _d_h: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_ssize := ssize;
        x_from_array(_d_grad, grad, X_CREATE);
        x_from_array(_d_h, h, X_CREATE);
        _error_code := x_xv2_mlphessianbatch(@_s_error_msg, @_d_network, @_d_xy, @_d_ssize, @_d_e, @_d_grad, @_d_h, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlphessianbatch call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        e := _d_e;
        x_to_array(_d_grad, grad);
        x_to_array(_d_h, h);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_grad);
        x_clear(_d_h);
    end;
end;


procedure mlphessianbatch( network: Tmultilayerperceptron;  xy: TMatrix;  ssize: TALGLIBInteger; out  e: Double; var  grad: TVector; var  h: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_mlphessianbatch(network, xy, ssize, e, grad, h, _xparams);
end;


procedure _core_mlpallerrorssubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; out  rep: Tmodelerrors; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_setsize: NativeInt;
    _d_subset: x_vector;
    _d_subsetsize: NativeInt;
    _d_rep: x_modelerrors;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_setsize := setsize;
        x_from_array(_d_subset, subset, X_CREATE);
        _d_subsetsize := subsetsize;
        x_modelerrors_init(_d_rep);
        _error_code := x_xv2_mlpallerrorssubset(@_s_error_msg, @_d_network, @_d_xy, @_d_setsize, @_d_subset, @_d_subsetsize, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpallerrorssubset call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_modelerrors_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_subset);
        x_modelerrors_clear(_d_rep);
    end;
end;


procedure mlpallerrorssubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; out  rep: Tmodelerrors; const _xparams: UInt64 = 0);
begin
    _core_mlpallerrorssubset(network, xy, setsize, subset, subsetsize, rep, _xparams);
end;


procedure _core_mlpallerrorssparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; out  rep: Tmodelerrors; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_setsize: NativeInt;
    _d_subset: x_vector;
    _d_subsetsize: NativeInt;
    _d_rep: x_modelerrors;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_setsize := setsize;
        x_from_array(_d_subset, subset, X_CREATE);
        _d_subsetsize := subsetsize;
        x_modelerrors_init(_d_rep);
        _error_code := x_xv2_mlpallerrorssparsesubset(@_s_error_msg, @_d_network, @_d_xy, @_d_setsize, @_d_subset, @_d_subsetsize, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpallerrorssparsesubset call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_modelerrors_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_subset);
        x_modelerrors_clear(_d_rep);
    end;
end;


procedure mlpallerrorssparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; out  rep: Tmodelerrors; const _xparams: UInt64 = 0);
begin
    _core_mlpallerrorssparsesubset(network, xy, setsize, subset, subsetsize, rep, _xparams);
end;


function _core_mlperrorsubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_setsize: NativeInt;
    _d_subset: x_vector;
    _d_subsetsize: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_setsize := setsize;
        x_from_array(_d_subset, subset, X_CREATE);
        _d_subsetsize := subsetsize;
        _error_code := x_xv2_mlperrorsubset(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_setsize, @_d_subset, @_d_subsetsize, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlperrorsubset call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_subset);
    end;
end;


function mlperrorsubset( network: Tmultilayerperceptron;  xy: TMatrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlperrorsubset(network, xy, setsize, subset, subsetsize, _xparams);
end;


function _core_mlperrorsparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_network : Pointer;
    _d_xy : Pointer;
    _d_setsize: NativeInt;
    _d_subset: x_vector;
    _d_subsetsize: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_xy := xy.ptr;
        _d_setsize := setsize;
        x_from_array(_d_subset, subset, X_CREATE);
        _d_subsetsize := subsetsize;
        _error_code := x_xv2_mlperrorsparsesubset(@_s_error_msg, @_d_result, @_d_network, @_d_xy, @_d_setsize, @_d_subset, @_d_subsetsize, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlperrorsparsesubset call');
        end;
        result := _d_result;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_subset);
    end;
end;


function mlperrorsparsesubset( network: Tmultilayerperceptron;  xy: Tsparsematrix;  setsize: TALGLIBInteger;  subset: TIVector;  subsetsize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlperrorsparsesubset(network, xy, setsize, subset, subsetsize, _xparams);
end;


procedure _core_fisherlda( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
    _d_info: NativeInt;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_fisherlda(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_nclasses, @_d_info, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fisherlda call');
        end;
        info := _d_info;
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_w);
    end;
end;


procedure fisherlda( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_fisherlda(xy, npoints, nvars, nclasses, info, w, _xparams);
end;


procedure _core_fisherldan( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  w: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
    _d_info: NativeInt;
    _d_w: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_fisherldan(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_nclasses, @_d_info, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fisherldan call');
        end;
        info := _d_info;
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_w);
    end;
end;


procedure fisherldan( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  w: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_fisherldan(xy, npoints, nvars, nclasses, info, w, _xparams);
end;

constructor Tssamodel.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tssamodel.Destroy();
begin
    Deallocate();
end;

function Tssamodel.Clone():Tssamodel;
begin
    if ptr=nil then
        Result:=Tssamodel.Create(nil)
    else
        Result:=Tssamodel.Create(x_obj_copy_ssamodel(ptr));
end;

procedure Tssamodel.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_ssamodel(ptr);
    ptr:=nil;
end;


procedure _core_ssacreate(out  s: Tssamodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_ssacreate(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssacreate call');
        end;
        s := Tssamodel.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_ssamodel(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure ssacreate(out  s: Tssamodel; const _xparams: UInt64 = 0);
begin
    _core_ssacreate(s, _xparams);
end;


procedure _core_ssasetwindow( s: Tssamodel;  windowwidth: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_windowwidth: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_windowwidth := windowwidth;
        _error_code := x_xv2_ssasetwindow(@_s_error_msg, @_d_s, @_d_windowwidth, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssasetwindow call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssasetwindow( s: Tssamodel;  windowwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssasetwindow(s, windowwidth, _xparams);
end;


procedure _core_ssasetseed( s: Tssamodel;  seed: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_seed: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_seed := seed;
        _error_code := x_xv2_ssasetseed(@_s_error_msg, @_d_s, @_d_seed, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssasetseed call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssasetseed( s: Tssamodel;  seed: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssasetseed(s, seed, _xparams);
end;


procedure _core_ssasetpoweruplength( s: Tssamodel;  pwlen: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_pwlen: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_pwlen := pwlen;
        _error_code := x_xv2_ssasetpoweruplength(@_s_error_msg, @_d_s, @_d_pwlen, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssasetpoweruplength call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssasetpoweruplength( s: Tssamodel;  pwlen: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssasetpoweruplength(s, pwlen, _xparams);
end;


procedure _core_ssasetmemorylimit( s: Tssamodel;  memlimit: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_memlimit: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_memlimit := memlimit;
        _error_code := x_xv2_ssasetmemorylimit(@_s_error_msg, @_d_s, @_d_memlimit, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssasetmemorylimit call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssasetmemorylimit( s: Tssamodel;  memlimit: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssasetmemorylimit(s, memlimit, _xparams);
end;


procedure _core_ssaaddsequence( s: Tssamodel;  x: TVector;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_ssaaddsequence(@_s_error_msg, @_d_s, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaaddsequence call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure ssaaddsequence( s: Tssamodel;  x: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_ssaaddsequence(s, x, n, _xparams);
end;


procedure ssaaddsequence( s: Tssamodel;  x: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_ssaaddsequence(s, x, n, _xparams);

end;


procedure _core_ssaappendpointandupdate( s: Tssamodel;  x: Double;  updateits: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: Double;
    _d_updateits: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_x := x;
        _d_updateits := updateits;
        _error_code := x_xv2_ssaappendpointandupdate(@_s_error_msg, @_d_s, @_d_x, @_d_updateits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaappendpointandupdate call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssaappendpointandupdate( s: Tssamodel;  x: Double;  updateits: Double; const _xparams: UInt64 = 0);
begin
    _core_ssaappendpointandupdate(s, x, updateits, _xparams);
end;


procedure _core_ssaappendsequenceandupdate( s: Tssamodel;  x: TVector;  nticks: TALGLIBInteger;  updateits: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_nticks: NativeInt;
    _d_updateits: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _d_nticks := nticks;
        _d_updateits := updateits;
        _error_code := x_xv2_ssaappendsequenceandupdate(@_s_error_msg, @_d_s, @_d_x, @_d_nticks, @_d_updateits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaappendsequenceandupdate call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure ssaappendsequenceandupdate( s: Tssamodel;  x: TVector;  nticks: TALGLIBInteger;  updateits: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_ssaappendsequenceandupdate(s, x, nticks, updateits, _xparams);
end;


procedure ssaappendsequenceandupdate( s: Tssamodel;  x: TVector;  updateits: Double; const _xparams: UInt64 = 0);overload;
var
    nticks: TALGLIBInteger;

begin

    nticks := xlen(x);

    _core_ssaappendsequenceandupdate(s, x, nticks, updateits, _xparams);

end;


procedure _core_ssasetalgoprecomputed( s: Tssamodel;  a: TMatrix;  windowwidth: TALGLIBInteger;  nbasis: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_a: x_matrix;
    _d_windowwidth: NativeInt;
    _d_nbasis: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_a, a, X_CREATE);
        _d_windowwidth := windowwidth;
        _d_nbasis := nbasis;
        _error_code := x_xv2_ssasetalgoprecomputed(@_s_error_msg, @_d_s, @_d_a, @_d_windowwidth, @_d_nbasis, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssasetalgoprecomputed call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure ssasetalgoprecomputed( s: Tssamodel;  a: TMatrix;  windowwidth: TALGLIBInteger;  nbasis: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_ssasetalgoprecomputed(s, a, windowwidth, nbasis, _xparams);
end;


procedure ssasetalgoprecomputed( s: Tssamodel;  a: TMatrix; const _xparams: UInt64 = 0);overload;
var
    windowwidth: TALGLIBInteger;
    nbasis: TALGLIBInteger;

begin

    windowwidth := xrows(a);
    nbasis := xcols(a);

    _core_ssasetalgoprecomputed(s, a, windowwidth, nbasis, _xparams);

end;


procedure _core_ssasetalgotopkdirect( s: Tssamodel;  topk: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_topk: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_topk := topk;
        _error_code := x_xv2_ssasetalgotopkdirect(@_s_error_msg, @_d_s, @_d_topk, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssasetalgotopkdirect call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssasetalgotopkdirect( s: Tssamodel;  topk: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssasetalgotopkdirect(s, topk, _xparams);
end;


procedure _core_ssasetalgotopkrealtime( s: Tssamodel;  topk: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_topk: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_topk := topk;
        _error_code := x_xv2_ssasetalgotopkrealtime(@_s_error_msg, @_d_s, @_d_topk, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssasetalgotopkrealtime call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssasetalgotopkrealtime( s: Tssamodel;  topk: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssasetalgotopkrealtime(s, topk, _xparams);
end;


procedure _core_ssacleardata( s: Tssamodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_ssacleardata(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssacleardata call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure ssacleardata( s: Tssamodel; const _xparams: UInt64 = 0);
begin
    _core_ssacleardata(s, _xparams);
end;


procedure _core_ssagetbasis( s: Tssamodel; out  a: TMatrix; out  sv: TVector; out  windowwidth: TALGLIBInteger; out  nbasis: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_a: x_matrix;
    _d_sv: x_vector;
    _d_windowwidth: NativeInt;
    _d_nbasis: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        x_create_empty(_d_sv, DT_REAL);
        sv := nil;
        _error_code := x_xv2_ssagetbasis(@_s_error_msg, @_d_s, @_d_a, @_d_sv, @_d_windowwidth, @_d_nbasis, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssagetbasis call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_a, a);
        x_to_array(_d_sv, sv);
        windowwidth := _d_windowwidth;
        nbasis := _d_nbasis;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_sv);
    end;
end;


procedure ssagetbasis( s: Tssamodel; out  a: TMatrix; out  sv: TVector; out  windowwidth: TALGLIBInteger; out  nbasis: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssagetbasis(s, a, sv, windowwidth, nbasis, _xparams);
end;


procedure _core_ssagetlrr( s: Tssamodel; out  a: TVector; out  windowwidth: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_a: x_vector;
    _d_windowwidth: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_ssagetlrr(@_s_error_msg, @_d_s, @_d_a, @_d_windowwidth, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssagetlrr call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_a, a);
        windowwidth := _d_windowwidth;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure ssagetlrr( s: Tssamodel; out  a: TVector; out  windowwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssagetlrr(s, a, windowwidth, _xparams);
end;


procedure _core_ssaanalyzelastwindow( s: Tssamodel; out  trend: TVector; out  noise: TVector; out  nticks: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_trend: x_vector;
    _d_noise: x_vector;
    _d_nticks: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_create_empty(_d_trend, DT_REAL);
        trend := nil;
        x_create_empty(_d_noise, DT_REAL);
        noise := nil;
        _error_code := x_xv2_ssaanalyzelastwindow(@_s_error_msg, @_d_s, @_d_trend, @_d_noise, @_d_nticks, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaanalyzelastwindow call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_trend, trend);
        x_to_array(_d_noise, noise);
        nticks := _d_nticks;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_trend);
        x_clear(_d_noise);
    end;
end;


procedure ssaanalyzelastwindow( s: Tssamodel; out  trend: TVector; out  noise: TVector; out  nticks: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_ssaanalyzelastwindow(s, trend, noise, nticks, _xparams);
end;


procedure _core_ssaanalyzelast( s: Tssamodel;  nticks: TALGLIBInteger; out  trend: TVector; out  noise: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_nticks: NativeInt;
    _d_trend: x_vector;
    _d_noise: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_nticks := nticks;
        x_create_empty(_d_trend, DT_REAL);
        trend := nil;
        x_create_empty(_d_noise, DT_REAL);
        noise := nil;
        _error_code := x_xv2_ssaanalyzelast(@_s_error_msg, @_d_s, @_d_nticks, @_d_trend, @_d_noise, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaanalyzelast call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_trend, trend);
        x_to_array(_d_noise, noise);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_trend);
        x_clear(_d_noise);
    end;
end;


procedure ssaanalyzelast( s: Tssamodel;  nticks: TALGLIBInteger; out  trend: TVector; out  noise: TVector; const _xparams: UInt64 = 0);
begin
    _core_ssaanalyzelast(s, nticks, trend, noise, _xparams);
end;


procedure _core_ssaanalyzesequence( s: Tssamodel;  data: TVector;  nticks: TALGLIBInteger; out  trend: TVector; out  noise: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_data: x_vector;
    _d_nticks: NativeInt;
    _d_trend: x_vector;
    _d_noise: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_data, data, X_CREATE);
        _d_nticks := nticks;
        x_create_empty(_d_trend, DT_REAL);
        trend := nil;
        x_create_empty(_d_noise, DT_REAL);
        noise := nil;
        _error_code := x_xv2_ssaanalyzesequence(@_s_error_msg, @_d_s, @_d_data, @_d_nticks, @_d_trend, @_d_noise, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaanalyzesequence call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_trend, trend);
        x_to_array(_d_noise, noise);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_data);
        x_clear(_d_trend);
        x_clear(_d_noise);
    end;
end;


procedure ssaanalyzesequence( s: Tssamodel;  data: TVector;  nticks: TALGLIBInteger; out  trend: TVector; out  noise: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_ssaanalyzesequence(s, data, nticks, trend, noise, _xparams);
end;


procedure ssaanalyzesequence( s: Tssamodel;  data: TVector; out  trend: TVector; out  noise: TVector; const _xparams: UInt64 = 0);overload;
var
    nticks: TALGLIBInteger;

begin

    nticks := xlen(data);

    _core_ssaanalyzesequence(s, data, nticks, trend, noise, _xparams);

end;


procedure _core_ssaforecastlast( s: Tssamodel;  nticks: TALGLIBInteger; out  trend: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_nticks: NativeInt;
    _d_trend: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_nticks := nticks;
        x_create_empty(_d_trend, DT_REAL);
        trend := nil;
        _error_code := x_xv2_ssaforecastlast(@_s_error_msg, @_d_s, @_d_nticks, @_d_trend, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaforecastlast call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_trend, trend);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_trend);
    end;
end;


procedure ssaforecastlast( s: Tssamodel;  nticks: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);
begin
    _core_ssaforecastlast(s, nticks, trend, _xparams);
end;


procedure _core_ssaforecastsequence( s: Tssamodel;  data: TVector;  datalen: TALGLIBInteger;  forecastlen: TALGLIBInteger;  applysmoothing: Boolean; out  trend: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_data: x_vector;
    _d_datalen: NativeInt;
    _d_forecastlen: NativeInt;
    _d_applysmoothing: Byte;
    _d_trend: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_data, data, X_CREATE);
        _d_datalen := datalen;
        _d_forecastlen := forecastlen;
        _d_applysmoothing := Bool2Byte(applysmoothing);
        x_create_empty(_d_trend, DT_REAL);
        trend := nil;
        _error_code := x_xv2_ssaforecastsequence(@_s_error_msg, @_d_s, @_d_data, @_d_datalen, @_d_forecastlen, @_d_applysmoothing, @_d_trend, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaforecastsequence call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_trend, trend);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_data);
        x_clear(_d_trend);
    end;
end;


procedure ssaforecastsequence( s: Tssamodel;  data: TVector;  datalen: TALGLIBInteger;  forecastlen: TALGLIBInteger;  applysmoothing: Boolean; out  trend: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_ssaforecastsequence(s, data, datalen, forecastlen, applysmoothing, trend, _xparams);
end;


procedure ssaforecastsequence( s: Tssamodel;  data: TVector;  forecastlen: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);overload;
var
    datalen: TALGLIBInteger;
    applysmoothing: Boolean;

begin

    datalen := xlen(data);
    applysmoothing := True;

    _core_ssaforecastsequence(s, data, datalen, forecastlen, applysmoothing, trend, _xparams);

end;


procedure _core_ssaforecastavglast( s: Tssamodel;  m: TALGLIBInteger;  nticks: TALGLIBInteger; out  trend: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_m: NativeInt;
    _d_nticks: NativeInt;
    _d_trend: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_m := m;
        _d_nticks := nticks;
        x_create_empty(_d_trend, DT_REAL);
        trend := nil;
        _error_code := x_xv2_ssaforecastavglast(@_s_error_msg, @_d_s, @_d_m, @_d_nticks, @_d_trend, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaforecastavglast call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_trend, trend);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_trend);
    end;
end;


procedure ssaforecastavglast( s: Tssamodel;  m: TALGLIBInteger;  nticks: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);
begin
    _core_ssaforecastavglast(s, m, nticks, trend, _xparams);
end;


procedure _core_ssaforecastavgsequence( s: Tssamodel;  data: TVector;  datalen: TALGLIBInteger;  m: TALGLIBInteger;  forecastlen: TALGLIBInteger;  applysmoothing: Boolean; out  trend: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_data: x_vector;
    _d_datalen: NativeInt;
    _d_m: NativeInt;
    _d_forecastlen: NativeInt;
    _d_applysmoothing: Byte;
    _d_trend: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_data, data, X_CREATE);
        _d_datalen := datalen;
        _d_m := m;
        _d_forecastlen := forecastlen;
        _d_applysmoothing := Bool2Byte(applysmoothing);
        x_create_empty(_d_trend, DT_REAL);
        trend := nil;
        _error_code := x_xv2_ssaforecastavgsequence(@_s_error_msg, @_d_s, @_d_data, @_d_datalen, @_d_m, @_d_forecastlen, @_d_applysmoothing, @_d_trend, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ssaforecastavgsequence call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_trend, trend);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_data);
        x_clear(_d_trend);
    end;
end;


procedure ssaforecastavgsequence( s: Tssamodel;  data: TVector;  datalen: TALGLIBInteger;  m: TALGLIBInteger;  forecastlen: TALGLIBInteger;  applysmoothing: Boolean; out  trend: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_ssaforecastavgsequence(s, data, datalen, m, forecastlen, applysmoothing, trend, _xparams);
end;


procedure ssaforecastavgsequence( s: Tssamodel;  data: TVector;  m: TALGLIBInteger;  forecastlen: TALGLIBInteger; out  trend: TVector; const _xparams: UInt64 = 0);overload;
var
    datalen: TALGLIBInteger;
    applysmoothing: Boolean;

begin

    datalen := xlen(data);
    applysmoothing := True;

    _core_ssaforecastavgsequence(s, data, datalen, m, forecastlen, applysmoothing, trend, _xparams);

end;


function _core_gammafunction( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_gammafunction(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gammafunction call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function gammafunction( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_gammafunction(x, _xparams);
end;


function _core_lngamma( x: Double; out  sgngam: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
    _d_sgngam: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_lngamma(@_s_error_msg, @_d_result, @_d_x, @_d_sgngam, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lngamma call');
        end;
        result := _d_result;
        sgngam := _d_sgngam;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function lngamma( x: Double; out  sgngam: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_lngamma(x, sgngam, _xparams);
end;


function _core_errorfunction( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_errorfunction(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during errorfunction call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function errorfunction( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_errorfunction(x, _xparams);
end;


function _core_errorfunctionc( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_errorfunctionc(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during errorfunctionc call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function errorfunctionc( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_errorfunctionc(x, _xparams);
end;


function _core_normaldistribution( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_normaldistribution(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during normaldistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function normaldistribution( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_normaldistribution(x, _xparams);
end;


function _core_normalpdf( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_normalpdf(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during normalpdf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function normalpdf( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_normalpdf(x, _xparams);
end;


function _core_normalcdf( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_normalcdf(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during normalcdf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function normalcdf( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_normalcdf(x, _xparams);
end;


function _core_inverf( e: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_e: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_e := e;
        _error_code := x_xv2_inverf(@_s_error_msg, @_d_result, @_d_e, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during inverf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function inverf( e: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_inverf(e, _xparams);
end;


function _core_invnormaldistribution( y0: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_y0: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_y0 := y0;
        _error_code := x_xv2_invnormaldistribution(@_s_error_msg, @_d_result, @_d_y0, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invnormaldistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invnormaldistribution( y0: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invnormaldistribution(y0, _xparams);
end;


function _core_invnormalcdf( y0: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_y0: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_y0 := y0;
        _error_code := x_xv2_invnormalcdf(@_s_error_msg, @_d_result, @_d_y0, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invnormalcdf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invnormalcdf( y0: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invnormalcdf(y0, _xparams);
end;


function _core_bivariatenormalpdf( x: Double;  y: Double;  rho: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
    _d_y: Double;
    _d_rho: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _d_y := y;
        _d_rho := rho;
        _error_code := x_xv2_bivariatenormalpdf(@_s_error_msg, @_d_result, @_d_x, @_d_y, @_d_rho, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during bivariatenormalpdf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function bivariatenormalpdf( x: Double;  y: Double;  rho: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_bivariatenormalpdf(x, y, rho, _xparams);
end;


function _core_bivariatenormalcdf( x: Double;  y: Double;  rho: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
    _d_y: Double;
    _d_rho: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _d_y := y;
        _d_rho := rho;
        _error_code := x_xv2_bivariatenormalcdf(@_s_error_msg, @_d_result, @_d_x, @_d_y, @_d_rho, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during bivariatenormalcdf call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function bivariatenormalcdf( x: Double;  y: Double;  rho: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_bivariatenormalcdf(x, y, rho, _xparams);
end;


function _core_incompletegamma( a: Double;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_x := x;
        _error_code := x_xv2_incompletegamma(@_s_error_msg, @_d_result, @_d_a, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during incompletegamma call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function incompletegamma( a: Double;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_incompletegamma(a, x, _xparams);
end;


function _core_incompletegammac( a: Double;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_x := x;
        _error_code := x_xv2_incompletegammac(@_s_error_msg, @_d_result, @_d_a, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during incompletegammac call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function incompletegammac( a: Double;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_incompletegammac(a, x, _xparams);
end;


function _core_invincompletegammac( a: Double;  y0: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_y0: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_y0 := y0;
        _error_code := x_xv2_invincompletegammac(@_s_error_msg, @_d_result, @_d_a, @_d_y0, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invincompletegammac call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invincompletegammac( a: Double;  y0: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invincompletegammac(a, y0, _xparams);
end;

constructor Tlinearmodel.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tlinearmodel.Destroy();
begin
    Deallocate();
end;

function Tlinearmodel.Clone():Tlinearmodel;
begin
    if ptr=nil then
        Result:=Tlinearmodel.Create(nil)
    else
        Result:=Tlinearmodel.Create(x_obj_copy_linearmodel(ptr));
end;

procedure Tlinearmodel.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_linearmodel(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tlrreport):Tlrreport;overload;
begin
    Result.c := Clone(src.c);
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
    Result.cvrmserror := src.cvrmserror;
    Result.cvavgerror := src.cvavgerror;
    Result.cvavgrelerror := src.cvavgrelerror;
    Result.ncvdefects := src.ncvdefects;
    Result.cvdefects := Clone(src.cvdefects);
end;

procedure x_lrreport_init(var x: x_lrreport);
begin
    x_create_empty(x.c, DT_REAL);
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
    x.cvrmserror := 0;
    x.cvavgerror := 0;
    x.cvavgrelerror := 0;
    x.ncvdefects.longval := 0;
    x_create_empty(x.cvdefects, DT_INT);
end;

procedure x_lrreport_clear(var x: x_lrreport);
begin
    x_clear(x.c);
    x_clear(x.cvdefects);
end;

procedure x_lrreport_init_from(var x: x_lrreport; const v: Tlrreport);
begin
    x_from_array(x.c, v.c, X_CREATE);
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
    x.cvrmserror := v.cvrmserror;
    x.cvavgerror := v.cvavgerror;
    x.cvavgrelerror := v.cvavgrelerror;
    x.ncvdefects.longval := v.ncvdefects;
    x_from_array(x.cvdefects, v.cvdefects, X_CREATE);
end;

procedure x_lrreport_to_record(const x: x_lrreport; var v: Tlrreport);
begin
    x_to_array(x.c, v.c);
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
    v.cvrmserror := x.cvrmserror;
    v.cvavgerror := x.cvavgerror;
    v.cvavgrelerror := x.cvavgrelerror;
    v.ncvdefects := x.ncvdefects.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.cvdefects, v.cvdefects);
end;


procedure _core_lrbuild( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_info: NativeInt;
    _d_lm : Pointer;
    _d_ar: x_lrreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_lm := nil;
        lm := nil;
        x_lrreport_init(_d_ar);
        _error_code := x_xv2_lrbuild(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_info, @_d_lm, @_d_ar, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrbuild call');
        end;
        info := _d_info;
        lm := Tlinearmodel.Create(_d_lm);
        x_lrreport_to_record(_d_ar, ar);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_lm<>nil) and (lm=nil) then
            x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to Delphi objects
        x_lrreport_clear(_d_ar);
    end;
end;


procedure lrbuild( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
begin
    _core_lrbuild(xy, npoints, nvars, info, lm, ar, _xparams);
end;


procedure _core_lrbuilds( xy: TMatrix;  s: TVector;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_s: x_vector;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_info: NativeInt;
    _d_lm : Pointer;
    _d_ar: x_lrreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        x_from_array(_d_s, s, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_lm := nil;
        lm := nil;
        x_lrreport_init(_d_ar);
        _error_code := x_xv2_lrbuilds(@_s_error_msg, @_d_xy, @_d_s, @_d_npoints, @_d_nvars, @_d_info, @_d_lm, @_d_ar, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrbuilds call');
        end;
        info := _d_info;
        lm := Tlinearmodel.Create(_d_lm);
        x_lrreport_to_record(_d_ar, ar);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_s);
        if (_d_lm<>nil) and (lm=nil) then
            x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to Delphi objects
        x_lrreport_clear(_d_ar);
    end;
end;


procedure lrbuilds( xy: TMatrix;  s: TVector;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
begin
    _core_lrbuilds(xy, s, npoints, nvars, info, lm, ar, _xparams);
end;


procedure _core_lrbuildzs( xy: TMatrix;  s: TVector;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_s: x_vector;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_info: NativeInt;
    _d_lm : Pointer;
    _d_ar: x_lrreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        x_from_array(_d_s, s, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_lm := nil;
        lm := nil;
        x_lrreport_init(_d_ar);
        _error_code := x_xv2_lrbuildzs(@_s_error_msg, @_d_xy, @_d_s, @_d_npoints, @_d_nvars, @_d_info, @_d_lm, @_d_ar, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrbuildzs call');
        end;
        info := _d_info;
        lm := Tlinearmodel.Create(_d_lm);
        x_lrreport_to_record(_d_ar, ar);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_s);
        if (_d_lm<>nil) and (lm=nil) then
            x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to Delphi objects
        x_lrreport_clear(_d_ar);
    end;
end;


procedure lrbuildzs( xy: TMatrix;  s: TVector;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
begin
    _core_lrbuildzs(xy, s, npoints, nvars, info, lm, ar, _xparams);
end;


procedure _core_lrbuildz( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_info: NativeInt;
    _d_lm : Pointer;
    _d_ar: x_lrreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_lm := nil;
        lm := nil;
        x_lrreport_init(_d_ar);
        _error_code := x_xv2_lrbuildz(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_info, @_d_lm, @_d_ar, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrbuildz call');
        end;
        info := _d_info;
        lm := Tlinearmodel.Create(_d_lm);
        x_lrreport_to_record(_d_ar, ar);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_lm<>nil) and (lm=nil) then
            x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to Delphi objects
        x_lrreport_clear(_d_ar);
    end;
end;


procedure lrbuildz( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlinearmodel; out  ar: Tlrreport; const _xparams: UInt64 = 0);
begin
    _core_lrbuildz(xy, npoints, nvars, info, lm, ar, _xparams);
end;


procedure _core_lrunpack( lm: Tlinearmodel; out  v: TVector; out  nvars: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lm : Pointer;
    _d_v: x_vector;
    _d_nvars: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_create_empty(_d_v, DT_REAL);
        v := nil;
        _error_code := x_xv2_lrunpack(@_s_error_msg, @_d_lm, @_d_v, @_d_nvars, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrunpack call');
        end;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_v, v);
        nvars := _d_nvars;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_v);
    end;
end;


procedure lrunpack( lm: Tlinearmodel; out  v: TVector; out  nvars: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_lrunpack(lm, v, nvars, _xparams);
end;


procedure _core_lrpack( v: TVector;  nvars: TALGLIBInteger; out  lm: Tlinearmodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_v: x_vector;
    _d_nvars: NativeInt;
    _d_lm : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_v, v, X_CREATE);
        _d_nvars := nvars;
        _d_lm := nil;
        lm := nil;
        _error_code := x_xv2_lrpack(@_s_error_msg, @_d_v, @_d_nvars, @_d_lm, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrpack call');
        end;
        lm := Tlinearmodel.Create(_d_lm);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_v);
        if (_d_lm<>nil) and (lm=nil) then
            x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lrpack( v: TVector;  nvars: TALGLIBInteger; out  lm: Tlinearmodel; const _xparams: UInt64 = 0);
begin
    _core_lrpack(v, nvars, lm, _xparams);
end;


function _core_lrprocess( lm: Tlinearmodel;  x: TVector; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_lrprocess(@_s_error_msg, @_d_result, @_d_lm, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrprocess call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function lrprocess( lm: Tlinearmodel;  x: TVector; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_lrprocess(lm, x, _xparams);
end;


function _core_lrrmserror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_lrrmserror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lrrmserror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function lrrmserror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_lrrmserror(lm, xy, npoints, _xparams);
end;


function _core_lravgerror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_lravgerror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lravgerror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function lravgerror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_lravgerror(lm, xy, npoints, _xparams);
end;


function _core_lravgrelerror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_lravgrelerror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lravgrelerror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function lravgrelerror( lm: Tlinearmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_lravgrelerror(lm, xy, npoints, _xparams);
end;


procedure _core_filtersma(var  x: TVector;  n: TALGLIBInteger;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_k := k;
        _error_code := x_xv2_filtersma(@_s_error_msg, @_d_x, @_d_n, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during filtersma call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure filtersma(var  x: TVector;  n: TALGLIBInteger;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_filtersma(x, n, k, _xparams);
end;


procedure filtersma(var  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_filtersma(x, n, k, _xparams);

end;


procedure _core_filterema(var  x: TVector;  n: TALGLIBInteger;  alpha: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_alpha: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_alpha := alpha;
        _error_code := x_xv2_filterema(@_s_error_msg, @_d_x, @_d_n, @_d_alpha, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during filterema call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure filterema(var  x: TVector;  n: TALGLIBInteger;  alpha: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_filterema(x, n, alpha, _xparams);
end;


procedure filterema(var  x: TVector;  alpha: Double; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_filterema(x, n, alpha, _xparams);

end;


procedure _core_filterlrma(var  x: TVector;  n: TALGLIBInteger;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_k := k;
        _error_code := x_xv2_filterlrma(@_s_error_msg, @_d_x, @_d_n, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during filterlrma call');
        end;
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure filterlrma(var  x: TVector;  n: TALGLIBInteger;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_filterlrma(x, n, k, _xparams);
end;


procedure filterlrma(var  x: TVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_filterlrma(x, n, k, _xparams);

end;

constructor Tlogitmodel.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tlogitmodel.Destroy();
begin
    Deallocate();
end;

function Tlogitmodel.Clone():Tlogitmodel;
begin
    if ptr=nil then
        Result:=Tlogitmodel.Create(nil)
    else
        Result:=Tlogitmodel.Create(x_obj_copy_logitmodel(ptr));
end;

procedure Tlogitmodel.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_logitmodel(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tmnlreport):Tmnlreport;overload;
begin
    Result.ngrad := src.ngrad;
    Result.nhess := src.nhess;
end;

procedure x_mnlreport_init(var x: x_mnlreport);
begin
    x.ngrad.longval := 0;
    x.nhess.longval := 0;
end;

procedure x_mnlreport_clear(var x: x_mnlreport);
begin
end;

procedure x_mnlreport_init_from(var x: x_mnlreport; const v: Tmnlreport);
begin
    x.ngrad.longval := v.ngrad;
    x.nhess.longval := v.nhess;
end;

procedure x_mnlreport_to_record(const x: x_mnlreport; var v: Tmnlreport);
begin
    v.ngrad := x.ngrad.val; // long is silently truncated to TALGLIBInteger
    v.nhess := x.nhess.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_mnltrainh( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlogitmodel; out  rep: Tmnlreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
    _d_info: NativeInt;
    _d_lm : Pointer;
    _d_rep: x_mnlreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        _d_lm := nil;
        lm := nil;
        x_mnlreport_init(_d_rep);
        _error_code := x_xv2_mnltrainh(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_nclasses, @_d_info, @_d_lm, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnltrainh call');
        end;
        info := _d_info;
        lm := Tlogitmodel.Create(_d_lm);
        x_mnlreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_lm<>nil) and (lm=nil) then
            x_obj_free_logitmodel(_d_lm); // on exception clean up X objects which were not attached to Delphi objects
        x_mnlreport_clear(_d_rep);
    end;
end;


procedure mnltrainh( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  info: TALGLIBInteger; out  lm: Tlogitmodel; out  rep: Tmnlreport; const _xparams: UInt64 = 0);
begin
    _core_mnltrainh(xy, npoints, nvars, nclasses, info, lm, rep, _xparams);
end;


procedure _core_mnlprocess( lm: Tlogitmodel;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lm : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_mnlprocess(@_s_error_msg, @_d_lm, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlprocess call');
        end;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure mnlprocess( lm: Tlogitmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_mnlprocess(lm, x, y, _xparams);
end;


procedure _core_mnlprocessi( lm: Tlogitmodel;  x: TVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lm : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_mnlprocessi(@_s_error_msg, @_d_lm, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlprocessi call');
        end;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure mnlprocessi( lm: Tlogitmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_mnlprocessi(lm, x, y, _xparams);
end;


procedure _core_mnlunpack( lm: Tlogitmodel; out  a: TMatrix; out  nvars: TALGLIBInteger; out  nclasses: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_lm : Pointer;
    _d_a: x_matrix;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_mnlunpack(@_s_error_msg, @_d_lm, @_d_a, @_d_nvars, @_d_nclasses, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlunpack call');
        end;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_a, a);
        nvars := _d_nvars;
        nclasses := _d_nclasses;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure mnlunpack( lm: Tlogitmodel; out  a: TMatrix; out  nvars: TALGLIBInteger; out  nclasses: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mnlunpack(lm, a, nvars, nclasses, _xparams);
end;


procedure _core_mnlpack( a: TMatrix;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  lm: Tlogitmodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
    _d_lm : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        _d_lm := nil;
        lm := nil;
        _error_code := x_xv2_mnlpack(@_s_error_msg, @_d_a, @_d_nvars, @_d_nclasses, @_d_lm, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlpack call');
        end;
        lm := Tlogitmodel.Create(_d_lm);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        if (_d_lm<>nil) and (lm=nil) then
            x_obj_free_logitmodel(_d_lm); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mnlpack( a: TMatrix;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; out  lm: Tlogitmodel; const _xparams: UInt64 = 0);
begin
    _core_mnlpack(a, nvars, nclasses, lm, _xparams);
end;


function _core_mnlavgce( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mnlavgce(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlavgce call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mnlavgce( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mnlavgce(lm, xy, npoints, _xparams);
end;


function _core_mnlrelclserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mnlrelclserror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlrelclserror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mnlrelclserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mnlrelclserror(lm, xy, npoints, _xparams);
end;


function _core_mnlrmserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mnlrmserror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlrmserror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mnlrmserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mnlrmserror(lm, xy, npoints, _xparams);
end;


function _core_mnlavgerror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mnlavgerror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlavgerror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mnlavgerror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mnlavgerror(lm, xy, npoints, _xparams);
end;


function _core_mnlavgrelerror( lm: Tlogitmodel;  xy: TMatrix;  ssize: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_ssize: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_ssize := ssize;
        _error_code := x_xv2_mnlavgrelerror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_ssize, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlavgrelerror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mnlavgrelerror( lm: Tlogitmodel;  xy: TMatrix;  ssize: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mnlavgrelerror(lm, xy, ssize, _xparams);
end;


function _core_mnlclserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_lm : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_lm := lm.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mnlclserror(@_s_error_msg, @_d_result, @_d_lm, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mnlclserror call');
        end;
        result := _d_result;
        Assert(lm.ptr=_d_lm, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mnlclserror( lm: Tlogitmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_mnlclserror(lm, xy, npoints, _xparams);
end;

constructor Tmcpdstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tmcpdstate.Destroy();
begin
    Deallocate();
end;

function Tmcpdstate.Clone():Tmcpdstate;
begin
    if ptr=nil then
        Result:=Tmcpdstate.Create(nil)
    else
        Result:=Tmcpdstate.Create(x_obj_copy_mcpdstate(ptr));
end;

procedure Tmcpdstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_mcpdstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tmcpdreport):Tmcpdreport;overload;
begin
    Result.inneriterationscount := src.inneriterationscount;
    Result.outeriterationscount := src.outeriterationscount;
    Result.nfev := src.nfev;
    Result.terminationtype := src.terminationtype;
end;

procedure x_mcpdreport_init(var x: x_mcpdreport);
begin
    x.inneriterationscount.longval := 0;
    x.outeriterationscount.longval := 0;
    x.nfev.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_mcpdreport_clear(var x: x_mcpdreport);
begin
end;

procedure x_mcpdreport_init_from(var x: x_mcpdreport; const v: Tmcpdreport);
begin
    x.inneriterationscount.longval := v.inneriterationscount;
    x.outeriterationscount.longval := v.outeriterationscount;
    x.nfev.longval := v.nfev;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_mcpdreport_to_record(const x: x_mcpdreport; var v: Tmcpdreport);
begin
    v.inneriterationscount := x.inneriterationscount.val; // long is silently truncated to TALGLIBInteger
    v.outeriterationscount := x.outeriterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_mcpdcreate( n: TALGLIBInteger; out  s: Tmcpdstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_mcpdcreate(@_s_error_msg, @_d_n, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdcreate call');
        end;
        s := Tmcpdstate.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mcpdcreate( n: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
begin
    _core_mcpdcreate(n, s, _xparams);
end;


procedure _core_mcpdcreateentry( n: TALGLIBInteger;  entrystate: TALGLIBInteger; out  s: Tmcpdstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_entrystate: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_entrystate := entrystate;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_mcpdcreateentry(@_s_error_msg, @_d_n, @_d_entrystate, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdcreateentry call');
        end;
        s := Tmcpdstate.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mcpdcreateentry( n: TALGLIBInteger;  entrystate: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
begin
    _core_mcpdcreateentry(n, entrystate, s, _xparams);
end;


procedure _core_mcpdcreateexit( n: TALGLIBInteger;  exitstate: TALGLIBInteger; out  s: Tmcpdstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_exitstate: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_exitstate := exitstate;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_mcpdcreateexit(@_s_error_msg, @_d_n, @_d_exitstate, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdcreateexit call');
        end;
        s := Tmcpdstate.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mcpdcreateexit( n: TALGLIBInteger;  exitstate: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
begin
    _core_mcpdcreateexit(n, exitstate, s, _xparams);
end;


procedure _core_mcpdcreateentryexit( n: TALGLIBInteger;  entrystate: TALGLIBInteger;  exitstate: TALGLIBInteger; out  s: Tmcpdstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_entrystate: NativeInt;
    _d_exitstate: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_entrystate := entrystate;
        _d_exitstate := exitstate;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_mcpdcreateentryexit(@_s_error_msg, @_d_n, @_d_entrystate, @_d_exitstate, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdcreateentryexit call');
        end;
        s := Tmcpdstate.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mcpdcreateentryexit( n: TALGLIBInteger;  entrystate: TALGLIBInteger;  exitstate: TALGLIBInteger; out  s: Tmcpdstate; const _xparams: UInt64 = 0);
begin
    _core_mcpdcreateentryexit(n, entrystate, exitstate, s, _xparams);
end;


procedure _core_mcpdaddtrack( s: Tmcpdstate;  xy: TMatrix;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy: x_matrix;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_mcpdaddtrack(@_s_error_msg, @_d_s, @_d_xy, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdaddtrack call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure mcpdaddtrack( s: Tmcpdstate;  xy: TMatrix;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_mcpdaddtrack(s, xy, k, _xparams);
end;


procedure mcpdaddtrack( s: Tmcpdstate;  xy: TMatrix; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin

    k := xrows(xy);

    _core_mcpdaddtrack(s, xy, k, _xparams);

end;


procedure _core_mcpdsetec( s: Tmcpdstate;  ec: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_ec: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_ec, ec, X_CREATE);
        _error_code := x_xv2_mcpdsetec(@_s_error_msg, @_d_s, @_d_ec, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdsetec call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_ec);
    end;
end;


procedure mcpdsetec( s: Tmcpdstate;  ec: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_mcpdsetec(s, ec, _xparams);
end;


procedure _core_mcpdaddec( s: Tmcpdstate;  i: TALGLIBInteger;  j: TALGLIBInteger;  c: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_j: NativeInt;
    _d_c: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        _d_j := j;
        _d_c := c;
        _error_code := x_xv2_mcpdaddec(@_s_error_msg, @_d_s, @_d_i, @_d_j, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdaddec call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mcpdaddec( s: Tmcpdstate;  i: TALGLIBInteger;  j: TALGLIBInteger;  c: Double; const _xparams: UInt64 = 0);
begin
    _core_mcpdaddec(s, i, j, c, _xparams);
end;


procedure _core_mcpdsetbc( s: Tmcpdstate;  bndl: TMatrix;  bndu: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_bndl: x_matrix;
    _d_bndu: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_mcpdsetbc(@_s_error_msg, @_d_s, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdsetbc call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure mcpdsetbc( s: Tmcpdstate;  bndl: TMatrix;  bndu: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_mcpdsetbc(s, bndl, bndu, _xparams);
end;


procedure _core_mcpdaddbc( s: Tmcpdstate;  i: TALGLIBInteger;  j: TALGLIBInteger;  bndl: Double;  bndu: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_i: NativeInt;
    _d_j: NativeInt;
    _d_bndl: Double;
    _d_bndu: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_i := i;
        _d_j := j;
        _d_bndl := bndl;
        _d_bndu := bndu;
        _error_code := x_xv2_mcpdaddbc(@_s_error_msg, @_d_s, @_d_i, @_d_j, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdaddbc call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mcpdaddbc( s: Tmcpdstate;  i: TALGLIBInteger;  j: TALGLIBInteger;  bndl: Double;  bndu: Double; const _xparams: UInt64 = 0);
begin
    _core_mcpdaddbc(s, i, j, bndl, bndu, _xparams);
end;


procedure _core_mcpdsetlc( s: Tmcpdstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_c: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_mcpdsetlc(@_s_error_msg, @_d_s, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdsetlc call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_clear(_d_ct);
    end;
end;


procedure mcpdsetlc( s: Tmcpdstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_mcpdsetlc(s, c, ct, k, _xparams);
end;


procedure mcpdsetlc( s: Tmcpdstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(c)<>xlen(ct))) then
    raise Exception.Create('Error while calling mcpdsetlc: looks like one of arguments has wrong size');

    k := xrows(c);

    _core_mcpdsetlc(s, c, ct, k, _xparams);

end;


procedure _core_mcpdsettikhonovregularizer( s: Tmcpdstate;  v: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_v := v;
        _error_code := x_xv2_mcpdsettikhonovregularizer(@_s_error_msg, @_d_s, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdsettikhonovregularizer call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mcpdsettikhonovregularizer( s: Tmcpdstate;  v: Double; const _xparams: UInt64 = 0);
begin
    _core_mcpdsettikhonovregularizer(s, v, _xparams);
end;


procedure _core_mcpdsetprior( s: Tmcpdstate;  pp: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_pp: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_pp, pp, X_CREATE);
        _error_code := x_xv2_mcpdsetprior(@_s_error_msg, @_d_s, @_d_pp, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdsetprior call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_pp);
    end;
end;


procedure mcpdsetprior( s: Tmcpdstate;  pp: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_mcpdsetprior(s, pp, _xparams);
end;


procedure _core_mcpdsetpredictionweights( s: Tmcpdstate;  pw: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_pw: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_pw, pw, X_CREATE);
        _error_code := x_xv2_mcpdsetpredictionweights(@_s_error_msg, @_d_s, @_d_pw, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdsetpredictionweights call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_pw);
    end;
end;


procedure mcpdsetpredictionweights( s: Tmcpdstate;  pw: TVector; const _xparams: UInt64 = 0);
begin
    _core_mcpdsetpredictionweights(s, pw, _xparams);
end;


procedure _core_mcpdsolve( s: Tmcpdstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_mcpdsolve(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdsolve call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mcpdsolve( s: Tmcpdstate; const _xparams: UInt64 = 0);
begin
    _core_mcpdsolve(s, _xparams);
end;


procedure _core_mcpdresults( s: Tmcpdstate; out  p: TMatrix; out  rep: Tmcpdreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_p: x_matrix;
    _d_rep: x_mcpdreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_create_empty(_d_p, DT_REAL);
        p := nil;
        x_mcpdreport_init(_d_rep);
        _error_code := x_xv2_mcpdresults(@_s_error_msg, @_d_s, @_d_p, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mcpdresults call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_p, p);
        x_mcpdreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_p);
        x_mcpdreport_clear(_d_rep);
    end;
end;


procedure mcpdresults( s: Tmcpdstate; out  p: TMatrix; out  rep: Tmcpdreport; const _xparams: UInt64 = 0);
begin
    _core_mcpdresults(s, p, rep, _xparams);
end;

constructor Tmlpensemble.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tmlpensemble.Destroy();
begin
    Deallocate();
end;

function Tmlpensemble.Clone():Tmlpensemble;
begin
    if ptr=nil then
        Result:=Tmlpensemble.Create(nil)
    else
        Result:=Tmlpensemble.Create(x_obj_copy_mlpensemble(ptr));
end;

procedure Tmlpensemble.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_mlpensemble(ptr);
    ptr:=nil;
end;

procedure mlpeserialize(const obj: Tmlpensemble; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_mlpeserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure mlpeunserialize(const s_in: AnsiString; out obj: Tmlpensemble);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_mlpeunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeunserialize() call');
        end;
        obj:=Tmlpensemble.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_mlpensemble(_x);
    end;
end;

procedure mlpeserialize(const obj: Tmlpensemble; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_mlpeserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during mlpeserialize_stream() call');
    end;
end;

procedure mlpeunserialize(stream: TStream; out obj: Tmlpensemble);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_mlpeunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeunserialize_stream() call');
        end;
        obj:=Tmlpensemble.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_mlpensemble(_x);
    end;
end;


procedure _core_mlpecreate0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreate0(@_s_error_msg, @_d_nin, @_d_nout, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreate0 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreate0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreate0(nin, nout, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreate1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreate1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreate1 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreate1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreate1(nin, nhid, nout, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreate2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreate2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreate2 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreate2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreate2(nin, nhid1, nhid2, nout, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreateb0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_b: Double;
    _d_d: Double;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_b := b;
        _d_d := d;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreateb0(@_s_error_msg, @_d_nin, @_d_nout, @_d_b, @_d_d, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreateb0 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreateb0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreateb0(nin, nout, b, d, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreateb1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_b: Double;
    _d_d: Double;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_b := b;
        _d_d := d;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreateb1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_b, @_d_d, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreateb1 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreateb1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreateb1(nin, nhid, nout, b, d, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreateb2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_b: Double;
    _d_d: Double;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_b := b;
        _d_d := d;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreateb2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_b, @_d_d, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreateb2 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreateb2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  b: Double;  d: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreateb2(nin, nhid1, nhid2, nout, b, d, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreater0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_a := a;
        _d_b := b;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreater0(@_s_error_msg, @_d_nin, @_d_nout, @_d_a, @_d_b, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreater0 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreater0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreater0(nin, nout, a, b, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreater1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_a := a;
        _d_b := b;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreater1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_a, @_d_b, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreater1 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreater1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreater1(nin, nhid, nout, a, b, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreater2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_a := a;
        _d_b := b;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreater2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_a, @_d_b, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreater2 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreater2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  a: Double;  b: Double;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreater2(nin, nhid1, nhid2, nout, a, b, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreatec0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreatec0(@_s_error_msg, @_d_nin, @_d_nout, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreatec0 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreatec0( nin: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreatec0(nin, nout, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreatec1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid: NativeInt;
    _d_nout: NativeInt;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid := nhid;
        _d_nout := nout;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreatec1(@_s_error_msg, @_d_nin, @_d_nhid, @_d_nout, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreatec1 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreatec1( nin: TALGLIBInteger;  nhid: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreatec1(nin, nhid, nout, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreatec2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nhid1: NativeInt;
    _d_nhid2: NativeInt;
    _d_nout: NativeInt;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nhid1 := nhid1;
        _d_nhid2 := nhid2;
        _d_nout := nout;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreatec2(@_s_error_msg, @_d_nin, @_d_nhid1, @_d_nhid2, @_d_nout, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreatec2 call');
        end;
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreatec2( nin: TALGLIBInteger;  nhid1: TALGLIBInteger;  nhid2: TALGLIBInteger;  nout: TALGLIBInteger;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreatec2(nin, nhid1, nhid2, nout, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlpecreatefromnetwork( network: Tmultilayerperceptron;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_ensemblesize: NativeInt;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        _d_ensemblesize := ensemblesize;
        _d_ensemble := nil;
        ensemble := nil;
        _error_code := x_xv2_mlpecreatefromnetwork(@_s_error_msg, @_d_network, @_d_ensemblesize, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpecreatefromnetwork call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        ensemble := Tmlpensemble.Create(_d_ensemble);
    finally
        SetXExceptionMask(fpumask);
        if (_d_ensemble<>nil) and (ensemble=nil) then
            x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpecreatefromnetwork( network: Tmultilayerperceptron;  ensemblesize: TALGLIBInteger; out  ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlpecreatefromnetwork(network, ensemblesize, ensemble, _xparams);
end;


procedure _core_mlperandomize( ensemble: Tmlpensemble; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        _error_code := x_xv2_mlperandomize(@_s_error_msg, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlperandomize call');
        end;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlperandomize( ensemble: Tmlpensemble; const _xparams: UInt64 = 0);
begin
    _core_mlperandomize(ensemble, _xparams);
end;


procedure _core_mlpeproperties( ensemble: Tmlpensemble; out  nin: TALGLIBInteger; out  nout: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_ensemble : Pointer;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        _error_code := x_xv2_mlpeproperties(@_s_error_msg, @_d_ensemble, @_d_nin, @_d_nout, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeproperties call');
        end;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
        nin := _d_nin;
        nout := _d_nout;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpeproperties( ensemble: Tmlpensemble; out  nin: TALGLIBInteger; out  nout: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mlpeproperties(ensemble, nin, nout, _xparams);
end;


function _core_mlpeissoftmax( ensemble: Tmlpensemble; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_ensemble : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        _error_code := x_xv2_mlpeissoftmax(@_s_error_msg, @_d_result, @_d_ensemble, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeissoftmax call');
        end;
        result := Byte2Bool(_d_result);
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpeissoftmax( ensemble: Tmlpensemble; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_mlpeissoftmax(ensemble, _xparams);
end;


procedure _core_mlpeprocess( ensemble: Tmlpensemble;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_ensemble : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_mlpeprocess(@_s_error_msg, @_d_ensemble, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeprocess call');
        end;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure mlpeprocess( ensemble: Tmlpensemble;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpeprocess(ensemble, x, y, _xparams);
end;


procedure _core_mlpeprocessi( ensemble: Tmlpensemble;  x: TVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_ensemble : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_mlpeprocessi(@_s_error_msg, @_d_ensemble, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeprocessi call');
        end;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure mlpeprocessi( ensemble: Tmlpensemble;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_mlpeprocessi(ensemble, x, y, _xparams);
end;


function _core_mlperelclserror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlperelclserror(@_s_error_msg, @_d_result, @_d_ensemble, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlperelclserror call');
        end;
        result := _d_result;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlperelclserror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlperelclserror(ensemble, xy, npoints, _xparams);
end;


function _core_mlpeavgce( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpeavgce(@_s_error_msg, @_d_result, @_d_ensemble, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeavgce call');
        end;
        result := _d_result;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpeavgce( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpeavgce(ensemble, xy, npoints, _xparams);
end;


function _core_mlpermserror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpermserror(@_s_error_msg, @_d_result, @_d_ensemble, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpermserror call');
        end;
        result := _d_result;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpermserror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpermserror(ensemble, xy, npoints, _xparams);
end;


function _core_mlpeavgerror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpeavgerror(@_s_error_msg, @_d_result, @_d_ensemble, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeavgerror call');
        end;
        result := _d_result;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpeavgerror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpeavgerror(ensemble, xy, npoints, _xparams);
end;


function _core_mlpeavgrelerror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpeavgrelerror(@_s_error_msg, @_d_result, @_d_ensemble, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpeavgrelerror call');
        end;
        result := _d_result;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function mlpeavgrelerror( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_mlpeavgrelerror(ensemble, xy, npoints, _xparams);
end;

function Clone(const Src: Tmlpreport):Tmlpreport;overload;
begin
    Result.relclserror := src.relclserror;
    Result.avgce := src.avgce;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
    Result.ngrad := src.ngrad;
    Result.nhess := src.nhess;
    Result.ncholesky := src.ncholesky;
end;

procedure x_mlpreport_init(var x: x_mlpreport);
begin
    x.relclserror := 0;
    x.avgce := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
    x.ngrad.longval := 0;
    x.nhess.longval := 0;
    x.ncholesky.longval := 0;
end;

procedure x_mlpreport_clear(var x: x_mlpreport);
begin
end;

procedure x_mlpreport_init_from(var x: x_mlpreport; const v: Tmlpreport);
begin
    x.relclserror := v.relclserror;
    x.avgce := v.avgce;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
    x.ngrad.longval := v.ngrad;
    x.nhess.longval := v.nhess;
    x.ncholesky.longval := v.ncholesky;
end;

procedure x_mlpreport_to_record(const x: x_mlpreport; var v: Tmlpreport);
begin
    v.relclserror := x.relclserror;
    v.avgce := x.avgce;
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
    v.ngrad := x.ngrad.val; // long is silently truncated to TALGLIBInteger
    v.nhess := x.nhess.val; // long is silently truncated to TALGLIBInteger
    v.ncholesky := x.ncholesky.val; // long is silently truncated to TALGLIBInteger
end;

function Clone(const Src: Tmlpcvreport):Tmlpcvreport;overload;
begin
    Result.relclserror := src.relclserror;
    Result.avgce := src.avgce;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
end;

procedure x_mlpcvreport_init(var x: x_mlpcvreport);
begin
    x.relclserror := 0;
    x.avgce := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
end;

procedure x_mlpcvreport_clear(var x: x_mlpcvreport);
begin
end;

procedure x_mlpcvreport_init_from(var x: x_mlpcvreport; const v: Tmlpcvreport);
begin
    x.relclserror := v.relclserror;
    x.avgce := v.avgce;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
end;

procedure x_mlpcvreport_to_record(const x: x_mlpcvreport; var v: Tmlpcvreport);
begin
    v.relclserror := x.relclserror;
    v.avgce := x.avgce;
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
end;

constructor Tmlptrainer.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tmlptrainer.Destroy();
begin
    Deallocate();
end;

function Tmlptrainer.Clone():Tmlptrainer;
begin
    if ptr=nil then
        Result:=Tmlptrainer.Create(nil)
    else
        Result:=Tmlptrainer.Create(x_obj_copy_mlptrainer(ptr));
end;

procedure Tmlptrainer.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_mlptrainer(ptr);
    ptr:=nil;
end;


procedure _core_mlptrainlm( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_decay := decay;
        _d_restarts := restarts;
        x_mlpreport_init(_d_rep);
        _error_code := x_xv2_mlptrainlm(@_s_error_msg, @_d_network, @_d_xy, @_d_npoints, @_d_decay, @_d_restarts, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlptrainlm call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_mlpreport_clear(_d_rep);
    end;
end;


procedure mlptrainlm( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
begin
    _core_mlptrainlm(network, xy, npoints, decay, restarts, info, rep, _xparams);
end;


procedure _core_mlptrainlbfgs( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_wstep: Double;
    _d_maxits: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_decay := decay;
        _d_restarts := restarts;
        _d_wstep := wstep;
        _d_maxits := maxits;
        x_mlpreport_init(_d_rep);
        _error_code := x_xv2_mlptrainlbfgs(@_s_error_msg, @_d_network, @_d_xy, @_d_npoints, @_d_decay, @_d_restarts, @_d_wstep, @_d_maxits, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlptrainlbfgs call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_mlpreport_clear(_d_rep);
    end;
end;


procedure mlptrainlbfgs( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
begin
    _core_mlptrainlbfgs(network, xy, npoints, decay, restarts, wstep, maxits, info, rep, _xparams);
end;


procedure _core_mlptraines( network: Tmultilayerperceptron;  trnxy: TMatrix;  trnsize: TALGLIBInteger;  valxy: TMatrix;  valsize: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_trnxy: x_matrix;
    _d_trnsize: NativeInt;
    _d_valxy: x_matrix;
    _d_valsize: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_trnxy, trnxy, X_CREATE);
        _d_trnsize := trnsize;
        x_from_array(_d_valxy, valxy, X_CREATE);
        _d_valsize := valsize;
        _d_decay := decay;
        _d_restarts := restarts;
        x_mlpreport_init(_d_rep);
        _error_code := x_xv2_mlptraines(@_s_error_msg, @_d_network, @_d_trnxy, @_d_trnsize, @_d_valxy, @_d_valsize, @_d_decay, @_d_restarts, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlptraines call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_trnxy);
        x_clear(_d_valxy);
        x_mlpreport_clear(_d_rep);
    end;
end;


procedure mlptraines( network: Tmultilayerperceptron;  trnxy: TMatrix;  trnsize: TALGLIBInteger;  valxy: TMatrix;  valsize: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
begin
    _core_mlptraines(network, trnxy, trnsize, valxy, valsize, decay, restarts, info, rep, _xparams);
end;


procedure _core_mlpkfoldcvlbfgs( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger;  foldscount: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  cvrep: Tmlpcvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_wstep: Double;
    _d_maxits: NativeInt;
    _d_foldscount: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
    _d_cvrep: x_mlpcvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_decay := decay;
        _d_restarts := restarts;
        _d_wstep := wstep;
        _d_maxits := maxits;
        _d_foldscount := foldscount;
        x_mlpreport_init(_d_rep);
        x_mlpcvreport_init(_d_cvrep);
        _error_code := x_xv2_mlpkfoldcvlbfgs(@_s_error_msg, @_d_network, @_d_xy, @_d_npoints, @_d_decay, @_d_restarts, @_d_wstep, @_d_maxits, @_d_foldscount, @_d_info, @_d_rep, @_d_cvrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpkfoldcvlbfgs call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
        x_mlpcvreport_to_record(_d_cvrep, cvrep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_mlpreport_clear(_d_rep);
        x_mlpcvreport_clear(_d_cvrep);
    end;
end;


procedure mlpkfoldcvlbfgs( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger;  foldscount: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  cvrep: Tmlpcvreport; const _xparams: UInt64 = 0);
begin
    _core_mlpkfoldcvlbfgs(network, xy, npoints, decay, restarts, wstep, maxits, foldscount, info, rep, cvrep, _xparams);
end;


procedure _core_mlpkfoldcvlm( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  foldscount: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  cvrep: Tmlpcvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_network : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_foldscount: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
    _d_cvrep: x_mlpcvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_network := network.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_decay := decay;
        _d_restarts := restarts;
        _d_foldscount := foldscount;
        x_mlpreport_init(_d_rep);
        x_mlpcvreport_init(_d_cvrep);
        _error_code := x_xv2_mlpkfoldcvlm(@_s_error_msg, @_d_network, @_d_xy, @_d_npoints, @_d_decay, @_d_restarts, @_d_foldscount, @_d_info, @_d_rep, @_d_cvrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpkfoldcvlm call');
        end;
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
        x_mlpcvreport_to_record(_d_cvrep, cvrep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_mlpreport_clear(_d_rep);
        x_mlpcvreport_clear(_d_cvrep);
    end;
end;


procedure mlpkfoldcvlm( network: Tmultilayerperceptron;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  foldscount: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  cvrep: Tmlpcvreport; const _xparams: UInt64 = 0);
begin
    _core_mlpkfoldcvlm(network, xy, npoints, decay, restarts, foldscount, info, rep, cvrep, _xparams);
end;


procedure _core_mlpkfoldcv( s: Tmlptrainer;  network: Tmultilayerperceptron;  nrestarts: TALGLIBInteger;  foldscount: TALGLIBInteger; out  rep: Tmlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_network : Pointer;
    _d_nrestarts: NativeInt;
    _d_foldscount: NativeInt;
    _d_rep: x_mlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_network := network.ptr;
        _d_nrestarts := nrestarts;
        _d_foldscount := foldscount;
        x_mlpreport_init(_d_rep);
        _error_code := x_xv2_mlpkfoldcv(@_s_error_msg, @_d_s, @_d_network, @_d_nrestarts, @_d_foldscount, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpkfoldcv call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_mlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_mlpreport_clear(_d_rep);
    end;
end;


procedure mlpkfoldcv( s: Tmlptrainer;  network: Tmultilayerperceptron;  nrestarts: TALGLIBInteger;  foldscount: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
begin
    _core_mlpkfoldcv(s, network, nrestarts, foldscount, rep, _xparams);
end;


procedure _core_mlpcreatetrainer( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  s: Tmlptrainer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nout: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nout := nout;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_mlpcreatetrainer(@_s_error_msg, @_d_nin, @_d_nout, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreatetrainer call');
        end;
        s := Tmlptrainer.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_mlptrainer(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreatetrainer( nin: TALGLIBInteger;  nout: TALGLIBInteger; out  s: Tmlptrainer; const _xparams: UInt64 = 0);
begin
    _core_mlpcreatetrainer(nin, nout, s, _xparams);
end;


procedure _core_mlpcreatetrainercls( nin: TALGLIBInteger;  nclasses: TALGLIBInteger; out  s: Tmlptrainer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nin: NativeInt;
    _d_nclasses: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nin := nin;
        _d_nclasses := nclasses;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_mlpcreatetrainercls(@_s_error_msg, @_d_nin, @_d_nclasses, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcreatetrainercls call');
        end;
        s := Tmlptrainer.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_mlptrainer(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure mlpcreatetrainercls( nin: TALGLIBInteger;  nclasses: TALGLIBInteger; out  s: Tmlptrainer; const _xparams: UInt64 = 0);
begin
    _core_mlpcreatetrainercls(nin, nclasses, s, _xparams);
end;


procedure _core_mlpsetdataset( s: Tmlptrainer;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_mlpsetdataset(@_s_error_msg, @_d_s, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetdataset call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure mlpsetdataset( s: Tmlptrainer;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mlpsetdataset(s, xy, npoints, _xparams);
end;


procedure _core_mlpsetsparsedataset( s: Tmlptrainer;  xy: Tsparsematrix;  npoints: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy : Pointer;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_xy := xy.ptr;
        _d_npoints := npoints;
        _error_code := x_xv2_mlpsetsparsedataset(@_s_error_msg, @_d_s, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetsparsedataset call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(xy.ptr=_d_xy, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetsparsedataset( s: Tmlptrainer;  xy: Tsparsematrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mlpsetsparsedataset(s, xy, npoints, _xparams);
end;


procedure _core_mlpsetdecay( s: Tmlptrainer;  decay: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_decay: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_decay := decay;
        _error_code := x_xv2_mlpsetdecay(@_s_error_msg, @_d_s, @_d_decay, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetdecay call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetdecay( s: Tmlptrainer;  decay: Double; const _xparams: UInt64 = 0);
begin
    _core_mlpsetdecay(s, decay, _xparams);
end;


procedure _core_mlpsetcond( s: Tmlptrainer;  wstep: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_wstep: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_wstep := wstep;
        _d_maxits := maxits;
        _error_code := x_xv2_mlpsetcond(@_s_error_msg, @_d_s, @_d_wstep, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetcond call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetcond( s: Tmlptrainer;  wstep: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_mlpsetcond(s, wstep, maxits, _xparams);
end;


procedure _core_mlpsetalgobatch( s: Tmlptrainer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_mlpsetalgobatch(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpsetalgobatch call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpsetalgobatch( s: Tmlptrainer; const _xparams: UInt64 = 0);
begin
    _core_mlpsetalgobatch(s, _xparams);
end;


procedure _core_mlptrainnetwork( s: Tmlptrainer;  network: Tmultilayerperceptron;  nrestarts: TALGLIBInteger; out  rep: Tmlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_network : Pointer;
    _d_nrestarts: NativeInt;
    _d_rep: x_mlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_network := network.ptr;
        _d_nrestarts := nrestarts;
        x_mlpreport_init(_d_rep);
        _error_code := x_xv2_mlptrainnetwork(@_s_error_msg, @_d_s, @_d_network, @_d_nrestarts, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlptrainnetwork call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_mlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_mlpreport_clear(_d_rep);
    end;
end;


procedure mlptrainnetwork( s: Tmlptrainer;  network: Tmultilayerperceptron;  nrestarts: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
begin
    _core_mlptrainnetwork(s, network, nrestarts, rep, _xparams);
end;


procedure _core_mlpstarttraining( s: Tmlptrainer;  network: Tmultilayerperceptron;  randomstart: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_network : Pointer;
    _d_randomstart: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_network := network.ptr;
        _d_randomstart := Bool2Byte(randomstart);
        _error_code := x_xv2_mlpstarttraining(@_s_error_msg, @_d_s, @_d_network, @_d_randomstart, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpstarttraining call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure mlpstarttraining( s: Tmlptrainer;  network: Tmultilayerperceptron;  randomstart: Boolean; const _xparams: UInt64 = 0);
begin
    _core_mlpstarttraining(s, network, randomstart, _xparams);
end;


function _core_mlpcontinuetraining( s: Tmlptrainer;  network: Tmultilayerperceptron; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_s : Pointer;
    _d_network : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_network := network.ptr;
        _error_code := x_xv2_mlpcontinuetraining(@_s_error_msg, @_d_result, @_d_s, @_d_network, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpcontinuetraining call');
        end;
        result := Byte2Bool(_d_result);
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(network.ptr=_d_network, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function mlpcontinuetraining( s: Tmlptrainer;  network: Tmultilayerperceptron; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_mlpcontinuetraining(s, network, _xparams);
end;


procedure _core_mlpebagginglm( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  ooberrors: Tmlpcvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
    _d_ooberrors: x_mlpcvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_decay := decay;
        _d_restarts := restarts;
        x_mlpreport_init(_d_rep);
        x_mlpcvreport_init(_d_ooberrors);
        _error_code := x_xv2_mlpebagginglm(@_s_error_msg, @_d_ensemble, @_d_xy, @_d_npoints, @_d_decay, @_d_restarts, @_d_info, @_d_rep, @_d_ooberrors, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpebagginglm call');
        end;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
        x_mlpcvreport_to_record(_d_ooberrors, ooberrors);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_mlpreport_clear(_d_rep);
        x_mlpcvreport_clear(_d_ooberrors);
    end;
end;


procedure mlpebagginglm( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  ooberrors: Tmlpcvreport; const _xparams: UInt64 = 0);
begin
    _core_mlpebagginglm(ensemble, xy, npoints, decay, restarts, info, rep, ooberrors, _xparams);
end;


procedure _core_mlpebagginglbfgs( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  ooberrors: Tmlpcvreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_wstep: Double;
    _d_maxits: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
    _d_ooberrors: x_mlpcvreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_decay := decay;
        _d_restarts := restarts;
        _d_wstep := wstep;
        _d_maxits := maxits;
        x_mlpreport_init(_d_rep);
        x_mlpcvreport_init(_d_ooberrors);
        _error_code := x_xv2_mlpebagginglbfgs(@_s_error_msg, @_d_ensemble, @_d_xy, @_d_npoints, @_d_decay, @_d_restarts, @_d_wstep, @_d_maxits, @_d_info, @_d_rep, @_d_ooberrors, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpebagginglbfgs call');
        end;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
        x_mlpcvreport_to_record(_d_ooberrors, ooberrors);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_mlpreport_clear(_d_rep);
        x_mlpcvreport_clear(_d_ooberrors);
    end;
end;


procedure mlpebagginglbfgs( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger;  wstep: Double;  maxits: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; out  ooberrors: Tmlpcvreport; const _xparams: UInt64 = 0);
begin
    _core_mlpebagginglbfgs(ensemble, xy, npoints, decay, restarts, wstep, maxits, info, rep, ooberrors, _xparams);
end;


procedure _core_mlpetraines( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_ensemble : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_decay: Double;
    _d_restarts: NativeInt;
    _d_info: NativeInt;
    _d_rep: x_mlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_ensemble := ensemble.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_decay := decay;
        _d_restarts := restarts;
        x_mlpreport_init(_d_rep);
        _error_code := x_xv2_mlpetraines(@_s_error_msg, @_d_ensemble, @_d_xy, @_d_npoints, @_d_decay, @_d_restarts, @_d_info, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlpetraines call');
        end;
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_mlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_mlpreport_clear(_d_rep);
    end;
end;


procedure mlpetraines( ensemble: Tmlpensemble;  xy: TMatrix;  npoints: TALGLIBInteger;  decay: Double;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
begin
    _core_mlpetraines(ensemble, xy, npoints, decay, restarts, info, rep, _xparams);
end;


procedure _core_mlptrainensemblees( s: Tmlptrainer;  ensemble: Tmlpensemble;  nrestarts: TALGLIBInteger; out  rep: Tmlpreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_ensemble : Pointer;
    _d_nrestarts: NativeInt;
    _d_rep: x_mlpreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_ensemble := ensemble.ptr;
        _d_nrestarts := nrestarts;
        x_mlpreport_init(_d_rep);
        _error_code := x_xv2_mlptrainensemblees(@_s_error_msg, @_d_s, @_d_ensemble, @_d_nrestarts, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mlptrainensemblees call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(ensemble.ptr=_d_ensemble, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_mlpreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_mlpreport_clear(_d_rep);
    end;
end;


procedure mlptrainensemblees( s: Tmlptrainer;  ensemble: Tmlpensemble;  nrestarts: TALGLIBInteger; out  rep: Tmlpreport; const _xparams: UInt64 = 0);
begin
    _core_mlptrainensemblees(s, ensemble, nrestarts, rep, _xparams);
end;

constructor Tclusterizerstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tclusterizerstate.Destroy();
begin
    Deallocate();
end;

function Tclusterizerstate.Clone():Tclusterizerstate;
begin
    if ptr=nil then
        Result:=Tclusterizerstate.Create(nil)
    else
        Result:=Tclusterizerstate.Create(x_obj_copy_clusterizerstate(ptr));
end;

procedure Tclusterizerstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_clusterizerstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tahcreport):Tahcreport;overload;
begin
    Result.terminationtype := src.terminationtype;
    Result.npoints := src.npoints;
    Result.p := Clone(src.p);
    Result.z := Clone(src.z);
    Result.pz := Clone(src.pz);
    Result.pm := Clone(src.pm);
    Result.mergedist := Clone(src.mergedist);
end;

procedure x_ahcreport_init(var x: x_ahcreport);
begin
    x.terminationtype.longval := 0;
    x.npoints.longval := 0;
    x_create_empty(x.p, DT_INT);
    x_create_empty(x.z, DT_INT);
    x_create_empty(x.pz, DT_INT);
    x_create_empty(x.pm, DT_INT);
    x_create_empty(x.mergedist, DT_REAL);
end;

procedure x_ahcreport_clear(var x: x_ahcreport);
begin
    x_clear(x.p);
    x_clear(x.z);
    x_clear(x.pz);
    x_clear(x.pm);
    x_clear(x.mergedist);
end;

procedure x_ahcreport_init_from(var x: x_ahcreport; const v: Tahcreport);
begin
    x.terminationtype.longval := v.terminationtype;
    x.npoints.longval := v.npoints;
    x_from_array(x.p, v.p, X_CREATE);
    x_from_array(x.z, v.z, X_CREATE);
    x_from_array(x.pz, v.pz, X_CREATE);
    x_from_array(x.pm, v.pm, X_CREATE);
    x_from_array(x.mergedist, v.mergedist, X_CREATE);
end;

procedure x_ahcreport_to_record(const x: x_ahcreport; var v: Tahcreport);
begin
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.npoints := x.npoints.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.p, v.p);
    x_to_array(x.z, v.z);
    x_to_array(x.pz, v.pz);
    x_to_array(x.pm, v.pm);
    x_to_array(x.mergedist, v.mergedist);
end;

function Clone(const Src: Tkmeansreport):Tkmeansreport;overload;
begin
    Result.npoints := src.npoints;
    Result.nfeatures := src.nfeatures;
    Result.terminationtype := src.terminationtype;
    Result.iterationscount := src.iterationscount;
    Result.energy := src.energy;
    Result.k := src.k;
    Result.c := Clone(src.c);
    Result.cidx := Clone(src.cidx);
end;

procedure x_kmeansreport_init(var x: x_kmeansreport);
begin
    x.npoints.longval := 0;
    x.nfeatures.longval := 0;
    x.terminationtype.longval := 0;
    x.iterationscount.longval := 0;
    x.energy := 0;
    x.k.longval := 0;
    x_create_empty(x.c, DT_REAL);
    x_create_empty(x.cidx, DT_INT);
end;

procedure x_kmeansreport_clear(var x: x_kmeansreport);
begin
    x_clear(x.c);
    x_clear(x.cidx);
end;

procedure x_kmeansreport_init_from(var x: x_kmeansreport; const v: Tkmeansreport);
begin
    x.npoints.longval := v.npoints;
    x.nfeatures.longval := v.nfeatures;
    x.terminationtype.longval := v.terminationtype;
    x.iterationscount.longval := v.iterationscount;
    x.energy := v.energy;
    x.k.longval := v.k;
    x_from_array(x.c, v.c, X_CREATE);
    x_from_array(x.cidx, v.cidx, X_CREATE);
end;

procedure x_kmeansreport_to_record(const x: x_kmeansreport; var v: Tkmeansreport);
begin
    v.npoints := x.npoints.val; // long is silently truncated to TALGLIBInteger
    v.nfeatures := x.nfeatures.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.energy := x.energy;
    v.k := x.k.val; // long is silently truncated to TALGLIBInteger
    x_to_array(x.c, v.c);
    x_to_array(x.cidx, v.cidx);
end;


procedure _core_clusterizercreate(out  s: Tclusterizerstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_clusterizercreate(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizercreate call');
        end;
        s := Tclusterizerstate.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_clusterizerstate(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure clusterizercreate(out  s: Tclusterizerstate; const _xparams: UInt64 = 0);
begin
    _core_clusterizercreate(s, _xparams);
end;


procedure _core_clusterizersetpoints( s: Tclusterizerstate;  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger;  disttype: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nfeatures: NativeInt;
    _d_disttype: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nfeatures := nfeatures;
        _d_disttype := disttype;
        _error_code := x_xv2_clusterizersetpoints(@_s_error_msg, @_d_s, @_d_xy, @_d_npoints, @_d_nfeatures, @_d_disttype, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizersetpoints call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure clusterizersetpoints( s: Tclusterizerstate;  xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger;  disttype: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_clusterizersetpoints(s, xy, npoints, nfeatures, disttype, _xparams);
end;


procedure clusterizersetpoints( s: Tclusterizerstate;  xy: TMatrix;  disttype: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
var
    npoints: TALGLIBInteger;
    nfeatures: TALGLIBInteger;

begin

    npoints := xrows(xy);
    nfeatures := xcols(xy);

    _core_clusterizersetpoints(s, xy, npoints, nfeatures, disttype, _xparams);

end;


procedure _core_clusterizersetdistances( s: Tclusterizerstate;  d: TMatrix;  npoints: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_d: x_matrix;
    _d_npoints: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_d, d, X_CREATE);
        _d_npoints := npoints;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_clusterizersetdistances(@_s_error_msg, @_d_s, @_d_d, @_d_npoints, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizersetdistances call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_d);
    end;
end;


procedure clusterizersetdistances( s: Tclusterizerstate;  d: TMatrix;  npoints: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0);overload;
begin
    _core_clusterizersetdistances(s, d, npoints, isupper, _xparams);
end;


procedure clusterizersetdistances( s: Tclusterizerstate;  d: TMatrix;  isupper: Boolean; const _xparams: UInt64 = 0);overload;
var
    npoints: TALGLIBInteger;

begin
    if ((xrows(d)<>xcols(d))) then
    raise Exception.Create('Error while calling clusterizersetdistances: looks like one of arguments has wrong size');

    npoints := xrows(d);

    _core_clusterizersetdistances(s, d, npoints, isupper, _xparams);

end;


procedure _core_clusterizersetahcalgo( s: Tclusterizerstate;  algo: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_algo: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_algo := algo;
        _error_code := x_xv2_clusterizersetahcalgo(@_s_error_msg, @_d_s, @_d_algo, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizersetahcalgo call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure clusterizersetahcalgo( s: Tclusterizerstate;  algo: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_clusterizersetahcalgo(s, algo, _xparams);
end;


procedure _core_clusterizersetkmeanslimits( s: Tclusterizerstate;  restarts: TALGLIBInteger;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_restarts: NativeInt;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_restarts := restarts;
        _d_maxits := maxits;
        _error_code := x_xv2_clusterizersetkmeanslimits(@_s_error_msg, @_d_s, @_d_restarts, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizersetkmeanslimits call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure clusterizersetkmeanslimits( s: Tclusterizerstate;  restarts: TALGLIBInteger;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_clusterizersetkmeanslimits(s, restarts, maxits, _xparams);
end;


procedure _core_clusterizersetkmeansinit( s: Tclusterizerstate;  initalgo: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_initalgo: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_initalgo := initalgo;
        _error_code := x_xv2_clusterizersetkmeansinit(@_s_error_msg, @_d_s, @_d_initalgo, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizersetkmeansinit call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure clusterizersetkmeansinit( s: Tclusterizerstate;  initalgo: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_clusterizersetkmeansinit(s, initalgo, _xparams);
end;


procedure _core_clusterizersetseed( s: Tclusterizerstate;  seed: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_seed: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_seed := seed;
        _error_code := x_xv2_clusterizersetseed(@_s_error_msg, @_d_s, @_d_seed, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizersetseed call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure clusterizersetseed( s: Tclusterizerstate;  seed: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_clusterizersetseed(s, seed, _xparams);
end;


procedure _core_clusterizerrunahc( s: Tclusterizerstate; out  rep: Tahcreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_rep: x_ahcreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_ahcreport_init(_d_rep);
        _error_code := x_xv2_clusterizerrunahc(@_s_error_msg, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizerrunahc call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_ahcreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_ahcreport_clear(_d_rep);
    end;
end;


procedure clusterizerrunahc( s: Tclusterizerstate; out  rep: Tahcreport; const _xparams: UInt64 = 0);
begin
    _core_clusterizerrunahc(s, rep, _xparams);
end;


procedure _core_clusterizerrunkmeans( s: Tclusterizerstate;  k: TALGLIBInteger; out  rep: Tkmeansreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_k: NativeInt;
    _d_rep: x_kmeansreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_k := k;
        x_kmeansreport_init(_d_rep);
        _error_code := x_xv2_clusterizerrunkmeans(@_s_error_msg, @_d_s, @_d_k, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizerrunkmeans call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_kmeansreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_kmeansreport_clear(_d_rep);
    end;
end;


procedure clusterizerrunkmeans( s: Tclusterizerstate;  k: TALGLIBInteger; out  rep: Tkmeansreport; const _xparams: UInt64 = 0);
begin
    _core_clusterizerrunkmeans(s, k, rep, _xparams);
end;


procedure _core_clusterizergetdistances( xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger;  disttype: TALGLIBInteger; out  d: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nfeatures: NativeInt;
    _d_disttype: NativeInt;
    _d_d: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nfeatures := nfeatures;
        _d_disttype := disttype;
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        _error_code := x_xv2_clusterizergetdistances(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nfeatures, @_d_disttype, @_d_d, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizergetdistances call');
        end;
        x_to_array(_d_d, d);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_d);
    end;
end;


procedure clusterizergetdistances( xy: TMatrix;  npoints: TALGLIBInteger;  nfeatures: TALGLIBInteger;  disttype: TALGLIBInteger; out  d: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_clusterizergetdistances(xy, npoints, nfeatures, disttype, d, _xparams);
end;


procedure _core_clusterizergetkclusters( rep: Tahcreport;  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_rep: x_ahcreport;
    _d_k: NativeInt;
    _d_cidx: x_vector;
    _d_cz: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_ahcreport_init_from(_d_rep, rep);
        _d_k := k;
        x_create_empty(_d_cidx, DT_INT);
        cidx := nil;
        x_create_empty(_d_cz, DT_INT);
        cz := nil;
        _error_code := x_xv2_clusterizergetkclusters(@_s_error_msg, @_d_rep, @_d_k, @_d_cidx, @_d_cz, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizergetkclusters call');
        end;
        x_to_array(_d_cidx, cidx);
        x_to_array(_d_cz, cz);
    finally
        SetXExceptionMask(fpumask);
        x_ahcreport_clear(_d_rep);
        x_clear(_d_cidx);
        x_clear(_d_cz);
    end;
end;


procedure clusterizergetkclusters( rep: Tahcreport;  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; const _xparams: UInt64 = 0);
begin
    _core_clusterizergetkclusters(rep, k, cidx, cz, _xparams);
end;


procedure _core_clusterizerseparatedbydist( rep: Tahcreport;  r: Double; out  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_rep: x_ahcreport;
    _d_r: Double;
    _d_k: NativeInt;
    _d_cidx: x_vector;
    _d_cz: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_ahcreport_init_from(_d_rep, rep);
        _d_r := r;
        x_create_empty(_d_cidx, DT_INT);
        cidx := nil;
        x_create_empty(_d_cz, DT_INT);
        cz := nil;
        _error_code := x_xv2_clusterizerseparatedbydist(@_s_error_msg, @_d_rep, @_d_r, @_d_k, @_d_cidx, @_d_cz, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizerseparatedbydist call');
        end;
        k := _d_k;
        x_to_array(_d_cidx, cidx);
        x_to_array(_d_cz, cz);
    finally
        SetXExceptionMask(fpumask);
        x_ahcreport_clear(_d_rep);
        x_clear(_d_cidx);
        x_clear(_d_cz);
    end;
end;


procedure clusterizerseparatedbydist( rep: Tahcreport;  r: Double; out  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; const _xparams: UInt64 = 0);
begin
    _core_clusterizerseparatedbydist(rep, r, k, cidx, cz, _xparams);
end;


procedure _core_clusterizerseparatedbycorr( rep: Tahcreport;  r: Double; out  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_rep: x_ahcreport;
    _d_r: Double;
    _d_k: NativeInt;
    _d_cidx: x_vector;
    _d_cz: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_ahcreport_init_from(_d_rep, rep);
        _d_r := r;
        x_create_empty(_d_cidx, DT_INT);
        cidx := nil;
        x_create_empty(_d_cz, DT_INT);
        cz := nil;
        _error_code := x_xv2_clusterizerseparatedbycorr(@_s_error_msg, @_d_rep, @_d_r, @_d_k, @_d_cidx, @_d_cz, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during clusterizerseparatedbycorr call');
        end;
        k := _d_k;
        x_to_array(_d_cidx, cidx);
        x_to_array(_d_cz, cz);
    finally
        SetXExceptionMask(fpumask);
        x_ahcreport_clear(_d_rep);
        x_clear(_d_cidx);
        x_clear(_d_cz);
    end;
end;


procedure clusterizerseparatedbycorr( rep: Tahcreport;  r: Double; out  k: TALGLIBInteger; out  cidx: TIVector; out  cz: TIVector; const _xparams: UInt64 = 0);
begin
    _core_clusterizerseparatedbycorr(rep, r, k, cidx, cz, _xparams);
end;

constructor Tdecisionforestbuilder.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tdecisionforestbuilder.Destroy();
begin
    Deallocate();
end;

function Tdecisionforestbuilder.Clone():Tdecisionforestbuilder;
begin
    if ptr=nil then
        Result:=Tdecisionforestbuilder.Create(nil)
    else
        Result:=Tdecisionforestbuilder.Create(x_obj_copy_decisionforestbuilder(ptr));
end;

procedure Tdecisionforestbuilder.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_decisionforestbuilder(ptr);
    ptr:=nil;
end;

constructor Tdecisionforestbuffer.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tdecisionforestbuffer.Destroy();
begin
    Deallocate();
end;

function Tdecisionforestbuffer.Clone():Tdecisionforestbuffer;
begin
    if ptr=nil then
        Result:=Tdecisionforestbuffer.Create(nil)
    else
        Result:=Tdecisionforestbuffer.Create(x_obj_copy_decisionforestbuffer(ptr));
end;

procedure Tdecisionforestbuffer.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_decisionforestbuffer(ptr);
    ptr:=nil;
end;

constructor Tdecisionforest.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tdecisionforest.Destroy();
begin
    Deallocate();
end;

function Tdecisionforest.Clone():Tdecisionforest;
begin
    if ptr=nil then
        Result:=Tdecisionforest.Create(nil)
    else
        Result:=Tdecisionforest.Create(x_obj_copy_decisionforest(ptr));
end;

procedure Tdecisionforest.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_decisionforest(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tdfreport):Tdfreport;overload;
begin
    Result.relclserror := src.relclserror;
    Result.avgce := src.avgce;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
    Result.oobrelclserror := src.oobrelclserror;
    Result.oobavgce := src.oobavgce;
    Result.oobrmserror := src.oobrmserror;
    Result.oobavgerror := src.oobavgerror;
    Result.oobavgrelerror := src.oobavgrelerror;
    Result.topvars := Clone(src.topvars);
    Result.varimportances := Clone(src.varimportances);
end;

procedure x_dfreport_init(var x: x_dfreport);
begin
    x.relclserror := 0;
    x.avgce := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
    x.oobrelclserror := 0;
    x.oobavgce := 0;
    x.oobrmserror := 0;
    x.oobavgerror := 0;
    x.oobavgrelerror := 0;
    x_create_empty(x.topvars, DT_INT);
    x_create_empty(x.varimportances, DT_REAL);
end;

procedure x_dfreport_clear(var x: x_dfreport);
begin
    x_clear(x.topvars);
    x_clear(x.varimportances);
end;

procedure x_dfreport_init_from(var x: x_dfreport; const v: Tdfreport);
begin
    x.relclserror := v.relclserror;
    x.avgce := v.avgce;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
    x.oobrelclserror := v.oobrelclserror;
    x.oobavgce := v.oobavgce;
    x.oobrmserror := v.oobrmserror;
    x.oobavgerror := v.oobavgerror;
    x.oobavgrelerror := v.oobavgrelerror;
    x_from_array(x.topvars, v.topvars, X_CREATE);
    x_from_array(x.varimportances, v.varimportances, X_CREATE);
end;

procedure x_dfreport_to_record(const x: x_dfreport; var v: Tdfreport);
begin
    v.relclserror := x.relclserror;
    v.avgce := x.avgce;
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
    v.oobrelclserror := x.oobrelclserror;
    v.oobavgce := x.oobavgce;
    v.oobrmserror := x.oobrmserror;
    v.oobavgerror := x.oobavgerror;
    v.oobavgrelerror := x.oobavgrelerror;
    x_to_array(x.topvars, v.topvars);
    x_to_array(x.varimportances, v.varimportances);
end;

procedure dfserialize(const obj: Tdecisionforest; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_dfserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure dfunserialize(const s_in: AnsiString; out obj: Tdecisionforest);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_dfunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfunserialize() call');
        end;
        obj:=Tdecisionforest.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_decisionforest(_x);
    end;
end;

procedure dfserialize(const obj: Tdecisionforest; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_dfserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during dfserialize_stream() call');
    end;
end;

procedure dfunserialize(stream: TStream; out obj: Tdecisionforest);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_dfunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfunserialize_stream() call');
        end;
        obj:=Tdecisionforest.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_decisionforest(_x);
    end;
end;


procedure _core_dfcreatebuffer( model: Tdecisionforest; out  buf: Tdecisionforestbuffer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_model : Pointer;
    _d_buf : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        _d_buf := nil;
        buf := nil;
        _error_code := x_xv2_dfcreatebuffer(@_s_error_msg, @_d_model, @_d_buf, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfcreatebuffer call');
        end;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
        buf := Tdecisionforestbuffer.Create(_d_buf);
    finally
        SetXExceptionMask(fpumask);
        if (_d_buf<>nil) and (buf=nil) then
            x_obj_free_decisionforestbuffer(_d_buf); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure dfcreatebuffer( model: Tdecisionforest; out  buf: Tdecisionforestbuffer; const _xparams: UInt64 = 0);
begin
    _core_dfcreatebuffer(model, buf, _xparams);
end;


procedure _core_dfbuildercreate(out  s: Tdecisionforestbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_dfbuildercreate(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildercreate call');
        end;
        s := Tdecisionforestbuilder.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_decisionforestbuilder(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure dfbuildercreate(out  s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
begin
    _core_dfbuildercreate(s, _xparams);
end;


procedure _core_dfbuildersetdataset( s: Tdecisionforestbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        _error_code := x_xv2_dfbuildersetdataset(@_s_error_msg, @_d_s, @_d_xy, @_d_npoints, @_d_nvars, @_d_nclasses, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetdataset call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure dfbuildersetdataset( s: Tdecisionforestbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetdataset(s, xy, npoints, nvars, nclasses, _xparams);
end;


procedure _core_dfbuildersetrndvars( s: Tdecisionforestbuilder;  rndvars: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_rndvars: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_rndvars := rndvars;
        _error_code := x_xv2_dfbuildersetrndvars(@_s_error_msg, @_d_s, @_d_rndvars, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetrndvars call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetrndvars( s: Tdecisionforestbuilder;  rndvars: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetrndvars(s, rndvars, _xparams);
end;


procedure _core_dfbuildersetrndvarsratio( s: Tdecisionforestbuilder;  f: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_f: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_f := f;
        _error_code := x_xv2_dfbuildersetrndvarsratio(@_s_error_msg, @_d_s, @_d_f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetrndvarsratio call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetrndvarsratio( s: Tdecisionforestbuilder;  f: Double; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetrndvarsratio(s, f, _xparams);
end;


procedure _core_dfbuildersetrndvarsauto( s: Tdecisionforestbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_dfbuildersetrndvarsauto(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetrndvarsauto call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetrndvarsauto( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetrndvarsauto(s, _xparams);
end;


procedure _core_dfbuildersetsubsampleratio( s: Tdecisionforestbuilder;  f: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_f: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_f := f;
        _error_code := x_xv2_dfbuildersetsubsampleratio(@_s_error_msg, @_d_s, @_d_f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetsubsampleratio call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetsubsampleratio( s: Tdecisionforestbuilder;  f: Double; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetsubsampleratio(s, f, _xparams);
end;


procedure _core_dfbuildersetseed( s: Tdecisionforestbuilder;  seedval: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_seedval: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_seedval := seedval;
        _error_code := x_xv2_dfbuildersetseed(@_s_error_msg, @_d_s, @_d_seedval, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetseed call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetseed( s: Tdecisionforestbuilder;  seedval: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetseed(s, seedval, _xparams);
end;


procedure _core_dfbuildersetrdfalgo( s: Tdecisionforestbuilder;  algotype: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_algotype: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_algotype := algotype;
        _error_code := x_xv2_dfbuildersetrdfalgo(@_s_error_msg, @_d_s, @_d_algotype, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetrdfalgo call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetrdfalgo( s: Tdecisionforestbuilder;  algotype: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetrdfalgo(s, algotype, _xparams);
end;


procedure _core_dfbuildersetrdfsplitstrength( s: Tdecisionforestbuilder;  splitstrength: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_splitstrength: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_splitstrength := splitstrength;
        _error_code := x_xv2_dfbuildersetrdfsplitstrength(@_s_error_msg, @_d_s, @_d_splitstrength, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetrdfsplitstrength call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetrdfsplitstrength( s: Tdecisionforestbuilder;  splitstrength: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetrdfsplitstrength(s, splitstrength, _xparams);
end;


procedure _core_dfbuildersetimportancetrngini( s: Tdecisionforestbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_dfbuildersetimportancetrngini(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetimportancetrngini call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetimportancetrngini( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetimportancetrngini(s, _xparams);
end;


procedure _core_dfbuildersetimportanceoobgini( s: Tdecisionforestbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_dfbuildersetimportanceoobgini(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetimportanceoobgini call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetimportanceoobgini( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetimportanceoobgini(s, _xparams);
end;


procedure _core_dfbuildersetimportancepermutation( s: Tdecisionforestbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_dfbuildersetimportancepermutation(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetimportancepermutation call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetimportancepermutation( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetimportancepermutation(s, _xparams);
end;


procedure _core_dfbuildersetimportancenone( s: Tdecisionforestbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_dfbuildersetimportancenone(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildersetimportancenone call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure dfbuildersetimportancenone( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0);
begin
    _core_dfbuildersetimportancenone(s, _xparams);
end;


function _core_dfbuildergetprogress( s: Tdecisionforestbuilder; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_dfbuildergetprogress(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildergetprogress call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function dfbuildergetprogress( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfbuildergetprogress(s, _xparams);
end;


function _core_dfbuilderpeekprogress( s: Tdecisionforestbuilder; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_dfbuilderpeekprogress(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuilderpeekprogress call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function dfbuilderpeekprogress( s: Tdecisionforestbuilder; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfbuilderpeekprogress(s, _xparams);
end;


procedure _core_dfbuilderbuildrandomforest( s: Tdecisionforestbuilder;  ntrees: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_ntrees: NativeInt;
    _d_df : Pointer;
    _d_rep: x_dfreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_ntrees := ntrees;
        _d_df := nil;
        df := nil;
        x_dfreport_init(_d_rep);
        _error_code := x_xv2_dfbuilderbuildrandomforest(@_s_error_msg, @_d_s, @_d_ntrees, @_d_df, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuilderbuildrandomforest call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        df := Tdecisionforest.Create(_d_df);
        x_dfreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        if (_d_df<>nil) and (df=nil) then
            x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to Delphi objects
        x_dfreport_clear(_d_rep);
    end;
end;


procedure dfbuilderbuildrandomforest( s: Tdecisionforestbuilder;  ntrees: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; const _xparams: UInt64 = 0);
begin
    _core_dfbuilderbuildrandomforest(s, ntrees, df, rep, _xparams);
end;


function _core_dfbinarycompression( df: Tdecisionforest; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_df : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        _error_code := x_xv2_dfbinarycompression(@_s_error_msg, @_d_result, @_d_df, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbinarycompression call');
        end;
        result := _d_result;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function dfbinarycompression( df: Tdecisionforest; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfbinarycompression(df, _xparams);
end;


procedure _core_dfprocess( df: Tdecisionforest;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_df : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_dfprocess(@_s_error_msg, @_d_df, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfprocess call');
        end;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure dfprocess( df: Tdecisionforest;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_dfprocess(df, x, y, _xparams);
end;


procedure _core_dfprocessi( df: Tdecisionforest;  x: TVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_df : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_dfprocessi(@_s_error_msg, @_d_df, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfprocessi call');
        end;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure dfprocessi( df: Tdecisionforest;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_dfprocessi(df, x, y, _xparams);
end;


function _core_dfprocess0( model: Tdecisionforest;  x: TVector; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_model : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_dfprocess0(@_s_error_msg, @_d_result, @_d_model, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfprocess0 call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function dfprocess0( model: Tdecisionforest;  x: TVector; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfprocess0(model, x, _xparams);
end;


function _core_dfclassify( model: Tdecisionforest;  x: TVector; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_model : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_dfclassify(@_s_error_msg, @_d_result, @_d_model, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfclassify call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function dfclassify( model: Tdecisionforest;  x: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_dfclassify(model, x, _xparams);
end;


procedure _core_dftsprocess( df: Tdecisionforest;  buf: Tdecisionforestbuffer;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_df : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_dftsprocess(@_s_error_msg, @_d_df, @_d_buf, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dftsprocess call');
        end;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure dftsprocess( df: Tdecisionforest;  buf: Tdecisionforestbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_dftsprocess(df, buf, x, y, _xparams);
end;


function _core_dfrelclserror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_df : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_dfrelclserror(@_s_error_msg, @_d_result, @_d_df, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfrelclserror call');
        end;
        result := _d_result;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function dfrelclserror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfrelclserror(df, xy, npoints, _xparams);
end;


function _core_dfavgce( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_df : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_dfavgce(@_s_error_msg, @_d_result, @_d_df, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfavgce call');
        end;
        result := _d_result;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function dfavgce( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfavgce(df, xy, npoints, _xparams);
end;


function _core_dfrmserror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_df : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_dfrmserror(@_s_error_msg, @_d_result, @_d_df, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfrmserror call');
        end;
        result := _d_result;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function dfrmserror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfrmserror(df, xy, npoints, _xparams);
end;


function _core_dfavgerror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_df : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_dfavgerror(@_s_error_msg, @_d_result, @_d_df, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfavgerror call');
        end;
        result := _d_result;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function dfavgerror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfavgerror(df, xy, npoints, _xparams);
end;


function _core_dfavgrelerror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_df : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_df := df.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_dfavgrelerror(@_s_error_msg, @_d_result, @_d_df, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfavgrelerror call');
        end;
        result := _d_result;
        Assert(df.ptr=_d_df, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function dfavgrelerror( df: Tdecisionforest;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dfavgrelerror(df, xy, npoints, _xparams);
end;


procedure _core_dfbuildrandomdecisionforest( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger;  ntrees: TALGLIBInteger;  r: Double; out  info: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
    _d_ntrees: NativeInt;
    _d_r: Double;
    _d_info: NativeInt;
    _d_df : Pointer;
    _d_rep: x_dfreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        _d_ntrees := ntrees;
        _d_r := r;
        _d_df := nil;
        df := nil;
        x_dfreport_init(_d_rep);
        _error_code := x_xv2_dfbuildrandomdecisionforest(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_nclasses, @_d_ntrees, @_d_r, @_d_info, @_d_df, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildrandomdecisionforest call');
        end;
        info := _d_info;
        df := Tdecisionforest.Create(_d_df);
        x_dfreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_df<>nil) and (df=nil) then
            x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to Delphi objects
        x_dfreport_clear(_d_rep);
    end;
end;


procedure dfbuildrandomdecisionforest( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger;  ntrees: TALGLIBInteger;  r: Double; out  info: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; const _xparams: UInt64 = 0);
begin
    _core_dfbuildrandomdecisionforest(xy, npoints, nvars, nclasses, ntrees, r, info, df, rep, _xparams);
end;


procedure _core_dfbuildrandomdecisionforestx1( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger;  ntrees: TALGLIBInteger;  nrndvars: TALGLIBInteger;  r: Double; out  info: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
    _d_ntrees: NativeInt;
    _d_nrndvars: NativeInt;
    _d_r: Double;
    _d_info: NativeInt;
    _d_df : Pointer;
    _d_rep: x_dfreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        _d_ntrees := ntrees;
        _d_nrndvars := nrndvars;
        _d_r := r;
        _d_df := nil;
        df := nil;
        x_dfreport_init(_d_rep);
        _error_code := x_xv2_dfbuildrandomdecisionforestx1(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_nclasses, @_d_ntrees, @_d_nrndvars, @_d_r, @_d_info, @_d_df, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dfbuildrandomdecisionforestx1 call');
        end;
        info := _d_info;
        df := Tdecisionforest.Create(_d_df);
        x_dfreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_df<>nil) and (df=nil) then
            x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to Delphi objects
        x_dfreport_clear(_d_rep);
    end;
end;


procedure dfbuildrandomdecisionforestx1( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger;  ntrees: TALGLIBInteger;  nrndvars: TALGLIBInteger;  r: Double; out  info: TALGLIBInteger; out  df: Tdecisionforest; out  rep: Tdfreport; const _xparams: UInt64 = 0);
begin
    _core_dfbuildrandomdecisionforestx1(xy, npoints, nvars, nclasses, ntrees, nrndvars, r, info, df, rep, _xparams);
end;

constructor Tknnbuffer.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tknnbuffer.Destroy();
begin
    Deallocate();
end;

function Tknnbuffer.Clone():Tknnbuffer;
begin
    if ptr=nil then
        Result:=Tknnbuffer.Create(nil)
    else
        Result:=Tknnbuffer.Create(x_obj_copy_knnbuffer(ptr));
end;

procedure Tknnbuffer.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_knnbuffer(ptr);
    ptr:=nil;
end;

constructor Tknnbuilder.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tknnbuilder.Destroy();
begin
    Deallocate();
end;

function Tknnbuilder.Clone():Tknnbuilder;
begin
    if ptr=nil then
        Result:=Tknnbuilder.Create(nil)
    else
        Result:=Tknnbuilder.Create(x_obj_copy_knnbuilder(ptr));
end;

procedure Tknnbuilder.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_knnbuilder(ptr);
    ptr:=nil;
end;

constructor Tknnmodel.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tknnmodel.Destroy();
begin
    Deallocate();
end;

function Tknnmodel.Clone():Tknnmodel;
begin
    if ptr=nil then
        Result:=Tknnmodel.Create(nil)
    else
        Result:=Tknnmodel.Create(x_obj_copy_knnmodel(ptr));
end;

procedure Tknnmodel.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_knnmodel(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tknnreport):Tknnreport;overload;
begin
    Result.relclserror := src.relclserror;
    Result.avgce := src.avgce;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
end;

procedure x_knnreport_init(var x: x_knnreport);
begin
    x.relclserror := 0;
    x.avgce := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
end;

procedure x_knnreport_clear(var x: x_knnreport);
begin
end;

procedure x_knnreport_init_from(var x: x_knnreport; const v: Tknnreport);
begin
    x.relclserror := v.relclserror;
    x.avgce := v.avgce;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
end;

procedure x_knnreport_to_record(const x: x_knnreport; var v: Tknnreport);
begin
    v.relclserror := x.relclserror;
    v.avgce := x.avgce;
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
end;

procedure knnserialize(const obj: Tknnmodel; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_knnserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure knnunserialize(const s_in: AnsiString; out obj: Tknnmodel);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_knnunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnunserialize() call');
        end;
        obj:=Tknnmodel.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_knnmodel(_x);
    end;
end;

procedure knnserialize(const obj: Tknnmodel; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_knnserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during knnserialize_stream() call');
    end;
end;

procedure knnunserialize(stream: TStream; out obj: Tknnmodel);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_knnunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnunserialize_stream() call');
        end;
        obj:=Tknnmodel.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_knnmodel(_x);
    end;
end;


procedure _core_knncreatebuffer( model: Tknnmodel; out  buf: Tknnbuffer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_model : Pointer;
    _d_buf : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        _d_buf := nil;
        buf := nil;
        _error_code := x_xv2_knncreatebuffer(@_s_error_msg, @_d_model, @_d_buf, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knncreatebuffer call');
        end;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
        buf := Tknnbuffer.Create(_d_buf);
    finally
        SetXExceptionMask(fpumask);
        if (_d_buf<>nil) and (buf=nil) then
            x_obj_free_knnbuffer(_d_buf); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure knncreatebuffer( model: Tknnmodel; out  buf: Tknnbuffer; const _xparams: UInt64 = 0);
begin
    _core_knncreatebuffer(model, buf, _xparams);
end;


procedure _core_knnbuildercreate(out  s: Tknnbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_knnbuildercreate(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnbuildercreate call');
        end;
        s := Tknnbuilder.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_knnbuilder(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure knnbuildercreate(out  s: Tknnbuilder; const _xparams: UInt64 = 0);
begin
    _core_knnbuildercreate(s, _xparams);
end;


procedure _core_knnbuildersetdatasetreg( s: Tknnbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nout: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nout: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nout := nout;
        _error_code := x_xv2_knnbuildersetdatasetreg(@_s_error_msg, @_d_s, @_d_xy, @_d_npoints, @_d_nvars, @_d_nout, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnbuildersetdatasetreg call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure knnbuildersetdatasetreg( s: Tknnbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nout: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_knnbuildersetdatasetreg(s, xy, npoints, nvars, nout, _xparams);
end;


procedure _core_knnbuildersetdatasetcls( s: Tknnbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_nclasses: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_nclasses := nclasses;
        _error_code := x_xv2_knnbuildersetdatasetcls(@_s_error_msg, @_d_s, @_d_xy, @_d_npoints, @_d_nvars, @_d_nclasses, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnbuildersetdatasetcls call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure knnbuildersetdatasetcls( s: Tknnbuilder;  xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  nclasses: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_knnbuildersetdatasetcls(s, xy, npoints, nvars, nclasses, _xparams);
end;


procedure _core_knnbuildersetnorm( s: Tknnbuilder;  nrmtype: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_nrmtype: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_nrmtype := nrmtype;
        _error_code := x_xv2_knnbuildersetnorm(@_s_error_msg, @_d_s, @_d_nrmtype, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnbuildersetnorm call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure knnbuildersetnorm( s: Tknnbuilder;  nrmtype: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_knnbuildersetnorm(s, nrmtype, _xparams);
end;


procedure _core_knnbuilderbuildknnmodel( s: Tknnbuilder;  k: TALGLIBInteger;  eps: Double; out  model: Tknnmodel; out  rep: Tknnreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_k: NativeInt;
    _d_eps: Double;
    _d_model : Pointer;
    _d_rep: x_knnreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_k := k;
        _d_eps := eps;
        _d_model := nil;
        model := nil;
        x_knnreport_init(_d_rep);
        _error_code := x_xv2_knnbuilderbuildknnmodel(@_s_error_msg, @_d_s, @_d_k, @_d_eps, @_d_model, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnbuilderbuildknnmodel call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        model := Tknnmodel.Create(_d_model);
        x_knnreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        if (_d_model<>nil) and (model=nil) then
            x_obj_free_knnmodel(_d_model); // on exception clean up X objects which were not attached to Delphi objects
        x_knnreport_clear(_d_rep);
    end;
end;


procedure knnbuilderbuildknnmodel( s: Tknnbuilder;  k: TALGLIBInteger;  eps: Double; out  model: Tknnmodel; out  rep: Tknnreport; const _xparams: UInt64 = 0);
begin
    _core_knnbuilderbuildknnmodel(s, k, eps, model, rep, _xparams);
end;


procedure _core_knnrewritekeps( model: Tknnmodel;  k: TALGLIBInteger;  eps: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_model : Pointer;
    _d_k: NativeInt;
    _d_eps: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        _d_k := k;
        _d_eps := eps;
        _error_code := x_xv2_knnrewritekeps(@_s_error_msg, @_d_model, @_d_k, @_d_eps, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnrewritekeps call');
        end;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure knnrewritekeps( model: Tknnmodel;  k: TALGLIBInteger;  eps: Double; const _xparams: UInt64 = 0);
begin
    _core_knnrewritekeps(model, k, eps, _xparams);
end;


procedure _core_knnprocess( model: Tknnmodel;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_model : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_knnprocess(@_s_error_msg, @_d_model, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnprocess call');
        end;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure knnprocess( model: Tknnmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_knnprocess(model, x, y, _xparams);
end;


function _core_knnprocess0( model: Tknnmodel;  x: TVector; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_model : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_knnprocess0(@_s_error_msg, @_d_result, @_d_model, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnprocess0 call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function knnprocess0( model: Tknnmodel;  x: TVector; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_knnprocess0(model, x, _xparams);
end;


function _core_knnclassify( model: Tknnmodel;  x: TVector; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_model : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_knnclassify(@_s_error_msg, @_d_result, @_d_model, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnclassify call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


function knnclassify( model: Tknnmodel;  x: TVector; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_knnclassify(model, x, _xparams);
end;


procedure _core_knnprocessi( model: Tknnmodel;  x: TVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_model : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_knnprocessi(@_s_error_msg, @_d_model, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnprocessi call');
        end;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure knnprocessi( model: Tknnmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_knnprocessi(model, x, y, _xparams);
end;


procedure _core_knntsprocess( model: Tknnmodel;  buf: Tknnbuffer;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_model : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_knntsprocess(@_s_error_msg, @_d_model, @_d_buf, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knntsprocess call');
        end;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure knntsprocess( model: Tknnmodel;  buf: Tknnbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_knntsprocess(model, buf, x, y, _xparams);
end;


function _core_knnrelclserror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_model : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_knnrelclserror(@_s_error_msg, @_d_result, @_d_model, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnrelclserror call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function knnrelclserror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_knnrelclserror(model, xy, npoints, _xparams);
end;


function _core_knnavgce( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_model : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_knnavgce(@_s_error_msg, @_d_result, @_d_model, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnavgce call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function knnavgce( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_knnavgce(model, xy, npoints, _xparams);
end;


function _core_knnrmserror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_model : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_knnrmserror(@_s_error_msg, @_d_result, @_d_model, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnrmserror call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function knnrmserror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_knnrmserror(model, xy, npoints, _xparams);
end;


function _core_knnavgerror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_model : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_knnavgerror(@_s_error_msg, @_d_result, @_d_model, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnavgerror call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function knnavgerror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_knnavgerror(model, xy, npoints, _xparams);
end;


function _core_knnavgrelerror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_model : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _error_code := x_xv2_knnavgrelerror(@_s_error_msg, @_d_result, @_d_model, @_d_xy, @_d_npoints, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnavgrelerror call');
        end;
        result := _d_result;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


function knnavgrelerror( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_knnavgrelerror(model, xy, npoints, _xparams);
end;


procedure _core_knnallerrors( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; out  rep: Tknnreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_model : Pointer;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_rep: x_knnreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_model := model.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        x_knnreport_init(_d_rep);
        _error_code := x_xv2_knnallerrors(@_s_error_msg, @_d_model, @_d_xy, @_d_npoints, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during knnallerrors call');
        end;
        Assert(model.ptr=_d_model, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_knnreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_knnreport_clear(_d_rep);
    end;
end;


procedure knnallerrors( model: Tknnmodel;  xy: TMatrix;  npoints: TALGLIBInteger; out  rep: Tknnreport; const _xparams: UInt64 = 0);
begin
    _core_knnallerrors(model, xy, npoints, rep, _xparams);
end;


procedure _core_kmeansgenerate( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  k: TALGLIBInteger;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TMatrix; out  xyc: TIVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nvars: NativeInt;
    _d_k: NativeInt;
    _d_restarts: NativeInt;
    _d_info: NativeInt;
    _d_c: x_matrix;
    _d_xyc: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nvars := nvars;
        _d_k := k;
        _d_restarts := restarts;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        x_create_empty(_d_xyc, DT_INT);
        xyc := nil;
        _error_code := x_xv2_kmeansgenerate(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nvars, @_d_k, @_d_restarts, @_d_info, @_d_c, @_d_xyc, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during kmeansgenerate call');
        end;
        info := _d_info;
        x_to_array(_d_c, c);
        x_to_array(_d_xyc, xyc);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_c);
        x_clear(_d_xyc);
    end;
end;


procedure kmeansgenerate( xy: TMatrix;  npoints: TALGLIBInteger;  nvars: TALGLIBInteger;  k: TALGLIBInteger;  restarts: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TMatrix; out  xyc: TIVector; const _xparams: UInt64 = 0);
begin
    _core_kmeansgenerate(xy, npoints, nvars, k, restarts, info, c, xyc, _xparams);
end;


procedure _core_gqgeneraterec( alpha: TVector;  beta: TVector;  mu0: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_alpha: x_vector;
    _d_beta: x_vector;
    _d_mu0: Double;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_alpha, alpha, X_CREATE);
        x_from_array(_d_beta, beta, X_CREATE);
        _d_mu0 := mu0;
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_gqgeneraterec(@_s_error_msg, @_d_alpha, @_d_beta, @_d_mu0, @_d_n, @_d_info, @_d_x, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gqgeneraterec call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_alpha);
        x_clear(_d_beta);
        x_clear(_d_x);
        x_clear(_d_w);
    end;
end;


procedure gqgeneraterec( alpha: TVector;  beta: TVector;  mu0: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_gqgeneraterec(alpha, beta, mu0, n, info, x, w, _xparams);
end;


procedure _core_gqgenerategausslobattorec( alpha: TVector;  beta: TVector;  mu0: Double;  a: Double;  b: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_alpha: x_vector;
    _d_beta: x_vector;
    _d_mu0: Double;
    _d_a: Double;
    _d_b: Double;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_alpha, alpha, X_CREATE);
        x_from_array(_d_beta, beta, X_CREATE);
        _d_mu0 := mu0;
        _d_a := a;
        _d_b := b;
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_gqgenerategausslobattorec(@_s_error_msg, @_d_alpha, @_d_beta, @_d_mu0, @_d_a, @_d_b, @_d_n, @_d_info, @_d_x, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gqgenerategausslobattorec call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_alpha);
        x_clear(_d_beta);
        x_clear(_d_x);
        x_clear(_d_w);
    end;
end;


procedure gqgenerategausslobattorec( alpha: TVector;  beta: TVector;  mu0: Double;  a: Double;  b: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_gqgenerategausslobattorec(alpha, beta, mu0, a, b, n, info, x, w, _xparams);
end;


procedure _core_gqgenerategaussradaurec( alpha: TVector;  beta: TVector;  mu0: Double;  a: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_alpha: x_vector;
    _d_beta: x_vector;
    _d_mu0: Double;
    _d_a: Double;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_alpha, alpha, X_CREATE);
        x_from_array(_d_beta, beta, X_CREATE);
        _d_mu0 := mu0;
        _d_a := a;
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_gqgenerategaussradaurec(@_s_error_msg, @_d_alpha, @_d_beta, @_d_mu0, @_d_a, @_d_n, @_d_info, @_d_x, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gqgenerategaussradaurec call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_alpha);
        x_clear(_d_beta);
        x_clear(_d_x);
        x_clear(_d_w);
    end;
end;


procedure gqgenerategaussradaurec( alpha: TVector;  beta: TVector;  mu0: Double;  a: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_gqgenerategaussradaurec(alpha, beta, mu0, a, n, info, x, w, _xparams);
end;


procedure _core_gqgenerategausslegendre( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_gqgenerategausslegendre(@_s_error_msg, @_d_n, @_d_info, @_d_x, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gqgenerategausslegendre call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_w);
    end;
end;


procedure gqgenerategausslegendre( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_gqgenerategausslegendre(n, info, x, w, _xparams);
end;


procedure _core_gqgenerategaussjacobi( n: TALGLIBInteger;  alpha: Double;  beta: Double; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_alpha: Double;
    _d_beta: Double;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_alpha := alpha;
        _d_beta := beta;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_gqgenerategaussjacobi(@_s_error_msg, @_d_n, @_d_alpha, @_d_beta, @_d_info, @_d_x, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gqgenerategaussjacobi call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_w);
    end;
end;


procedure gqgenerategaussjacobi( n: TALGLIBInteger;  alpha: Double;  beta: Double; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_gqgenerategaussjacobi(n, alpha, beta, info, x, w, _xparams);
end;


procedure _core_gqgenerategausslaguerre( n: TALGLIBInteger;  alpha: Double; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_alpha: Double;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_alpha := alpha;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_gqgenerategausslaguerre(@_s_error_msg, @_d_n, @_d_alpha, @_d_info, @_d_x, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gqgenerategausslaguerre call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_w);
    end;
end;


procedure gqgenerategausslaguerre( n: TALGLIBInteger;  alpha: Double; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_gqgenerategausslaguerre(n, alpha, info, x, w, _xparams);
end;


procedure _core_gqgenerategausshermite( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_gqgenerategausshermite(@_s_error_msg, @_d_n, @_d_info, @_d_x, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gqgenerategausshermite call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_w);
    end;
end;


procedure gqgenerategausshermite( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_gqgenerategausshermite(n, info, x, w, _xparams);
end;


procedure _core_gkqgeneraterec( alpha: TVector;  beta: TVector;  mu0: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_alpha: x_vector;
    _d_beta: x_vector;
    _d_mu0: Double;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_wkronrod: x_vector;
    _d_wgauss: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_alpha, alpha, X_CREATE);
        x_from_array(_d_beta, beta, X_CREATE);
        _d_mu0 := mu0;
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_wkronrod, DT_REAL);
        wkronrod := nil;
        x_create_empty(_d_wgauss, DT_REAL);
        wgauss := nil;
        _error_code := x_xv2_gkqgeneraterec(@_s_error_msg, @_d_alpha, @_d_beta, @_d_mu0, @_d_n, @_d_info, @_d_x, @_d_wkronrod, @_d_wgauss, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gkqgeneraterec call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_wkronrod, wkronrod);
        x_to_array(_d_wgauss, wgauss);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_alpha);
        x_clear(_d_beta);
        x_clear(_d_x);
        x_clear(_d_wkronrod);
        x_clear(_d_wgauss);
    end;
end;


procedure gkqgeneraterec( alpha: TVector;  beta: TVector;  mu0: Double;  n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
begin
    _core_gkqgeneraterec(alpha, beta, mu0, n, info, x, wkronrod, wgauss, _xparams);
end;


procedure _core_gkqgenerategausslegendre( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_wkronrod: x_vector;
    _d_wgauss: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_wkronrod, DT_REAL);
        wkronrod := nil;
        x_create_empty(_d_wgauss, DT_REAL);
        wgauss := nil;
        _error_code := x_xv2_gkqgenerategausslegendre(@_s_error_msg, @_d_n, @_d_info, @_d_x, @_d_wkronrod, @_d_wgauss, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gkqgenerategausslegendre call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_wkronrod, wkronrod);
        x_to_array(_d_wgauss, wgauss);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_wkronrod);
        x_clear(_d_wgauss);
    end;
end;


procedure gkqgenerategausslegendre( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
begin
    _core_gkqgenerategausslegendre(n, info, x, wkronrod, wgauss, _xparams);
end;


procedure _core_gkqgenerategaussjacobi( n: TALGLIBInteger;  alpha: Double;  beta: Double; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_alpha: Double;
    _d_beta: Double;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_wkronrod: x_vector;
    _d_wgauss: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_alpha := alpha;
        _d_beta := beta;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_wkronrod, DT_REAL);
        wkronrod := nil;
        x_create_empty(_d_wgauss, DT_REAL);
        wgauss := nil;
        _error_code := x_xv2_gkqgenerategaussjacobi(@_s_error_msg, @_d_n, @_d_alpha, @_d_beta, @_d_info, @_d_x, @_d_wkronrod, @_d_wgauss, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gkqgenerategaussjacobi call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_wkronrod, wkronrod);
        x_to_array(_d_wgauss, wgauss);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_wkronrod);
        x_clear(_d_wgauss);
    end;
end;


procedure gkqgenerategaussjacobi( n: TALGLIBInteger;  alpha: Double;  beta: Double; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
begin
    _core_gkqgenerategaussjacobi(n, alpha, beta, info, x, wkronrod, wgauss, _xparams);
end;


procedure _core_gkqlegendrecalc( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_info: NativeInt;
    _d_x: x_vector;
    _d_wkronrod: x_vector;
    _d_wgauss: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_wkronrod, DT_REAL);
        wkronrod := nil;
        x_create_empty(_d_wgauss, DT_REAL);
        wgauss := nil;
        _error_code := x_xv2_gkqlegendrecalc(@_s_error_msg, @_d_n, @_d_info, @_d_x, @_d_wkronrod, @_d_wgauss, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gkqlegendrecalc call');
        end;
        info := _d_info;
        x_to_array(_d_x, x);
        x_to_array(_d_wkronrod, wkronrod);
        x_to_array(_d_wgauss, wgauss);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_wkronrod);
        x_clear(_d_wgauss);
    end;
end;


procedure gkqlegendrecalc( n: TALGLIBInteger; out  info: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; const _xparams: UInt64 = 0);
begin
    _core_gkqlegendrecalc(n, info, x, wkronrod, wgauss, _xparams);
end;


procedure _core_gkqlegendretbl( n: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; out  eps: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_wkronrod: x_vector;
    _d_wgauss: x_vector;
    _d_eps: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_wkronrod, DT_REAL);
        wkronrod := nil;
        x_create_empty(_d_wgauss, DT_REAL);
        wgauss := nil;
        _error_code := x_xv2_gkqlegendretbl(@_s_error_msg, @_d_n, @_d_x, @_d_wkronrod, @_d_wgauss, @_d_eps, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during gkqlegendretbl call');
        end;
        x_to_array(_d_x, x);
        x_to_array(_d_wkronrod, wkronrod);
        x_to_array(_d_wgauss, wgauss);
        eps := _d_eps;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_wkronrod);
        x_clear(_d_wgauss);
    end;
end;


procedure gkqlegendretbl( n: TALGLIBInteger; out  x: TVector; out  wkronrod: TVector; out  wgauss: TVector; out  eps: Double; const _xparams: UInt64 = 0);
begin
    _core_gkqlegendretbl(n, x, wkronrod, wgauss, eps, _xparams);
end;

function Clone(const Src: Tautogkreport):Tautogkreport;overload;
begin
    Result.terminationtype := src.terminationtype;
    Result.nfev := src.nfev;
    Result.nintervals := src.nintervals;
end;

procedure x_autogkreport_init(var x: x_autogkreport);
begin
    x.terminationtype.longval := 0;
    x.nfev.longval := 0;
    x.nintervals.longval := 0;
end;

procedure x_autogkreport_clear(var x: x_autogkreport);
begin
end;

procedure x_autogkreport_init_from(var x: x_autogkreport; const v: Tautogkreport);
begin
    x.terminationtype.longval := v.terminationtype;
    x.nfev.longval := v.nfev;
    x.nintervals.longval := v.nintervals;
end;

procedure x_autogkreport_to_record(const x: x_autogkreport; var v: Tautogkreport);
begin
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.nfev := x.nfev.val; // long is silently truncated to TALGLIBInteger
    v.nintervals := x.nintervals.val; // long is silently truncated to TALGLIBInteger
end;

constructor Tautogkstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tautogkstate.Destroy();
begin
    Deallocate();
end;

function Tautogkstate.Clone():Tautogkstate;
begin
    if ptr=nil then
        Result:=Tautogkstate.Create(nil)
    else
        Result:=Tautogkstate.Create(x_obj_copy_autogkstate(ptr));
end;

procedure Tautogkstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_autogkstate(ptr);
    ptr:=nil;
end;


procedure _core_autogksmooth( a: Double;  b: Double; out  state: Tautogkstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: Double;
    _d_b: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_autogksmooth(@_s_error_msg, @_d_a, @_d_b, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during autogksmooth call');
        end;
        state := Tautogkstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure autogksmooth( a: Double;  b: Double; out  state: Tautogkstate; const _xparams: UInt64 = 0);
begin
    _core_autogksmooth(a, b, state, _xparams);
end;


procedure _core_autogksmoothw( a: Double;  b: Double;  xwidth: Double; out  state: Tautogkstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: Double;
    _d_b: Double;
    _d_xwidth: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_xwidth := xwidth;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_autogksmoothw(@_s_error_msg, @_d_a, @_d_b, @_d_xwidth, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during autogksmoothw call');
        end;
        state := Tautogkstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure autogksmoothw( a: Double;  b: Double;  xwidth: Double; out  state: Tautogkstate; const _xparams: UInt64 = 0);
begin
    _core_autogksmoothw(a, b, xwidth, state, _xparams);
end;


procedure _core_autogksingular( a: Double;  b: Double;  alpha: Double;  beta: Double; out  state: Tautogkstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: Double;
    _d_b: Double;
    _d_alpha: Double;
    _d_beta: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_alpha := alpha;
        _d_beta := beta;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_autogksingular(@_s_error_msg, @_d_a, @_d_b, @_d_alpha, @_d_beta, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during autogksingular call');
        end;
        state := Tautogkstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure autogksingular( a: Double;  b: Double;  alpha: Double;  beta: Double; out  state: Tautogkstate; const _xparams: UInt64 = 0);
begin
    _core_autogksingular(a, b, alpha, beta, state, _xparams);
end;


function _core_autogkiteration( state: Tautogkstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_autogkiteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during autogkiteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function autogkiteration( state: Tautogkstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_autogkiteration(state, _xparams);
end;

procedure autogkintegrate(state: Tautogkstate; func: Tintegrator1_func; obj: Pointer; _xparams: UInt64 = 0);
var
    _s_error_msg: PAnsiChar;
    _error_code:Int32T;
    _b_result:  Byte;
    _state:     Pointer;
    _xc_x:      Double;
    _xc_xminusa:Double;
    _xc_bminusx:Double;
    _xc_f:      Double;
    _xc_needf:  Byte;
begin
    _s_error_msg:=nil;
    _state:=state.ptr;

    //
    // Check correctness of delegates
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in autogkintegrate() (func is nil)');

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_autogkiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during autogkiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;

        //
        // Reverse communication interface:
        // * fetch flags
        // * make delegate calls
        //
        x_autogkstate_get_needf(_state, @_xc_needf);
        if _xc_needf<>0 then
        begin
            x_autogkstate_get_x(_state, @_xc_x);
            x_autogkstate_get_xminusa(_state, @_xc_xminusa);
            x_autogkstate_get_bminusx(_state, @_xc_bminusx);
            func(_xc_x, _xc_xminusa, _xc_bminusx, _xc_f, obj);
            x_autogkstate_set_f(_state, @_xc_f);
            continue;
        end;
        raise Exception.Create('ALGLIB: error in autogkintegrate() (some derivatives were not provided?)');
    end;
end;


procedure _core_autogkresults( state: Tautogkstate; out  v: Double; out  rep: Tautogkreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_v: Double;
    _d_rep: x_autogkreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_autogkreport_init(_d_rep);
        _error_code := x_xv2_autogkresults(@_s_error_msg, @_d_state, @_d_v, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during autogkresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        v := _d_v;
        x_autogkreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_autogkreport_clear(_d_rep);
    end;
end;


procedure autogkresults( state: Tautogkstate; out  v: Double; out  rep: Tautogkreport; const _xparams: UInt64 = 0);
begin
    _core_autogkresults(state, v, rep, _xparams);
end;


procedure _core_fftc1d(var  a: TCVector;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_fftc1d(@_s_error_msg, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fftc1d call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure fftc1d(var  a: TCVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_fftc1d(a, n, _xparams);
end;


procedure fftc1d(var  a: TCVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(a);

    _core_fftc1d(a, n, _xparams);

end;


procedure _core_fftc1dinv(var  a: TCVector;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_fftc1dinv(@_s_error_msg, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fftc1dinv call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure fftc1dinv(var  a: TCVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_fftc1dinv(a, n, _xparams);
end;


procedure fftc1dinv(var  a: TCVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(a);

    _core_fftc1dinv(a, n, _xparams);

end;


procedure _core_fftr1d( a: TVector;  n: TALGLIBInteger; out  f: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
    _d_f: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_create_empty(_d_f, DT_COMPLEX);
        f := nil;
        _error_code := x_xv2_fftr1d(@_s_error_msg, @_d_a, @_d_n, @_d_f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fftr1d call');
        end;
        x_to_array(_d_f, f);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_f);
    end;
end;


procedure fftr1d( a: TVector;  n: TALGLIBInteger; out  f: TCVector; const _xparams: UInt64 = 0);overload;
begin
    _core_fftr1d(a, n, f, _xparams);
end;


procedure fftr1d( a: TVector; out  f: TCVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(a);

    _core_fftr1d(a, n, f, _xparams);

end;


procedure _core_fftr1dinv( f: TCVector;  n: TALGLIBInteger; out  a: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_f: x_vector;
    _d_n: NativeInt;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_f, f, X_CREATE);
        _d_n := n;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_fftr1dinv(@_s_error_msg, @_d_f, @_d_n, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fftr1dinv call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
        x_clear(_d_a);
    end;
end;


procedure fftr1dinv( f: TCVector;  n: TALGLIBInteger; out  a: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_fftr1dinv(f, n, a, _xparams);
end;


procedure fftr1dinv( f: TCVector; out  a: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(f);

    _core_fftr1dinv(f, n, a, _xparams);

end;


procedure _core_fhtr1d(var  a: TVector;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_fhtr1d(@_s_error_msg, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fhtr1d call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure fhtr1d(var  a: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_fhtr1d(a, n, _xparams);
end;


procedure _core_fhtr1dinv(var  a: TVector;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_fhtr1dinv(@_s_error_msg, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fhtr1dinv call');
        end;
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure fhtr1dinv(var  a: TVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_fhtr1dinv(a, n, _xparams);
end;


procedure _core_convc1d( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_m: NativeInt;
    _d_b: x_vector;
    _d_n: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        x_from_array(_d_b, b, X_CREATE);
        _d_n := n;
        x_create_empty(_d_r, DT_COMPLEX);
        r := nil;
        _error_code := x_xv2_convc1d(@_s_error_msg, @_d_a, @_d_m, @_d_b, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convc1d call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_r);
    end;
end;


procedure convc1d( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
begin
    _core_convc1d(a, m, b, n, r, _xparams);
end;


procedure _core_convc1dinv( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_m: NativeInt;
    _d_b: x_vector;
    _d_n: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        x_from_array(_d_b, b, X_CREATE);
        _d_n := n;
        x_create_empty(_d_r, DT_COMPLEX);
        r := nil;
        _error_code := x_xv2_convc1dinv(@_s_error_msg, @_d_a, @_d_m, @_d_b, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convc1dinv call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_r);
    end;
end;


procedure convc1dinv( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
begin
    _core_convc1dinv(a, m, b, n, r, _xparams);
end;


procedure _core_convc1dcircular( s: TCVector;  m: TALGLIBInteger;  r: TCVector;  n: TALGLIBInteger; out  c: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s: x_vector;
    _d_m: NativeInt;
    _d_r: x_vector;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_s, s, X_CREATE);
        _d_m := m;
        x_from_array(_d_r, r, X_CREATE);
        _d_n := n;
        x_create_empty(_d_c, DT_COMPLEX);
        c := nil;
        _error_code := x_xv2_convc1dcircular(@_s_error_msg, @_d_s, @_d_m, @_d_r, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convc1dcircular call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
        x_clear(_d_r);
        x_clear(_d_c);
    end;
end;


procedure convc1dcircular( s: TCVector;  m: TALGLIBInteger;  r: TCVector;  n: TALGLIBInteger; out  c: TCVector; const _xparams: UInt64 = 0);
begin
    _core_convc1dcircular(s, m, r, n, c, _xparams);
end;


procedure _core_convc1dcircularinv( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_m: NativeInt;
    _d_b: x_vector;
    _d_n: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        x_from_array(_d_b, b, X_CREATE);
        _d_n := n;
        x_create_empty(_d_r, DT_COMPLEX);
        r := nil;
        _error_code := x_xv2_convc1dcircularinv(@_s_error_msg, @_d_a, @_d_m, @_d_b, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convc1dcircularinv call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_r);
    end;
end;


procedure convc1dcircularinv( a: TCVector;  m: TALGLIBInteger;  b: TCVector;  n: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
begin
    _core_convc1dcircularinv(a, m, b, n, r, _xparams);
end;


procedure _core_convr1d( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_m: NativeInt;
    _d_b: x_vector;
    _d_n: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        x_from_array(_d_b, b, X_CREATE);
        _d_n := n;
        x_create_empty(_d_r, DT_REAL);
        r := nil;
        _error_code := x_xv2_convr1d(@_s_error_msg, @_d_a, @_d_m, @_d_b, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convr1d call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_r);
    end;
end;


procedure convr1d( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
begin
    _core_convr1d(a, m, b, n, r, _xparams);
end;


procedure _core_convr1dinv( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_m: NativeInt;
    _d_b: x_vector;
    _d_n: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        x_from_array(_d_b, b, X_CREATE);
        _d_n := n;
        x_create_empty(_d_r, DT_REAL);
        r := nil;
        _error_code := x_xv2_convr1dinv(@_s_error_msg, @_d_a, @_d_m, @_d_b, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convr1dinv call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_r);
    end;
end;


procedure convr1dinv( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
begin
    _core_convr1dinv(a, m, b, n, r, _xparams);
end;


procedure _core_convr1dcircular( s: TVector;  m: TALGLIBInteger;  r: TVector;  n: TALGLIBInteger; out  c: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s: x_vector;
    _d_m: NativeInt;
    _d_r: x_vector;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_s, s, X_CREATE);
        _d_m := m;
        x_from_array(_d_r, r, X_CREATE);
        _d_n := n;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_convr1dcircular(@_s_error_msg, @_d_s, @_d_m, @_d_r, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convr1dcircular call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
        x_clear(_d_r);
        x_clear(_d_c);
    end;
end;


procedure convr1dcircular( s: TVector;  m: TALGLIBInteger;  r: TVector;  n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
begin
    _core_convr1dcircular(s, m, r, n, c, _xparams);
end;


procedure _core_convr1dcircularinv( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_m: NativeInt;
    _d_b: x_vector;
    _d_n: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_m := m;
        x_from_array(_d_b, b, X_CREATE);
        _d_n := n;
        x_create_empty(_d_r, DT_REAL);
        r := nil;
        _error_code := x_xv2_convr1dcircularinv(@_s_error_msg, @_d_a, @_d_m, @_d_b, @_d_n, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during convr1dcircularinv call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_r);
    end;
end;


procedure convr1dcircularinv( a: TVector;  m: TALGLIBInteger;  b: TVector;  n: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
begin
    _core_convr1dcircularinv(a, m, b, n, r, _xparams);
end;


procedure _core_corrc1d( signal: TCVector;  n: TALGLIBInteger;  pattern: TCVector;  m: TALGLIBInteger; out  r: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_signal: x_vector;
    _d_n: NativeInt;
    _d_pattern: x_vector;
    _d_m: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_signal, signal, X_CREATE);
        _d_n := n;
        x_from_array(_d_pattern, pattern, X_CREATE);
        _d_m := m;
        x_create_empty(_d_r, DT_COMPLEX);
        r := nil;
        _error_code := x_xv2_corrc1d(@_s_error_msg, @_d_signal, @_d_n, @_d_pattern, @_d_m, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during corrc1d call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_signal);
        x_clear(_d_pattern);
        x_clear(_d_r);
    end;
end;


procedure corrc1d( signal: TCVector;  n: TALGLIBInteger;  pattern: TCVector;  m: TALGLIBInteger; out  r: TCVector; const _xparams: UInt64 = 0);
begin
    _core_corrc1d(signal, n, pattern, m, r, _xparams);
end;


procedure _core_corrc1dcircular( signal: TCVector;  m: TALGLIBInteger;  pattern: TCVector;  n: TALGLIBInteger; out  c: TCVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_signal: x_vector;
    _d_m: NativeInt;
    _d_pattern: x_vector;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_signal, signal, X_CREATE);
        _d_m := m;
        x_from_array(_d_pattern, pattern, X_CREATE);
        _d_n := n;
        x_create_empty(_d_c, DT_COMPLEX);
        c := nil;
        _error_code := x_xv2_corrc1dcircular(@_s_error_msg, @_d_signal, @_d_m, @_d_pattern, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during corrc1dcircular call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_signal);
        x_clear(_d_pattern);
        x_clear(_d_c);
    end;
end;


procedure corrc1dcircular( signal: TCVector;  m: TALGLIBInteger;  pattern: TCVector;  n: TALGLIBInteger; out  c: TCVector; const _xparams: UInt64 = 0);
begin
    _core_corrc1dcircular(signal, m, pattern, n, c, _xparams);
end;


procedure _core_corrr1d( signal: TVector;  n: TALGLIBInteger;  pattern: TVector;  m: TALGLIBInteger; out  r: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_signal: x_vector;
    _d_n: NativeInt;
    _d_pattern: x_vector;
    _d_m: NativeInt;
    _d_r: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_signal, signal, X_CREATE);
        _d_n := n;
        x_from_array(_d_pattern, pattern, X_CREATE);
        _d_m := m;
        x_create_empty(_d_r, DT_REAL);
        r := nil;
        _error_code := x_xv2_corrr1d(@_s_error_msg, @_d_signal, @_d_n, @_d_pattern, @_d_m, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during corrr1d call');
        end;
        x_to_array(_d_r, r);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_signal);
        x_clear(_d_pattern);
        x_clear(_d_r);
    end;
end;


procedure corrr1d( signal: TVector;  n: TALGLIBInteger;  pattern: TVector;  m: TALGLIBInteger; out  r: TVector; const _xparams: UInt64 = 0);
begin
    _core_corrr1d(signal, n, pattern, m, r, _xparams);
end;


procedure _core_corrr1dcircular( signal: TVector;  m: TALGLIBInteger;  pattern: TVector;  n: TALGLIBInteger; out  c: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_signal: x_vector;
    _d_m: NativeInt;
    _d_pattern: x_vector;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_signal, signal, X_CREATE);
        _d_m := m;
        x_from_array(_d_pattern, pattern, X_CREATE);
        _d_n := n;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_corrr1dcircular(@_s_error_msg, @_d_signal, @_d_m, @_d_pattern, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during corrr1dcircular call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_signal);
        x_clear(_d_pattern);
        x_clear(_d_c);
    end;
end;


procedure corrr1dcircular( signal: TVector;  m: TALGLIBInteger;  pattern: TVector;  n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
begin
    _core_corrr1dcircular(signal, m, pattern, n, c, _xparams);
end;

constructor Tidwcalcbuffer.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tidwcalcbuffer.Destroy();
begin
    Deallocate();
end;

function Tidwcalcbuffer.Clone():Tidwcalcbuffer;
begin
    if ptr=nil then
        Result:=Tidwcalcbuffer.Create(nil)
    else
        Result:=Tidwcalcbuffer.Create(x_obj_copy_idwcalcbuffer(ptr));
end;

procedure Tidwcalcbuffer.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_idwcalcbuffer(ptr);
    ptr:=nil;
end;

constructor Tidwmodel.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tidwmodel.Destroy();
begin
    Deallocate();
end;

function Tidwmodel.Clone():Tidwmodel;
begin
    if ptr=nil then
        Result:=Tidwmodel.Create(nil)
    else
        Result:=Tidwmodel.Create(x_obj_copy_idwmodel(ptr));
end;

procedure Tidwmodel.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_idwmodel(ptr);
    ptr:=nil;
end;

constructor Tidwbuilder.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tidwbuilder.Destroy();
begin
    Deallocate();
end;

function Tidwbuilder.Clone():Tidwbuilder;
begin
    if ptr=nil then
        Result:=Tidwbuilder.Create(nil)
    else
        Result:=Tidwbuilder.Create(x_obj_copy_idwbuilder(ptr));
end;

procedure Tidwbuilder.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_idwbuilder(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tidwreport):Tidwreport;overload;
begin
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.maxerror := src.maxerror;
    Result.r2 := src.r2;
end;

procedure x_idwreport_init(var x: x_idwreport);
begin
    x.rmserror := 0;
    x.avgerror := 0;
    x.maxerror := 0;
    x.r2 := 0;
end;

procedure x_idwreport_clear(var x: x_idwreport);
begin
end;

procedure x_idwreport_init_from(var x: x_idwreport; const v: Tidwreport);
begin
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.maxerror := v.maxerror;
    x.r2 := v.r2;
end;

procedure x_idwreport_to_record(const x: x_idwreport; var v: Tidwreport);
begin
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.maxerror := x.maxerror;
    v.r2 := x.r2;
end;

procedure idwserialize(const obj: Tidwmodel; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_idwserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure idwunserialize(const s_in: AnsiString; out obj: Tidwmodel);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_idwunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwunserialize() call');
        end;
        obj:=Tidwmodel.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_idwmodel(_x);
    end;
end;

procedure idwserialize(const obj: Tidwmodel; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_idwserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during idwserialize_stream() call');
    end;
end;

procedure idwunserialize(stream: TStream; out obj: Tidwmodel);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_idwunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwunserialize_stream() call');
        end;
        obj:=Tidwmodel.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_idwmodel(_x);
    end;
end;


procedure _core_idwcreatecalcbuffer( s: Tidwmodel; out  buf: Tidwcalcbuffer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_buf : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_buf := nil;
        buf := nil;
        _error_code := x_xv2_idwcreatecalcbuffer(@_s_error_msg, @_d_s, @_d_buf, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwcreatecalcbuffer call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        buf := Tidwcalcbuffer.Create(_d_buf);
    finally
        SetXExceptionMask(fpumask);
        if (_d_buf<>nil) and (buf=nil) then
            x_obj_free_idwcalcbuffer(_d_buf); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure idwcreatecalcbuffer( s: Tidwmodel; out  buf: Tidwcalcbuffer; const _xparams: UInt64 = 0);
begin
    _core_idwcreatecalcbuffer(s, buf, _xparams);
end;


procedure _core_idwbuildercreate( nx: TALGLIBInteger;  ny: TALGLIBInteger; out  state: Tidwbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nx: NativeInt;
    _d_ny: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nx := nx;
        _d_ny := ny;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_idwbuildercreate(@_s_error_msg, @_d_nx, @_d_ny, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildercreate call');
        end;
        state := Tidwbuilder.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_idwbuilder(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure idwbuildercreate( nx: TALGLIBInteger;  ny: TALGLIBInteger; out  state: Tidwbuilder; const _xparams: UInt64 = 0);
begin
    _core_idwbuildercreate(nx, ny, state, _xparams);
end;


procedure _core_idwbuildersetnlayers( state: Tidwbuilder;  nlayers: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_nlayers: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_nlayers := nlayers;
        _error_code := x_xv2_idwbuildersetnlayers(@_s_error_msg, @_d_state, @_d_nlayers, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetnlayers call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure idwbuildersetnlayers( state: Tidwbuilder;  nlayers: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_idwbuildersetnlayers(state, nlayers, _xparams);
end;


procedure _core_idwbuildersetpoints( state: Tidwbuilder;  xy: TMatrix;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_xy: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_idwbuildersetpoints(@_s_error_msg, @_d_state, @_d_xy, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetpoints call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure idwbuildersetpoints( state: Tidwbuilder;  xy: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_idwbuildersetpoints(state, xy, n, _xparams);
end;


procedure idwbuildersetpoints( state: Tidwbuilder;  xy: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xrows(xy);

    _core_idwbuildersetpoints(state, xy, n, _xparams);

end;


procedure _core_idwbuildersetalgomstab( state: Tidwbuilder;  srad: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_srad: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_srad := srad;
        _error_code := x_xv2_idwbuildersetalgomstab(@_s_error_msg, @_d_state, @_d_srad, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetalgomstab call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure idwbuildersetalgomstab( state: Tidwbuilder;  srad: Double; const _xparams: UInt64 = 0);
begin
    _core_idwbuildersetalgomstab(state, srad, _xparams);
end;


procedure _core_idwbuildersetalgotextbookshepard( state: Tidwbuilder;  p: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_p: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_p := p;
        _error_code := x_xv2_idwbuildersetalgotextbookshepard(@_s_error_msg, @_d_state, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetalgotextbookshepard call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure idwbuildersetalgotextbookshepard( state: Tidwbuilder;  p: Double; const _xparams: UInt64 = 0);
begin
    _core_idwbuildersetalgotextbookshepard(state, p, _xparams);
end;


procedure _core_idwbuildersetalgotextbookmodshepard( state: Tidwbuilder;  r: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_r: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_r := r;
        _error_code := x_xv2_idwbuildersetalgotextbookmodshepard(@_s_error_msg, @_d_state, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetalgotextbookmodshepard call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure idwbuildersetalgotextbookmodshepard( state: Tidwbuilder;  r: Double; const _xparams: UInt64 = 0);
begin
    _core_idwbuildersetalgotextbookmodshepard(state, r, _xparams);
end;


procedure _core_idwbuildersetuserterm( state: Tidwbuilder;  v: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_v := v;
        _error_code := x_xv2_idwbuildersetuserterm(@_s_error_msg, @_d_state, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetuserterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure idwbuildersetuserterm( state: Tidwbuilder;  v: Double; const _xparams: UInt64 = 0);
begin
    _core_idwbuildersetuserterm(state, v, _xparams);
end;


procedure _core_idwbuildersetconstterm( state: Tidwbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_idwbuildersetconstterm(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetconstterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure idwbuildersetconstterm( state: Tidwbuilder; const _xparams: UInt64 = 0);
begin
    _core_idwbuildersetconstterm(state, _xparams);
end;


procedure _core_idwbuildersetzeroterm( state: Tidwbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_idwbuildersetzeroterm(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwbuildersetzeroterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure idwbuildersetzeroterm( state: Tidwbuilder; const _xparams: UInt64 = 0);
begin
    _core_idwbuildersetzeroterm(state, _xparams);
end;


function _core_idwcalc1( s: Tidwmodel;  x0: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_x0: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_x0 := x0;
        _error_code := x_xv2_idwcalc1(@_s_error_msg, @_d_result, @_d_s, @_d_x0, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwcalc1 call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function idwcalc1( s: Tidwmodel;  x0: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_idwcalc1(s, x0, _xparams);
end;


function _core_idwcalc2( s: Tidwmodel;  x0: Double;  x1: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_x0: Double;
    _d_x1: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_x0 := x0;
        _d_x1 := x1;
        _error_code := x_xv2_idwcalc2(@_s_error_msg, @_d_result, @_d_s, @_d_x0, @_d_x1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwcalc2 call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function idwcalc2( s: Tidwmodel;  x0: Double;  x1: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_idwcalc2(s, x0, x1, _xparams);
end;


function _core_idwcalc3( s: Tidwmodel;  x0: Double;  x1: Double;  x2: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_x0: Double;
    _d_x1: Double;
    _d_x2: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_x0 := x0;
        _d_x1 := x1;
        _d_x2 := x2;
        _error_code := x_xv2_idwcalc3(@_s_error_msg, @_d_result, @_d_s, @_d_x0, @_d_x1, @_d_x2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwcalc3 call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function idwcalc3( s: Tidwmodel;  x0: Double;  x1: Double;  x2: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_idwcalc3(s, x0, x1, x2, _xparams);
end;


procedure _core_idwcalc( s: Tidwmodel;  x: TVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_idwcalc(@_s_error_msg, @_d_s, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwcalc call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure idwcalc( s: Tidwmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_idwcalc(s, x, y, _xparams);
end;


procedure _core_idwcalcbuf( s: Tidwmodel;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_idwcalcbuf(@_s_error_msg, @_d_s, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwcalcbuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure idwcalcbuf( s: Tidwmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_idwcalcbuf(s, x, y, _xparams);
end;


procedure _core_idwtscalcbuf( s: Tidwmodel;  buf: Tidwcalcbuffer;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_idwtscalcbuf(@_s_error_msg, @_d_s, @_d_buf, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwtscalcbuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure idwtscalcbuf( s: Tidwmodel;  buf: Tidwcalcbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_idwtscalcbuf(s, buf, x, y, _xparams);
end;


procedure _core_idwfit( state: Tidwbuilder; out  model: Tidwmodel; out  rep: Tidwreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_model : Pointer;
    _d_rep: x_idwreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_model := nil;
        model := nil;
        x_idwreport_init(_d_rep);
        _error_code := x_xv2_idwfit(@_s_error_msg, @_d_state, @_d_model, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during idwfit call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        model := Tidwmodel.Create(_d_model);
        x_idwreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        if (_d_model<>nil) and (model=nil) then
            x_obj_free_idwmodel(_d_model); // on exception clean up X objects which were not attached to Delphi objects
        x_idwreport_clear(_d_rep);
    end;
end;


procedure idwfit( state: Tidwbuilder; out  model: Tidwmodel; out  rep: Tidwreport; const _xparams: UInt64 = 0);
begin
    _core_idwfit(state, model, rep, _xparams);
end;

constructor Tbarycentricinterpolant.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tbarycentricinterpolant.Destroy();
begin
    Deallocate();
end;

function Tbarycentricinterpolant.Clone():Tbarycentricinterpolant;
begin
    if ptr=nil then
        Result:=Tbarycentricinterpolant.Create(nil)
    else
        Result:=Tbarycentricinterpolant.Create(x_obj_copy_barycentricinterpolant(ptr));
end;

procedure Tbarycentricinterpolant.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_barycentricinterpolant(ptr);
    ptr:=nil;
end;


function _core_barycentriccalc( b: Tbarycentricinterpolant;  t: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_b : Pointer;
    _d_t: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_b := b.ptr;
        _d_t := t;
        _error_code := x_xv2_barycentriccalc(@_s_error_msg, @_d_result, @_d_b, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentriccalc call');
        end;
        result := _d_result;
        Assert(b.ptr=_d_b, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function barycentriccalc( b: Tbarycentricinterpolant;  t: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_barycentriccalc(b, t, _xparams);
end;


procedure _core_barycentricdiff1( b: Tbarycentricinterpolant;  t: Double; out  f: Double; out  df: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_b : Pointer;
    _d_t: Double;
    _d_f: Double;
    _d_df: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_b := b.ptr;
        _d_t := t;
        _error_code := x_xv2_barycentricdiff1(@_s_error_msg, @_d_b, @_d_t, @_d_f, @_d_df, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentricdiff1 call');
        end;
        Assert(b.ptr=_d_b, 'ALGLIB: internal error (reference changed for non-out X-object)');
        f := _d_f;
        df := _d_df;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure barycentricdiff1( b: Tbarycentricinterpolant;  t: Double; out  f: Double; out  df: Double; const _xparams: UInt64 = 0);
begin
    _core_barycentricdiff1(b, t, f, df, _xparams);
end;


procedure _core_barycentricdiff2( b: Tbarycentricinterpolant;  t: Double; out  f: Double; out  df: Double; out  d2f: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_b : Pointer;
    _d_t: Double;
    _d_f: Double;
    _d_df: Double;
    _d_d2f: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_b := b.ptr;
        _d_t := t;
        _error_code := x_xv2_barycentricdiff2(@_s_error_msg, @_d_b, @_d_t, @_d_f, @_d_df, @_d_d2f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentricdiff2 call');
        end;
        Assert(b.ptr=_d_b, 'ALGLIB: internal error (reference changed for non-out X-object)');
        f := _d_f;
        df := _d_df;
        d2f := _d_d2f;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure barycentricdiff2( b: Tbarycentricinterpolant;  t: Double; out  f: Double; out  df: Double; out  d2f: Double; const _xparams: UInt64 = 0);
begin
    _core_barycentricdiff2(b, t, f, df, d2f, _xparams);
end;


procedure _core_barycentriclintransx( b: Tbarycentricinterpolant;  ca: Double;  cb: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_b : Pointer;
    _d_ca: Double;
    _d_cb: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_b := b.ptr;
        _d_ca := ca;
        _d_cb := cb;
        _error_code := x_xv2_barycentriclintransx(@_s_error_msg, @_d_b, @_d_ca, @_d_cb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentriclintransx call');
        end;
        Assert(b.ptr=_d_b, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure barycentriclintransx( b: Tbarycentricinterpolant;  ca: Double;  cb: Double; const _xparams: UInt64 = 0);
begin
    _core_barycentriclintransx(b, ca, cb, _xparams);
end;


procedure _core_barycentriclintransy( b: Tbarycentricinterpolant;  ca: Double;  cb: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_b : Pointer;
    _d_ca: Double;
    _d_cb: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_b := b.ptr;
        _d_ca := ca;
        _d_cb := cb;
        _error_code := x_xv2_barycentriclintransy(@_s_error_msg, @_d_b, @_d_ca, @_d_cb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentriclintransy call');
        end;
        Assert(b.ptr=_d_b, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure barycentriclintransy( b: Tbarycentricinterpolant;  ca: Double;  cb: Double; const _xparams: UInt64 = 0);
begin
    _core_barycentriclintransy(b, ca, cb, _xparams);
end;


procedure _core_barycentricunpack( b: Tbarycentricinterpolant; out  n: TALGLIBInteger; out  x: TVector; out  y: TVector; out  w: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_b : Pointer;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_w: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_b := b.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        x_create_empty(_d_w, DT_REAL);
        w := nil;
        _error_code := x_xv2_barycentricunpack(@_s_error_msg, @_d_b, @_d_n, @_d_x, @_d_y, @_d_w, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentricunpack call');
        end;
        Assert(b.ptr=_d_b, 'ALGLIB: internal error (reference changed for non-out X-object)');
        n := _d_n;
        x_to_array(_d_x, x);
        x_to_array(_d_y, y);
        x_to_array(_d_w, w);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
    end;
end;


procedure barycentricunpack( b: Tbarycentricinterpolant; out  n: TALGLIBInteger; out  x: TVector; out  y: TVector; out  w: TVector; const _xparams: UInt64 = 0);
begin
    _core_barycentricunpack(b, n, x, y, w, _xparams);
end;


procedure _core_barycentricbuildxyw( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger; out  b: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_n: NativeInt;
    _d_b : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        _d_n := n;
        _d_b := nil;
        b := nil;
        _error_code := x_xv2_barycentricbuildxyw(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_n, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentricbuildxyw call');
        end;
        b := Tbarycentricinterpolant.Create(_d_b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        if (_d_b<>nil) and (b=nil) then
            x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure barycentricbuildxyw( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger; out  b: Tbarycentricinterpolant; const _xparams: UInt64 = 0);
begin
    _core_barycentricbuildxyw(x, y, w, n, b, _xparams);
end;


procedure _core_barycentricbuildfloaterhormann( x: TVector;  y: TVector;  n: TALGLIBInteger;  d: TALGLIBInteger; out  b: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_d: NativeInt;
    _d_b : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_d := d;
        _d_b := nil;
        b := nil;
        _error_code := x_xv2_barycentricbuildfloaterhormann(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_d, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentricbuildfloaterhormann call');
        end;
        b := Tbarycentricinterpolant.Create(_d_b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_b<>nil) and (b=nil) then
            x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure barycentricbuildfloaterhormann( x: TVector;  y: TVector;  n: TALGLIBInteger;  d: TALGLIBInteger; out  b: Tbarycentricinterpolant; const _xparams: UInt64 = 0);
begin
    _core_barycentricbuildfloaterhormann(x, y, n, d, b, _xparams);
end;


procedure _core_fitspherels( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  r: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_cx: x_vector;
    _d_r: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_fitspherels(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_cx, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fitspherels call');
        end;
        x_to_array(_d_cx, cx);
        r := _d_r;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure fitspherels( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  r: Double; const _xparams: UInt64 = 0);
begin
    _core_fitspherels(xy, npoints, nx, cx, r, _xparams);
end;


procedure _core_fitspheremc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rhi: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_cx: x_vector;
    _d_rhi: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_fitspheremc(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_cx, @_d_rhi, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fitspheremc call');
        end;
        x_to_array(_d_cx, cx);
        rhi := _d_rhi;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure fitspheremc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rhi: Double; const _xparams: UInt64 = 0);
begin
    _core_fitspheremc(xy, npoints, nx, cx, rhi, _xparams);
end;


procedure _core_fitspheremi( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_cx: x_vector;
    _d_rlo: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_fitspheremi(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_cx, @_d_rlo, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fitspheremi call');
        end;
        x_to_array(_d_cx, cx);
        rlo := _d_rlo;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure fitspheremi( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; const _xparams: UInt64 = 0);
begin
    _core_fitspheremi(xy, npoints, nx, cx, rlo, _xparams);
end;


procedure _core_fitspheremz( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; out  rhi: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_cx: x_vector;
    _d_rlo: Double;
    _d_rhi: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_fitspheremz(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_cx, @_d_rlo, @_d_rhi, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fitspheremz call');
        end;
        x_to_array(_d_cx, cx);
        rlo := _d_rlo;
        rhi := _d_rhi;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure fitspheremz( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
begin
    _core_fitspheremz(xy, npoints, nx, cx, rlo, rhi, _xparams);
end;


procedure _core_fitspherex( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger;  problemtype: TALGLIBInteger;  epsx: Double;  aulits: TALGLIBInteger;  penalty: Double; out  cx: TVector; out  rlo: Double; out  rhi: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_problemtype: NativeInt;
    _d_epsx: Double;
    _d_aulits: NativeInt;
    _d_penalty: Double;
    _d_cx: x_vector;
    _d_rlo: Double;
    _d_rhi: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        _d_problemtype := problemtype;
        _d_epsx := epsx;
        _d_aulits := aulits;
        _d_penalty := penalty;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_fitspherex(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_problemtype, @_d_epsx, @_d_aulits, @_d_penalty, @_d_cx, @_d_rlo, @_d_rhi, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fitspherex call');
        end;
        x_to_array(_d_cx, cx);
        rlo := _d_rlo;
        rhi := _d_rhi;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure fitspherex( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger;  problemtype: TALGLIBInteger;  epsx: Double;  aulits: TALGLIBInteger;  penalty: Double; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
begin
    _core_fitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, cx, rlo, rhi, _xparams);
end;

constructor Tspline1dinterpolant.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tspline1dinterpolant.Destroy();
begin
    Deallocate();
end;

function Tspline1dinterpolant.Clone():Tspline1dinterpolant;
begin
    if ptr=nil then
        Result:=Tspline1dinterpolant.Create(nil)
    else
        Result:=Tspline1dinterpolant.Create(x_obj_copy_spline1dinterpolant(ptr));
end;

procedure Tspline1dinterpolant.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_spline1dinterpolant(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tspline1dfitreport):Tspline1dfitreport;overload;
begin
    Result.taskrcond := src.taskrcond;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
    Result.maxerror := src.maxerror;
end;

procedure x_spline1dfitreport_init(var x: x_spline1dfitreport);
begin
    x.taskrcond := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
    x.maxerror := 0;
end;

procedure x_spline1dfitreport_clear(var x: x_spline1dfitreport);
begin
end;

procedure x_spline1dfitreport_init_from(var x: x_spline1dfitreport; const v: Tspline1dfitreport);
begin
    x.taskrcond := v.taskrcond;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
    x.maxerror := v.maxerror;
end;

procedure x_spline1dfitreport_to_record(const x: x_spline1dfitreport; var v: Tspline1dfitreport);
begin
    v.taskrcond := x.taskrcond;
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
    v.maxerror := x.maxerror;
end;


procedure _core_spline1dbuildlinear( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline1dbuildlinear(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dbuildlinear call');
        end;
        c := Tspline1dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline1dbuildlinear( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dbuildlinear(x, y, n, c, _xparams);
end;


procedure spline1dbuildlinear( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dbuildlinear: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dbuildlinear(x, y, n, c, _xparams);

end;


procedure _core_spline1dbuildcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  c: Tspline1dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_boundltype: NativeInt;
    _d_boundl: Double;
    _d_boundrtype: NativeInt;
    _d_boundr: Double;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_boundltype := boundltype;
        _d_boundl := boundl;
        _d_boundrtype := boundrtype;
        _d_boundr := boundr;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline1dbuildcubic(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_boundltype, @_d_boundl, @_d_boundrtype, @_d_boundr, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dbuildcubic call');
        end;
        c := Tspline1dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline1dbuildcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, c, _xparams);
end;


procedure spline1dbuildcubic( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    boundltype: TALGLIBInteger;
    boundl: Double;
    boundrtype: TALGLIBInteger;
    boundr: Double;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dbuildcubic: looks like one of arguments has wrong size');

    n := xlen(x);
    boundltype := 0;
    boundl := 0;
    boundrtype := 0;
    boundr := 0;

    _core_spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, c, _xparams);

end;


procedure _core_spline1dgriddiffcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  d: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_boundltype: NativeInt;
    _d_boundl: Double;
    _d_boundrtype: NativeInt;
    _d_boundr: Double;
    _d_d: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_boundltype := boundltype;
        _d_boundl := boundl;
        _d_boundrtype := boundrtype;
        _d_boundr := boundr;
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        _error_code := x_xv2_spline1dgriddiffcubic(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_boundltype, @_d_boundl, @_d_boundrtype, @_d_boundr, @_d_d, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dgriddiffcubic call');
        end;
        x_to_array(_d_d, d);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_d);
    end;
end;


procedure spline1dgriddiffcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  d: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, d, _xparams);
end;


procedure spline1dgriddiffcubic( x: TVector;  y: TVector; out  d: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    boundltype: TALGLIBInteger;
    boundl: Double;
    boundrtype: TALGLIBInteger;
    boundr: Double;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dgriddiffcubic: looks like one of arguments has wrong size');

    n := xlen(x);
    boundltype := 0;
    boundl := 0;
    boundrtype := 0;
    boundr := 0;

    _core_spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, d, _xparams);

end;


procedure _core_spline1dgriddiff2cubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  d1: TVector; out  d2: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_boundltype: NativeInt;
    _d_boundl: Double;
    _d_boundrtype: NativeInt;
    _d_boundr: Double;
    _d_d1: x_vector;
    _d_d2: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_boundltype := boundltype;
        _d_boundl := boundl;
        _d_boundrtype := boundrtype;
        _d_boundr := boundr;
        x_create_empty(_d_d1, DT_REAL);
        d1 := nil;
        x_create_empty(_d_d2, DT_REAL);
        d2 := nil;
        _error_code := x_xv2_spline1dgriddiff2cubic(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_boundltype, @_d_boundl, @_d_boundrtype, @_d_boundr, @_d_d1, @_d_d2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dgriddiff2cubic call');
        end;
        x_to_array(_d_d1, d1);
        x_to_array(_d_d2, d2);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_d1);
        x_clear(_d_d2);
    end;
end;


procedure spline1dgriddiff2cubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double; out  d1: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, d1, d2, _xparams);
end;


procedure spline1dgriddiff2cubic( x: TVector;  y: TVector; out  d1: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    boundltype: TALGLIBInteger;
    boundl: Double;
    boundrtype: TALGLIBInteger;
    boundr: Double;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dgriddiff2cubic: looks like one of arguments has wrong size');

    n := xlen(x);
    boundltype := 0;
    boundl := 0;
    boundrtype := 0;
    boundr := 0;

    _core_spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, d1, d2, _xparams);

end;


procedure _core_spline1dconvcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_boundltype: NativeInt;
    _d_boundl: Double;
    _d_boundrtype: NativeInt;
    _d_boundr: Double;
    _d_x2: x_vector;
    _d_n2: NativeInt;
    _d_y2: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_boundltype := boundltype;
        _d_boundl := boundl;
        _d_boundrtype := boundrtype;
        _d_boundr := boundr;
        x_from_array(_d_x2, x2, X_CREATE);
        _d_n2 := n2;
        x_create_empty(_d_y2, DT_REAL);
        y2 := nil;
        _error_code := x_xv2_spline1dconvcubic(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_boundltype, @_d_boundl, @_d_boundrtype, @_d_boundr, @_d_x2, @_d_n2, @_d_y2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dconvcubic call');
        end;
        x_to_array(_d_y2, y2);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_x2);
        x_clear(_d_y2);
    end;
end;


procedure spline1dconvcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, _xparams);
end;


procedure spline1dconvcubic( x: TVector;  y: TVector;  x2: TVector; out  y2: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    boundltype: TALGLIBInteger;
    boundl: Double;
    boundrtype: TALGLIBInteger;
    boundr: Double;
    n2: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dconvcubic: looks like one of arguments has wrong size');

    n := xlen(x);
    boundltype := 0;
    boundl := 0;
    boundrtype := 0;
    boundr := 0;
    n2 := xlen(x2);

    _core_spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, _xparams);

end;


procedure _core_spline1dconvdiffcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; out  d2: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_boundltype: NativeInt;
    _d_boundl: Double;
    _d_boundrtype: NativeInt;
    _d_boundr: Double;
    _d_x2: x_vector;
    _d_n2: NativeInt;
    _d_y2: x_vector;
    _d_d2: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_boundltype := boundltype;
        _d_boundl := boundl;
        _d_boundrtype := boundrtype;
        _d_boundr := boundr;
        x_from_array(_d_x2, x2, X_CREATE);
        _d_n2 := n2;
        x_create_empty(_d_y2, DT_REAL);
        y2 := nil;
        x_create_empty(_d_d2, DT_REAL);
        d2 := nil;
        _error_code := x_xv2_spline1dconvdiffcubic(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_boundltype, @_d_boundl, @_d_boundrtype, @_d_boundr, @_d_x2, @_d_n2, @_d_y2, @_d_d2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dconvdiffcubic call');
        end;
        x_to_array(_d_y2, y2);
        x_to_array(_d_d2, d2);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_x2);
        x_clear(_d_y2);
        x_clear(_d_d2);
    end;
end;


procedure spline1dconvdiffcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2, _xparams);
end;


procedure spline1dconvdiffcubic( x: TVector;  y: TVector;  x2: TVector; out  y2: TVector; out  d2: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    boundltype: TALGLIBInteger;
    boundl: Double;
    boundrtype: TALGLIBInteger;
    boundr: Double;
    n2: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dconvdiffcubic: looks like one of arguments has wrong size');

    n := xlen(x);
    boundltype := 0;
    boundl := 0;
    boundrtype := 0;
    boundr := 0;
    n2 := xlen(x2);

    _core_spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2, _xparams);

end;


procedure _core_spline1dconvdiff2cubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; out  d2: TVector; out  dd2: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_boundltype: NativeInt;
    _d_boundl: Double;
    _d_boundrtype: NativeInt;
    _d_boundr: Double;
    _d_x2: x_vector;
    _d_n2: NativeInt;
    _d_y2: x_vector;
    _d_d2: x_vector;
    _d_dd2: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_boundltype := boundltype;
        _d_boundl := boundl;
        _d_boundrtype := boundrtype;
        _d_boundr := boundr;
        x_from_array(_d_x2, x2, X_CREATE);
        _d_n2 := n2;
        x_create_empty(_d_y2, DT_REAL);
        y2 := nil;
        x_create_empty(_d_d2, DT_REAL);
        d2 := nil;
        x_create_empty(_d_dd2, DT_REAL);
        dd2 := nil;
        _error_code := x_xv2_spline1dconvdiff2cubic(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_boundltype, @_d_boundl, @_d_boundrtype, @_d_boundr, @_d_x2, @_d_n2, @_d_y2, @_d_d2, @_d_dd2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dconvdiff2cubic call');
        end;
        x_to_array(_d_y2, y2);
        x_to_array(_d_d2, d2);
        x_to_array(_d_dd2, dd2);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_x2);
        x_clear(_d_y2);
        x_clear(_d_d2);
        x_clear(_d_dd2);
    end;
end;


procedure spline1dconvdiff2cubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundltype: TALGLIBInteger;  boundl: Double;  boundrtype: TALGLIBInteger;  boundr: Double;  x2: TVector;  n2: TALGLIBInteger; out  y2: TVector; out  d2: TVector; out  dd2: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2, dd2, _xparams);
end;


procedure spline1dconvdiff2cubic( x: TVector;  y: TVector;  x2: TVector; out  y2: TVector; out  d2: TVector; out  dd2: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    boundltype: TALGLIBInteger;
    boundl: Double;
    boundrtype: TALGLIBInteger;
    boundr: Double;
    n2: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dconvdiff2cubic: looks like one of arguments has wrong size');

    n := xlen(x);
    boundltype := 0;
    boundl := 0;
    boundrtype := 0;
    boundr := 0;
    n2 := xlen(x2);

    _core_spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2, dd2, _xparams);

end;


procedure _core_spline1dbuildcatmullrom( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundtype: TALGLIBInteger;  tension: Double; out  c: Tspline1dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_boundtype: NativeInt;
    _d_tension: Double;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_boundtype := boundtype;
        _d_tension := tension;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline1dbuildcatmullrom(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_boundtype, @_d_tension, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dbuildcatmullrom call');
        end;
        c := Tspline1dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline1dbuildcatmullrom( x: TVector;  y: TVector;  n: TALGLIBInteger;  boundtype: TALGLIBInteger;  tension: Double; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dbuildcatmullrom(x, y, n, boundtype, tension, c, _xparams);
end;


procedure spline1dbuildcatmullrom( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    boundtype: TALGLIBInteger;
    tension: Double;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dbuildcatmullrom: looks like one of arguments has wrong size');

    n := xlen(x);
    boundtype := 0;
    tension := 0;

    _core_spline1dbuildcatmullrom(x, y, n, boundtype, tension, c, _xparams);

end;


procedure _core_spline1dbuildhermite( x: TVector;  y: TVector;  d: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_d: x_vector;
    _d_n: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_d, d, X_CREATE);
        _d_n := n;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline1dbuildhermite(@_s_error_msg, @_d_x, @_d_y, @_d_d, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dbuildhermite call');
        end;
        c := Tspline1dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_d);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline1dbuildhermite( x: TVector;  y: TVector;  d: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dbuildhermite(x, y, d, n, c, _xparams);
end;


procedure spline1dbuildhermite( x: TVector;  y: TVector;  d: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) or ((xlen(x)<>xlen(d))) then
    raise Exception.Create('Error while calling spline1dbuildhermite: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dbuildhermite(x, y, d, n, c, _xparams);

end;


procedure _core_spline1dbuildakima( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline1dbuildakima(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dbuildakima call');
        end;
        c := Tspline1dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline1dbuildakima( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dbuildakima(x, y, n, c, _xparams);
end;


procedure spline1dbuildakima( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dbuildakima: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dbuildakima(x, y, n, c, _xparams);

end;


function _core_spline1dcalc( c: Tspline1dinterpolant;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c : Pointer;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _error_code := x_xv2_spline1dcalc(@_s_error_msg, @_d_result, @_d_c, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dcalc call');
        end;
        result := _d_result;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function spline1dcalc( c: Tspline1dinterpolant;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spline1dcalc(c, x, _xparams);
end;


procedure _core_spline1ddiff( c: Tspline1dinterpolant;  x: Double; out  s: Double; out  ds: Double; out  d2s: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_x: Double;
    _d_s: Double;
    _d_ds: Double;
    _d_d2s: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _error_code := x_xv2_spline1ddiff(@_s_error_msg, @_d_c, @_d_x, @_d_s, @_d_ds, @_d_d2s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1ddiff call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        s := _d_s;
        ds := _d_ds;
        d2s := _d_d2s;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline1ddiff( c: Tspline1dinterpolant;  x: Double; out  s: Double; out  ds: Double; out  d2s: Double; const _xparams: UInt64 = 0);
begin
    _core_spline1ddiff(c, x, s, ds, d2s, _xparams);
end;


procedure _core_spline1dunpack( c: Tspline1dinterpolant; out  n: TALGLIBInteger; out  tbl: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_n: NativeInt;
    _d_tbl: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        x_create_empty(_d_tbl, DT_REAL);
        tbl := nil;
        _error_code := x_xv2_spline1dunpack(@_s_error_msg, @_d_c, @_d_n, @_d_tbl, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dunpack call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        n := _d_n;
        x_to_array(_d_tbl, tbl);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_tbl);
    end;
end;


procedure spline1dunpack( c: Tspline1dinterpolant; out  n: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_spline1dunpack(c, n, tbl, _xparams);
end;


procedure _core_spline1dlintransx( c: Tspline1dinterpolant;  a: Double;  b: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_a: Double;
    _d_b: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_a := a;
        _d_b := b;
        _error_code := x_xv2_spline1dlintransx(@_s_error_msg, @_d_c, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dlintransx call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline1dlintransx( c: Tspline1dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
begin
    _core_spline1dlintransx(c, a, b, _xparams);
end;


procedure _core_spline1dlintransy( c: Tspline1dinterpolant;  a: Double;  b: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_a: Double;
    _d_b: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_a := a;
        _d_b := b;
        _error_code := x_xv2_spline1dlintransy(@_s_error_msg, @_d_c, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dlintransy call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline1dlintransy( c: Tspline1dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
begin
    _core_spline1dlintransy(c, a, b, _xparams);
end;


function _core_spline1dintegrate( c: Tspline1dinterpolant;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c : Pointer;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _error_code := x_xv2_spline1dintegrate(@_s_error_msg, @_d_result, @_d_c, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dintegrate call');
        end;
        result := _d_result;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function spline1dintegrate( c: Tspline1dinterpolant;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spline1dintegrate(c, x, _xparams);
end;


procedure _core_spline1dfit( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  lambdans: Double; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_lambdans: Double;
    _d_s : Pointer;
    _d_rep: x_spline1dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_lambdans := lambdans;
        _d_s := nil;
        s := nil;
        x_spline1dfitreport_init(_d_rep);
        _error_code := x_xv2_spline1dfit(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m, @_d_lambdans, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dfit call');
        end;
        s := Tspline1dinterpolant.Create(_d_s);
        x_spline1dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline1dfitreport_clear(_d_rep);
    end;
end;


procedure spline1dfit( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  lambdans: Double; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dfit(x, y, n, m, lambdans, s, rep, _xparams);
end;


procedure spline1dfit( x: TVector;  y: TVector;  m: TALGLIBInteger;  lambdans: Double; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dfit: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dfit(x, y, n, m, lambdans, s, rep, _xparams);

end;


procedure _core_spline1dbuildmonotone( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline1dbuildmonotone(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dbuildmonotone call');
        end;
        c := Tspline1dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline1dbuildmonotone( x: TVector;  y: TVector;  n: TALGLIBInteger; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dbuildmonotone(x, y, n, c, _xparams);
end;


procedure spline1dbuildmonotone( x: TVector;  y: TVector; out  c: Tspline1dinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dbuildmonotone: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dbuildmonotone(x, y, n, c, _xparams);

end;

constructor Tpspline2interpolant.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tpspline2interpolant.Destroy();
begin
    Deallocate();
end;

function Tpspline2interpolant.Clone():Tpspline2interpolant;
begin
    if ptr=nil then
        Result:=Tpspline2interpolant.Create(nil)
    else
        Result:=Tpspline2interpolant.Create(x_obj_copy_pspline2interpolant(ptr));
end;

procedure Tpspline2interpolant.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_pspline2interpolant(ptr);
    ptr:=nil;
end;

constructor Tpspline3interpolant.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tpspline3interpolant.Destroy();
begin
    Deallocate();
end;

function Tpspline3interpolant.Clone():Tpspline3interpolant;
begin
    if ptr=nil then
        Result:=Tpspline3interpolant.Create(nil)
    else
        Result:=Tpspline3interpolant.Create(x_obj_copy_pspline3interpolant(ptr));
end;

procedure Tpspline3interpolant.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_pspline3interpolant(ptr);
    ptr:=nil;
end;


procedure _core_pspline2build( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline2interpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_n: NativeInt;
    _d_st: NativeInt;
    _d_pt: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _d_st := st;
        _d_pt := pt;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_pspline2build(@_s_error_msg, @_d_xy, @_d_n, @_d_st, @_d_pt, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2build call');
        end;
        p := Tpspline2interpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_pspline2interpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure pspline2build( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline2interpolant; const _xparams: UInt64 = 0);
begin
    _core_pspline2build(xy, n, st, pt, p, _xparams);
end;


procedure _core_pspline3build( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline3interpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_n: NativeInt;
    _d_st: NativeInt;
    _d_pt: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _d_st := st;
        _d_pt := pt;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_pspline3build(@_s_error_msg, @_d_xy, @_d_n, @_d_st, @_d_pt, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3build call');
        end;
        p := Tpspline3interpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_pspline3interpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure pspline3build( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline3interpolant; const _xparams: UInt64 = 0);
begin
    _core_pspline3build(xy, n, st, pt, p, _xparams);
end;


procedure _core_pspline2buildperiodic( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline2interpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_n: NativeInt;
    _d_st: NativeInt;
    _d_pt: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _d_st := st;
        _d_pt := pt;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_pspline2buildperiodic(@_s_error_msg, @_d_xy, @_d_n, @_d_st, @_d_pt, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2buildperiodic call');
        end;
        p := Tpspline2interpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_pspline2interpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure pspline2buildperiodic( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline2interpolant; const _xparams: UInt64 = 0);
begin
    _core_pspline2buildperiodic(xy, n, st, pt, p, _xparams);
end;


procedure _core_pspline3buildperiodic( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline3interpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_n: NativeInt;
    _d_st: NativeInt;
    _d_pt: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _d_st := st;
        _d_pt := pt;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_pspline3buildperiodic(@_s_error_msg, @_d_xy, @_d_n, @_d_st, @_d_pt, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3buildperiodic call');
        end;
        p := Tpspline3interpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_pspline3interpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure pspline3buildperiodic( xy: TMatrix;  n: TALGLIBInteger;  st: TALGLIBInteger;  pt: TALGLIBInteger; out  p: Tpspline3interpolant; const _xparams: UInt64 = 0);
begin
    _core_pspline3buildperiodic(xy, n, st, pt, p, _xparams);
end;


procedure _core_pspline2parametervalues( p: Tpspline2interpolant; out  n: TALGLIBInteger; out  t: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_n: NativeInt;
    _d_t: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        x_create_empty(_d_t, DT_REAL);
        t := nil;
        _error_code := x_xv2_pspline2parametervalues(@_s_error_msg, @_d_p, @_d_n, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2parametervalues call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        n := _d_n;
        x_to_array(_d_t, t);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_t);
    end;
end;


procedure pspline2parametervalues( p: Tpspline2interpolant; out  n: TALGLIBInteger; out  t: TVector; const _xparams: UInt64 = 0);
begin
    _core_pspline2parametervalues(p, n, t, _xparams);
end;


procedure _core_pspline3parametervalues( p: Tpspline3interpolant; out  n: TALGLIBInteger; out  t: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_n: NativeInt;
    _d_t: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        x_create_empty(_d_t, DT_REAL);
        t := nil;
        _error_code := x_xv2_pspline3parametervalues(@_s_error_msg, @_d_p, @_d_n, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3parametervalues call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        n := _d_n;
        x_to_array(_d_t, t);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_t);
    end;
end;


procedure pspline3parametervalues( p: Tpspline3interpolant; out  n: TALGLIBInteger; out  t: TVector; const _xparams: UInt64 = 0);
begin
    _core_pspline3parametervalues(p, n, t, _xparams);
end;


procedure _core_pspline2calc( p: Tpspline2interpolant;  t: Double; out  x: Double; out  y: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline2calc(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2calc call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        y := _d_y;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline2calc( p: Tpspline2interpolant;  t: Double; out  x: Double; out  y: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline2calc(p, t, x, y, _xparams);
end;


procedure _core_pspline3calc( p: Tpspline3interpolant;  t: Double; out  x: Double; out  y: Double; out  z: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_y: Double;
    _d_z: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline3calc(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_y, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3calc call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        y := _d_y;
        z := _d_z;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline3calc( p: Tpspline3interpolant;  t: Double; out  x: Double; out  y: Double; out  z: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline3calc(p, t, x, y, z, _xparams);
end;


procedure _core_pspline2tangent( p: Tpspline2interpolant;  t: Double; out  x: Double; out  y: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline2tangent(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2tangent call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        y := _d_y;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline2tangent( p: Tpspline2interpolant;  t: Double; out  x: Double; out  y: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline2tangent(p, t, x, y, _xparams);
end;


procedure _core_pspline3tangent( p: Tpspline3interpolant;  t: Double; out  x: Double; out  y: Double; out  z: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_y: Double;
    _d_z: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline3tangent(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_y, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3tangent call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        y := _d_y;
        z := _d_z;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline3tangent( p: Tpspline3interpolant;  t: Double; out  x: Double; out  y: Double; out  z: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline3tangent(p, t, x, y, z, _xparams);
end;


procedure _core_pspline2diff( p: Tpspline2interpolant;  t: Double; out  x: Double; out  dx: Double; out  y: Double; out  dy: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_dx: Double;
    _d_y: Double;
    _d_dy: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline2diff(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_dx, @_d_y, @_d_dy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2diff call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        dx := _d_dx;
        y := _d_y;
        dy := _d_dy;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline2diff( p: Tpspline2interpolant;  t: Double; out  x: Double; out  dx: Double; out  y: Double; out  dy: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline2diff(p, t, x, dx, y, dy, _xparams);
end;


procedure _core_pspline3diff( p: Tpspline3interpolant;  t: Double; out  x: Double; out  dx: Double; out  y: Double; out  dy: Double; out  z: Double; out  dz: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_dx: Double;
    _d_y: Double;
    _d_dy: Double;
    _d_z: Double;
    _d_dz: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline3diff(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_dx, @_d_y, @_d_dy, @_d_z, @_d_dz, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3diff call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        dx := _d_dx;
        y := _d_y;
        dy := _d_dy;
        z := _d_z;
        dz := _d_dz;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline3diff( p: Tpspline3interpolant;  t: Double; out  x: Double; out  dx: Double; out  y: Double; out  dy: Double; out  z: Double; out  dz: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline3diff(p, t, x, dx, y, dy, z, dz, _xparams);
end;


procedure _core_pspline2diff2( p: Tpspline2interpolant;  t: Double; out  x: Double; out  dx: Double; out  d2x: Double; out  y: Double; out  dy: Double; out  d2y: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_dx: Double;
    _d_d2x: Double;
    _d_y: Double;
    _d_dy: Double;
    _d_d2y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline2diff2(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_dx, @_d_d2x, @_d_y, @_d_dy, @_d_d2y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2diff2 call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        dx := _d_dx;
        d2x := _d_d2x;
        y := _d_y;
        dy := _d_dy;
        d2y := _d_d2y;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline2diff2( p: Tpspline2interpolant;  t: Double; out  x: Double; out  dx: Double; out  d2x: Double; out  y: Double; out  dy: Double; out  d2y: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline2diff2(p, t, x, dx, d2x, y, dy, d2y, _xparams);
end;


procedure _core_pspline3diff2( p: Tpspline3interpolant;  t: Double; out  x: Double; out  dx: Double; out  d2x: Double; out  y: Double; out  dy: Double; out  d2y: Double; out  z: Double; out  dz: Double; out  d2z: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_t: Double;
    _d_x: Double;
    _d_dx: Double;
    _d_d2x: Double;
    _d_y: Double;
    _d_dy: Double;
    _d_d2y: Double;
    _d_z: Double;
    _d_dz: Double;
    _d_d2z: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_t := t;
        _error_code := x_xv2_pspline3diff2(@_s_error_msg, @_d_p, @_d_t, @_d_x, @_d_dx, @_d_d2x, @_d_y, @_d_dy, @_d_d2y, @_d_z, @_d_dz, @_d_d2z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3diff2 call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x := _d_x;
        dx := _d_dx;
        d2x := _d_d2x;
        y := _d_y;
        dy := _d_dy;
        d2y := _d_d2y;
        z := _d_z;
        dz := _d_dz;
        d2z := _d_d2z;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pspline3diff2( p: Tpspline3interpolant;  t: Double; out  x: Double; out  dx: Double; out  d2x: Double; out  y: Double; out  dy: Double; out  d2y: Double; out  z: Double; out  dz: Double; out  d2z: Double; const _xparams: UInt64 = 0);
begin
    _core_pspline3diff2(p, t, x, dx, d2x, y, dy, d2y, z, dz, d2z, _xparams);
end;


function _core_pspline2arclength( p: Tpspline2interpolant;  a: Double;  b: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_p : Pointer;
    _d_a: Double;
    _d_b: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_a := a;
        _d_b := b;
        _error_code := x_xv2_pspline2arclength(@_s_error_msg, @_d_result, @_d_p, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline2arclength call');
        end;
        result := _d_result;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function pspline2arclength( p: Tpspline2interpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_pspline2arclength(p, a, b, _xparams);
end;


function _core_pspline3arclength( p: Tpspline3interpolant;  a: Double;  b: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_p : Pointer;
    _d_a: Double;
    _d_b: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_a := a;
        _d_b := b;
        _error_code := x_xv2_pspline3arclength(@_s_error_msg, @_d_result, @_d_p, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pspline3arclength call');
        end;
        result := _d_result;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function pspline3arclength( p: Tpspline3interpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_pspline3arclength(p, a, b, _xparams);
end;


procedure _core_parametricrdpfixed( x: TMatrix;  n: TALGLIBInteger;  d: TALGLIBInteger;  stopm: TALGLIBInteger;  stopeps: Double; out  x2: TMatrix; out  idx2: TIVector; out  nsections: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_n: NativeInt;
    _d_d: NativeInt;
    _d_stopm: NativeInt;
    _d_stopeps: Double;
    _d_x2: x_matrix;
    _d_idx2: x_vector;
    _d_nsections: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_d := d;
        _d_stopm := stopm;
        _d_stopeps := stopeps;
        x_create_empty(_d_x2, DT_REAL);
        x2 := nil;
        x_create_empty(_d_idx2, DT_INT);
        idx2 := nil;
        _error_code := x_xv2_parametricrdpfixed(@_s_error_msg, @_d_x, @_d_n, @_d_d, @_d_stopm, @_d_stopeps, @_d_x2, @_d_idx2, @_d_nsections, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during parametricrdpfixed call');
        end;
        x_to_array(_d_x2, x2);
        x_to_array(_d_idx2, idx2);
        nsections := _d_nsections;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_x2);
        x_clear(_d_idx2);
    end;
end;


procedure parametricrdpfixed( x: TMatrix;  n: TALGLIBInteger;  d: TALGLIBInteger;  stopm: TALGLIBInteger;  stopeps: Double; out  x2: TMatrix; out  idx2: TIVector; out  nsections: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_parametricrdpfixed(x, n, d, stopm, stopeps, x2, idx2, nsections, _xparams);
end;

constructor Tspline3dinterpolant.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tspline3dinterpolant.Destroy();
begin
    Deallocate();
end;

function Tspline3dinterpolant.Clone():Tspline3dinterpolant;
begin
    if ptr=nil then
        Result:=Tspline3dinterpolant.Create(nil)
    else
        Result:=Tspline3dinterpolant.Create(x_obj_copy_spline3dinterpolant(ptr));
end;

procedure Tspline3dinterpolant.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_spline3dinterpolant(ptr);
    ptr:=nil;
end;


function _core_spline3dcalc( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_z: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        _d_z := z;
        _error_code := x_xv2_spline3dcalc(@_s_error_msg, @_d_result, @_d_c, @_d_x, @_d_y, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dcalc call');
        end;
        result := _d_result;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function spline3dcalc( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spline3dcalc(c, x, y, z, _xparams);
end;


procedure _core_spline3dlintransxyz( c: Tspline3dinterpolant;  ax: Double;  bx: Double;  ay: Double;  by: Double;  az: Double;  bz: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_ax: Double;
    _d_bx: Double;
    _d_ay: Double;
    _d_by: Double;
    _d_az: Double;
    _d_bz: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_ax := ax;
        _d_bx := bx;
        _d_ay := ay;
        _d_by := by;
        _d_az := az;
        _d_bz := bz;
        _error_code := x_xv2_spline3dlintransxyz(@_s_error_msg, @_d_c, @_d_ax, @_d_bx, @_d_ay, @_d_by, @_d_az, @_d_bz, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dlintransxyz call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline3dlintransxyz( c: Tspline3dinterpolant;  ax: Double;  bx: Double;  ay: Double;  by: Double;  az: Double;  bz: Double; const _xparams: UInt64 = 0);
begin
    _core_spline3dlintransxyz(c, ax, bx, ay, by, az, bz, _xparams);
end;


procedure _core_spline3dlintransf( c: Tspline3dinterpolant;  a: Double;  b: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_a: Double;
    _d_b: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_a := a;
        _d_b := b;
        _error_code := x_xv2_spline3dlintransf(@_s_error_msg, @_d_c, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dlintransf call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline3dlintransf( c: Tspline3dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
begin
    _core_spline3dlintransf(c, a, b, _xparams);
end;


procedure _core_spline3dresampletrilinear( a: TVector;  oldzcount: TALGLIBInteger;  oldycount: TALGLIBInteger;  oldxcount: TALGLIBInteger;  newzcount: TALGLIBInteger;  newycount: TALGLIBInteger;  newxcount: TALGLIBInteger; out  b: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_oldzcount: NativeInt;
    _d_oldycount: NativeInt;
    _d_oldxcount: NativeInt;
    _d_newzcount: NativeInt;
    _d_newycount: NativeInt;
    _d_newxcount: NativeInt;
    _d_b: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_oldzcount := oldzcount;
        _d_oldycount := oldycount;
        _d_oldxcount := oldxcount;
        _d_newzcount := newzcount;
        _d_newycount := newycount;
        _d_newxcount := newxcount;
        x_create_empty(_d_b, DT_REAL);
        b := nil;
        _error_code := x_xv2_spline3dresampletrilinear(@_s_error_msg, @_d_a, @_d_oldzcount, @_d_oldycount, @_d_oldxcount, @_d_newzcount, @_d_newycount, @_d_newxcount, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dresampletrilinear call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure spline3dresampletrilinear( a: TVector;  oldzcount: TALGLIBInteger;  oldycount: TALGLIBInteger;  oldxcount: TALGLIBInteger;  newzcount: TALGLIBInteger;  newycount: TALGLIBInteger;  newxcount: TALGLIBInteger; out  b: TVector; const _xparams: UInt64 = 0);
begin
    _core_spline3dresampletrilinear(a, oldzcount, oldycount, oldxcount, newzcount, newycount, newxcount, b, _xparams);
end;


procedure _core_spline3dbuildtrilinearv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  z: TVector;  l: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline3dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_y: x_vector;
    _d_m: NativeInt;
    _d_z: x_vector;
    _d_l: NativeInt;
    _d_f: x_vector;
    _d_d: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        x_from_array(_d_y, y, X_CREATE);
        _d_m := m;
        x_from_array(_d_z, z, X_CREATE);
        _d_l := l;
        x_from_array(_d_f, f, X_CREATE);
        _d_d := d;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline3dbuildtrilinearv(@_s_error_msg, @_d_x, @_d_n, @_d_y, @_d_m, @_d_z, @_d_l, @_d_f, @_d_d, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dbuildtrilinearv call');
        end;
        c := Tspline3dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_z);
        x_clear(_d_f);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline3dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline3dbuildtrilinearv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  z: TVector;  l: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline3dinterpolant; const _xparams: UInt64 = 0);
begin
    _core_spline3dbuildtrilinearv(x, n, y, m, z, l, f, d, c, _xparams);
end;


procedure _core_spline3dcalcvbuf( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; var  f: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_z: Double;
    _d_f: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        _d_z := z;
        x_from_array(_d_f, f, X_CREATE);
        _error_code := x_xv2_spline3dcalcvbuf(@_s_error_msg, @_d_c, @_d_x, @_d_y, @_d_z, @_d_f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dcalcvbuf call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_f, f);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
    end;
end;


procedure spline3dcalcvbuf( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; var  f: TVector; const _xparams: UInt64 = 0);
begin
    _core_spline3dcalcvbuf(c, x, y, z, f, _xparams);
end;


procedure _core_spline3dcalcv( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; out  f: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_z: Double;
    _d_f: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        _d_z := z;
        x_create_empty(_d_f, DT_REAL);
        f := nil;
        _error_code := x_xv2_spline3dcalcv(@_s_error_msg, @_d_c, @_d_x, @_d_y, @_d_z, @_d_f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dcalcv call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_f, f);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
    end;
end;


procedure spline3dcalcv( c: Tspline3dinterpolant;  x: Double;  y: Double;  z: Double; out  f: TVector; const _xparams: UInt64 = 0);
begin
    _core_spline3dcalcv(c, x, y, z, f, _xparams);
end;


procedure _core_spline3dunpackv( c: Tspline3dinterpolant; out  n: TALGLIBInteger; out  m: TALGLIBInteger; out  l: TALGLIBInteger; out  d: TALGLIBInteger; out  stype: TALGLIBInteger; out  tbl: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_l: NativeInt;
    _d_d: NativeInt;
    _d_stype: NativeInt;
    _d_tbl: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        x_create_empty(_d_tbl, DT_REAL);
        tbl := nil;
        _error_code := x_xv2_spline3dunpackv(@_s_error_msg, @_d_c, @_d_n, @_d_m, @_d_l, @_d_d, @_d_stype, @_d_tbl, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline3dunpackv call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        n := _d_n;
        m := _d_m;
        l := _d_l;
        d := _d_d;
        stype := _d_stype;
        x_to_array(_d_tbl, tbl);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_tbl);
    end;
end;


procedure spline3dunpackv( c: Tspline3dinterpolant; out  n: TALGLIBInteger; out  m: TALGLIBInteger; out  l: TALGLIBInteger; out  d: TALGLIBInteger; out  stype: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_spline3dunpackv(c, n, m, l, d, stype, tbl, _xparams);
end;


procedure _core_polynomialbar2cheb( p: Tbarycentricinterpolant;  a: Double;  b: Double; out  t: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_a: Double;
    _d_b: Double;
    _d_t: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_a := a;
        _d_b := b;
        x_create_empty(_d_t, DT_REAL);
        t := nil;
        _error_code := x_xv2_polynomialbar2cheb(@_s_error_msg, @_d_p, @_d_a, @_d_b, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialbar2cheb call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_t, t);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_t);
    end;
end;


procedure polynomialbar2cheb( p: Tbarycentricinterpolant;  a: Double;  b: Double; out  t: TVector; const _xparams: UInt64 = 0);
begin
    _core_polynomialbar2cheb(p, a, b, t, _xparams);
end;


procedure _core_polynomialcheb2bar( t: TVector;  n: TALGLIBInteger;  a: Double;  b: Double; out  p: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_t: x_vector;
    _d_n: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_t, t, X_CREATE);
        _d_n := n;
        _d_a := a;
        _d_b := b;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_polynomialcheb2bar(@_s_error_msg, @_d_t, @_d_n, @_d_a, @_d_b, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialcheb2bar call');
        end;
        p := Tbarycentricinterpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_t);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure polynomialcheb2bar( t: TVector;  n: TALGLIBInteger;  a: Double;  b: Double; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialcheb2bar(t, n, a, b, p, _xparams);
end;


procedure polynomialcheb2bar( t: TVector;  a: Double;  b: Double; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(t);

    _core_polynomialcheb2bar(t, n, a, b, p, _xparams);

end;


procedure _core_polynomialbar2pow( p: Tbarycentricinterpolant;  c: Double;  s: Double; out  a: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_p : Pointer;
    _d_c: Double;
    _d_s: Double;
    _d_a: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_p := p.ptr;
        _d_c := c;
        _d_s := s;
        x_create_empty(_d_a, DT_REAL);
        a := nil;
        _error_code := x_xv2_polynomialbar2pow(@_s_error_msg, @_d_p, @_d_c, @_d_s, @_d_a, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialbar2pow call');
        end;
        Assert(p.ptr=_d_p, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_a, a);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


procedure polynomialbar2pow( p: Tbarycentricinterpolant;  c: Double;  s: Double; out  a: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialbar2pow(p, c, s, a, _xparams);
end;


procedure polynomialbar2pow( p: Tbarycentricinterpolant; out  a: TVector; const _xparams: UInt64 = 0);overload;
var
    c: Double;
    s: Double;

begin

    c := 0;
    s := 1;

    _core_polynomialbar2pow(p, c, s, a, _xparams);

end;


procedure _core_polynomialpow2bar( a: TVector;  n: TALGLIBInteger;  c: Double;  s: Double; out  p: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
    _d_c: Double;
    _d_s: Double;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_c := c;
        _d_s := s;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_polynomialpow2bar(@_s_error_msg, @_d_a, @_d_n, @_d_c, @_d_s, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialpow2bar call');
        end;
        p := Tbarycentricinterpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure polynomialpow2bar( a: TVector;  n: TALGLIBInteger;  c: Double;  s: Double; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialpow2bar(a, n, c, s, p, _xparams);
end;


procedure polynomialpow2bar( a: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    c: Double;
    s: Double;

begin

    n := xlen(a);
    c := 0;
    s := 1;

    _core_polynomialpow2bar(a, n, c, s, p, _xparams);

end;


procedure _core_polynomialbuild( x: TVector;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_polynomialbuild(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialbuild call');
        end;
        p := Tbarycentricinterpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure polynomialbuild( x: TVector;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialbuild(x, y, n, p, _xparams);
end;


procedure polynomialbuild( x: TVector;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling polynomialbuild: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_polynomialbuild(x, y, n, p, _xparams);

end;


procedure _core_polynomialbuildeqdist( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: Double;
    _d_b: Double;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_polynomialbuildeqdist(@_s_error_msg, @_d_a, @_d_b, @_d_y, @_d_n, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialbuildeqdist call');
        end;
        p := Tbarycentricinterpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure polynomialbuildeqdist( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialbuildeqdist(a, b, y, n, p, _xparams);
end;


procedure polynomialbuildeqdist( a: Double;  b: Double;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(y);

    _core_polynomialbuildeqdist(a, b, y, n, p, _xparams);

end;


procedure _core_polynomialbuildcheb1( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: Double;
    _d_b: Double;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_polynomialbuildcheb1(@_s_error_msg, @_d_a, @_d_b, @_d_y, @_d_n, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialbuildcheb1 call');
        end;
        p := Tbarycentricinterpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure polynomialbuildcheb1( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialbuildcheb1(a, b, y, n, p, _xparams);
end;


procedure polynomialbuildcheb1( a: Double;  b: Double;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(y);

    _core_polynomialbuildcheb1(a, b, y, n, p, _xparams);

end;


procedure _core_polynomialbuildcheb2( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: Double;
    _d_b: Double;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_p : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_p := nil;
        p := nil;
        _error_code := x_xv2_polynomialbuildcheb2(@_s_error_msg, @_d_a, @_d_b, @_d_y, @_d_n, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialbuildcheb2 call');
        end;
        p := Tbarycentricinterpolant.Create(_d_p);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure polynomialbuildcheb2( a: Double;  b: Double;  y: TVector;  n: TALGLIBInteger; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialbuildcheb2(a, b, y, n, p, _xparams);
end;


procedure polynomialbuildcheb2( a: Double;  b: Double;  y: TVector; out  p: Tbarycentricinterpolant; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(y);

    _core_polynomialbuildcheb2(a, b, y, n, p, _xparams);

end;


function _core_polynomialcalceqdist( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_b: Double;
    _d_f: x_vector;
    _d_n: NativeInt;
    _d_t: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        x_from_array(_d_f, f, X_CREATE);
        _d_n := n;
        _d_t := t;
        _error_code := x_xv2_polynomialcalceqdist(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_f, @_d_n, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialcalceqdist call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
    end;
end;


function polynomialcalceqdist( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_polynomialcalceqdist(a, b, f, n, t, _xparams);
end;


function polynomialcalceqdist( a: Double;  b: Double;  f: TVector;  t: Double; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(f);

    Result := _core_polynomialcalceqdist(a, b, f, n, t, _xparams);

end;


function _core_polynomialcalccheb1( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_b: Double;
    _d_f: x_vector;
    _d_n: NativeInt;
    _d_t: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        x_from_array(_d_f, f, X_CREATE);
        _d_n := n;
        _d_t := t;
        _error_code := x_xv2_polynomialcalccheb1(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_f, @_d_n, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialcalccheb1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
    end;
end;


function polynomialcalccheb1( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_polynomialcalccheb1(a, b, f, n, t, _xparams);
end;


function polynomialcalccheb1( a: Double;  b: Double;  f: TVector;  t: Double; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(f);

    Result := _core_polynomialcalccheb1(a, b, f, n, t, _xparams);

end;


function _core_polynomialcalccheb2( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_b: Double;
    _d_f: x_vector;
    _d_n: NativeInt;
    _d_t: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        x_from_array(_d_f, f, X_CREATE);
        _d_n := n;
        _d_t := t;
        _error_code := x_xv2_polynomialcalccheb2(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_f, @_d_n, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialcalccheb2 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
    end;
end;


function polynomialcalccheb2( a: Double;  b: Double;  f: TVector;  n: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_polynomialcalccheb2(a, b, f, n, t, _xparams);
end;


function polynomialcalccheb2( a: Double;  b: Double;  f: TVector;  t: Double; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(f);

    Result := _core_polynomialcalccheb2(a, b, f, n, t, _xparams);

end;

function Clone(const Src: Tpolynomialfitreport):Tpolynomialfitreport;overload;
begin
    Result.taskrcond := src.taskrcond;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
    Result.maxerror := src.maxerror;
end;

procedure x_polynomialfitreport_init(var x: x_polynomialfitreport);
begin
    x.taskrcond := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
    x.maxerror := 0;
end;

procedure x_polynomialfitreport_clear(var x: x_polynomialfitreport);
begin
end;

procedure x_polynomialfitreport_init_from(var x: x_polynomialfitreport; const v: Tpolynomialfitreport);
begin
    x.taskrcond := v.taskrcond;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
    x.maxerror := v.maxerror;
end;

procedure x_polynomialfitreport_to_record(const x: x_polynomialfitreport; var v: Tpolynomialfitreport);
begin
    v.taskrcond := x.taskrcond;
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
    v.maxerror := x.maxerror;
end;

function Clone(const Src: Tbarycentricfitreport):Tbarycentricfitreport;overload;
begin
    Result.taskrcond := src.taskrcond;
    Result.dbest := src.dbest;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
    Result.maxerror := src.maxerror;
end;

procedure x_barycentricfitreport_init(var x: x_barycentricfitreport);
begin
    x.taskrcond := 0;
    x.dbest.longval := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
    x.maxerror := 0;
end;

procedure x_barycentricfitreport_clear(var x: x_barycentricfitreport);
begin
end;

procedure x_barycentricfitreport_init_from(var x: x_barycentricfitreport; const v: Tbarycentricfitreport);
begin
    x.taskrcond := v.taskrcond;
    x.dbest.longval := v.dbest;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
    x.maxerror := v.maxerror;
end;

procedure x_barycentricfitreport_to_record(const x: x_barycentricfitreport; var v: Tbarycentricfitreport);
begin
    v.taskrcond := x.taskrcond;
    v.dbest := x.dbest.val; // long is silently truncated to TALGLIBInteger
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
    v.maxerror := x.maxerror;
end;

function Clone(const Src: Tlsfitreport):Tlsfitreport;overload;
begin
    Result.taskrcond := src.taskrcond;
    Result.iterationscount := src.iterationscount;
    Result.varidx := src.varidx;
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.avgrelerror := src.avgrelerror;
    Result.maxerror := src.maxerror;
    Result.wrmserror := src.wrmserror;
    Result.covpar := Clone(src.covpar);
    Result.errpar := Clone(src.errpar);
    Result.errcurve := Clone(src.errcurve);
    Result.noise := Clone(src.noise);
    Result.r2 := src.r2;
end;

procedure x_lsfitreport_init(var x: x_lsfitreport);
begin
    x.taskrcond := 0;
    x.iterationscount.longval := 0;
    x.varidx.longval := 0;
    x.rmserror := 0;
    x.avgerror := 0;
    x.avgrelerror := 0;
    x.maxerror := 0;
    x.wrmserror := 0;
    x_create_empty(x.covpar, DT_REAL);
    x_create_empty(x.errpar, DT_REAL);
    x_create_empty(x.errcurve, DT_REAL);
    x_create_empty(x.noise, DT_REAL);
    x.r2 := 0;
end;

procedure x_lsfitreport_clear(var x: x_lsfitreport);
begin
    x_clear(x.covpar);
    x_clear(x.errpar);
    x_clear(x.errcurve);
    x_clear(x.noise);
end;

procedure x_lsfitreport_init_from(var x: x_lsfitreport; const v: Tlsfitreport);
begin
    x.taskrcond := v.taskrcond;
    x.iterationscount.longval := v.iterationscount;
    x.varidx.longval := v.varidx;
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.avgrelerror := v.avgrelerror;
    x.maxerror := v.maxerror;
    x.wrmserror := v.wrmserror;
    x_from_array(x.covpar, v.covpar, X_CREATE);
    x_from_array(x.errpar, v.errpar, X_CREATE);
    x_from_array(x.errcurve, v.errcurve, X_CREATE);
    x_from_array(x.noise, v.noise, X_CREATE);
    x.r2 := v.r2;
end;

procedure x_lsfitreport_to_record(const x: x_lsfitreport; var v: Tlsfitreport);
begin
    v.taskrcond := x.taskrcond;
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.varidx := x.varidx.val; // long is silently truncated to TALGLIBInteger
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.avgrelerror := x.avgrelerror;
    v.maxerror := x.maxerror;
    v.wrmserror := x.wrmserror;
    x_to_array(x.covpar, v.covpar);
    x_to_array(x.errpar, v.errpar);
    x_to_array(x.errcurve, v.errcurve);
    x_to_array(x.noise, v.noise);
    v.r2 := x.r2;
end;

constructor Tlsfitstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tlsfitstate.Destroy();
begin
    Deallocate();
end;

function Tlsfitstate.Clone():Tlsfitstate;
begin
    if ptr=nil then
        Result:=Tlsfitstate.Create(nil)
    else
        Result:=Tlsfitstate.Create(x_obj_copy_lsfitstate(ptr));
end;

procedure Tlsfitstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_lsfitstate(ptr);
    ptr:=nil;
end;


procedure _core_lstfitpiecewiselinearrdpfixed( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  x2: TVector; out  y2: TVector; out  nsections: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x2: x_vector;
    _d_y2: x_vector;
    _d_nsections: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m := m;
        x_create_empty(_d_x2, DT_REAL);
        x2 := nil;
        x_create_empty(_d_y2, DT_REAL);
        y2 := nil;
        _error_code := x_xv2_lstfitpiecewiselinearrdpfixed(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m, @_d_x2, @_d_y2, @_d_nsections, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lstfitpiecewiselinearrdpfixed call');
        end;
        x_to_array(_d_x2, x2);
        x_to_array(_d_y2, y2);
        nsections := _d_nsections;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_x2);
        x_clear(_d_y2);
    end;
end;


procedure lstfitpiecewiselinearrdpfixed( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  x2: TVector; out  y2: TVector; out  nsections: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_lstfitpiecewiselinearrdpfixed(x, y, n, m, x2, y2, nsections, _xparams);
end;


procedure _core_lstfitpiecewiselinearrdp( x: TVector;  y: TVector;  n: TALGLIBInteger;  eps: Double; out  x2: TVector; out  y2: TVector; out  nsections: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_eps: Double;
    _d_x2: x_vector;
    _d_y2: x_vector;
    _d_nsections: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_eps := eps;
        x_create_empty(_d_x2, DT_REAL);
        x2 := nil;
        x_create_empty(_d_y2, DT_REAL);
        y2 := nil;
        _error_code := x_xv2_lstfitpiecewiselinearrdp(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_eps, @_d_x2, @_d_y2, @_d_nsections, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lstfitpiecewiselinearrdp call');
        end;
        x_to_array(_d_x2, x2);
        x_to_array(_d_y2, y2);
        nsections := _d_nsections;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_x2);
        x_clear(_d_y2);
    end;
end;


procedure lstfitpiecewiselinearrdp( x: TVector;  y: TVector;  n: TALGLIBInteger;  eps: Double; out  x2: TVector; out  y2: TVector; out  nsections: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_lstfitpiecewiselinearrdp(x, y, n, eps, x2, y2, nsections, _xparams);
end;


procedure _core_polynomialfit( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_p : Pointer;
    _d_rep: x_polynomialfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_p := nil;
        p := nil;
        x_polynomialfitreport_init(_d_rep);
        _error_code := x_xv2_polynomialfit(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m, @_d_info, @_d_p, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialfit call');
        end;
        info := _d_info;
        p := Tbarycentricinterpolant.Create(_d_p);
        x_polynomialfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
        x_polynomialfitreport_clear(_d_rep);
    end;
end;


procedure polynomialfit( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialfit(x, y, n, m, info, p, rep, _xparams);
end;


procedure polynomialfit( x: TVector;  y: TVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling polynomialfit: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_polynomialfit(x, y, n, m, info, p, rep, _xparams);

end;


procedure _core_polynomialfitwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_n: NativeInt;
    _d_xc: x_vector;
    _d_yc: x_vector;
    _d_dc: x_vector;
    _d_k: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_p : Pointer;
    _d_rep: x_polynomialfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        _d_n := n;
        x_from_array(_d_xc, xc, X_CREATE);
        x_from_array(_d_yc, yc, X_CREATE);
        x_from_array(_d_dc, dc, X_CREATE);
        _d_k := k;
        _d_m := m;
        _d_p := nil;
        p := nil;
        x_polynomialfitreport_init(_d_rep);
        _error_code := x_xv2_polynomialfitwc(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_n, @_d_xc, @_d_yc, @_d_dc, @_d_k, @_d_m, @_d_info, @_d_p, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialfitwc call');
        end;
        info := _d_info;
        p := Tbarycentricinterpolant.Create(_d_p);
        x_polynomialfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_xc);
        x_clear(_d_yc);
        x_clear(_d_dc);
        if (_d_p<>nil) and (p=nil) then
            x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to Delphi objects
        x_polynomialfitreport_clear(_d_rep);
    end;
end;


procedure polynomialfitwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_polynomialfitwc(x, y, w, n, xc, yc, dc, k, m, info, p, rep, _xparams);
end;


procedure polynomialfitwc( x: TVector;  y: TVector;  w: TVector;  xc: TVector;  yc: TVector;  dc: TIVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  p: Tbarycentricinterpolant; out  rep: Tpolynomialfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) or ((xlen(x)<>xlen(w))) then
    raise Exception.Create('Error while calling polynomialfitwc: looks like one of arguments has wrong size');
    if ((xlen(xc)<>xlen(yc))) or ((xlen(xc)<>xlen(dc))) then
    raise Exception.Create('Error while calling polynomialfitwc: looks like one of arguments has wrong size');

    n := xlen(x);
    k := xlen(xc);

    _core_polynomialfitwc(x, y, w, n, xc, yc, dc, k, m, info, p, rep, _xparams);

end;


function _core_logisticcalc4( x: Double;  a: Double;  b: Double;  c: Double;  d: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
    _d_a: Double;
    _d_b: Double;
    _d_c: Double;
    _d_d: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _d_a := a;
        _d_b := b;
        _d_c := c;
        _d_d := d;
        _error_code := x_xv2_logisticcalc4(@_s_error_msg, @_d_result, @_d_x, @_d_a, @_d_b, @_d_c, @_d_d, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during logisticcalc4 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function logisticcalc4( x: Double;  a: Double;  b: Double;  c: Double;  d: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_logisticcalc4(x, a, b, c, d, _xparams);
end;


function _core_logisticcalc5( x: Double;  a: Double;  b: Double;  c: Double;  d: Double;  g: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
    _d_a: Double;
    _d_b: Double;
    _d_c: Double;
    _d_d: Double;
    _d_g: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _d_a := a;
        _d_b := b;
        _d_c := c;
        _d_d := d;
        _d_g := g;
        _error_code := x_xv2_logisticcalc5(@_s_error_msg, @_d_result, @_d_x, @_d_a, @_d_b, @_d_c, @_d_d, @_d_g, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during logisticcalc5 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function logisticcalc5( x: Double;  a: Double;  b: Double;  c: Double;  d: Double;  g: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_logisticcalc5(x, a, b, c, d, g, _xparams);
end;


procedure _core_logisticfit4( x: TVector;  y: TVector;  n: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_c: Double;
    _d_d: Double;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_logisticfit4(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_a, @_d_b, @_d_c, @_d_d, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during logisticfit4 call');
        end;
        a := _d_a;
        b := _d_b;
        c := _d_c;
        d := _d_d;
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure logisticfit4( x: TVector;  y: TVector;  n: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
begin
    _core_logisticfit4(x, y, n, a, b, c, d, rep, _xparams);
end;


procedure _core_logisticfit4ec( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_cnstrleft: Double;
    _d_cnstrright: Double;
    _d_a: Double;
    _d_b: Double;
    _d_c: Double;
    _d_d: Double;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_cnstrleft := cnstrleft;
        _d_cnstrright := cnstrright;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_logisticfit4ec(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_cnstrleft, @_d_cnstrright, @_d_a, @_d_b, @_d_c, @_d_d, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during logisticfit4ec call');
        end;
        a := _d_a;
        b := _d_b;
        c := _d_c;
        d := _d_d;
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure logisticfit4ec( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
begin
    _core_logisticfit4ec(x, y, n, cnstrleft, cnstrright, a, b, c, d, rep, _xparams);
end;


procedure _core_logisticfit5( x: TVector;  y: TVector;  n: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_c: Double;
    _d_d: Double;
    _d_g: Double;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_logisticfit5(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_a, @_d_b, @_d_c, @_d_d, @_d_g, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during logisticfit5 call');
        end;
        a := _d_a;
        b := _d_b;
        c := _d_c;
        d := _d_d;
        g := _d_g;
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure logisticfit5( x: TVector;  y: TVector;  n: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
begin
    _core_logisticfit5(x, y, n, a, b, c, d, g, rep, _xparams);
end;


procedure _core_logisticfit5ec( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_cnstrleft: Double;
    _d_cnstrright: Double;
    _d_a: Double;
    _d_b: Double;
    _d_c: Double;
    _d_d: Double;
    _d_g: Double;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_cnstrleft := cnstrleft;
        _d_cnstrright := cnstrright;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_logisticfit5ec(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_cnstrleft, @_d_cnstrright, @_d_a, @_d_b, @_d_c, @_d_d, @_d_g, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during logisticfit5ec call');
        end;
        a := _d_a;
        b := _d_b;
        c := _d_c;
        d := _d_d;
        g := _d_g;
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure logisticfit5ec( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
begin
    _core_logisticfit5ec(x, y, n, cnstrleft, cnstrright, a, b, c, d, g, rep, _xparams);
end;


procedure _core_logisticfit45x( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double;  is4pl: Boolean;  lambdav: Double;  epsx: Double;  rscnt: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_cnstrleft: Double;
    _d_cnstrright: Double;
    _d_is4pl: Byte;
    _d_lambdav: Double;
    _d_epsx: Double;
    _d_rscnt: NativeInt;
    _d_a: Double;
    _d_b: Double;
    _d_c: Double;
    _d_d: Double;
    _d_g: Double;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_cnstrleft := cnstrleft;
        _d_cnstrright := cnstrright;
        _d_is4pl := Bool2Byte(is4pl);
        _d_lambdav := lambdav;
        _d_epsx := epsx;
        _d_rscnt := rscnt;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_logisticfit45x(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_cnstrleft, @_d_cnstrright, @_d_is4pl, @_d_lambdav, @_d_epsx, @_d_rscnt, @_d_a, @_d_b, @_d_c, @_d_d, @_d_g, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during logisticfit45x call');
        end;
        a := _d_a;
        b := _d_b;
        c := _d_c;
        d := _d_d;
        g := _d_g;
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure logisticfit45x( x: TVector;  y: TVector;  n: TALGLIBInteger;  cnstrleft: Double;  cnstrright: Double;  is4pl: Boolean;  lambdav: Double;  epsx: Double;  rscnt: TALGLIBInteger; out  a: Double; out  b: Double; out  c: Double; out  d: Double; out  g: Double; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
begin
    _core_logisticfit45x(x, y, n, cnstrleft, cnstrright, is4pl, lambdav, epsx, rscnt, a, b, c, d, g, rep, _xparams);
end;


procedure _core_barycentricfitfloaterhormannwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  b: Tbarycentricinterpolant; out  rep: Tbarycentricfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_n: NativeInt;
    _d_xc: x_vector;
    _d_yc: x_vector;
    _d_dc: x_vector;
    _d_k: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_b : Pointer;
    _d_rep: x_barycentricfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        _d_n := n;
        x_from_array(_d_xc, xc, X_CREATE);
        x_from_array(_d_yc, yc, X_CREATE);
        x_from_array(_d_dc, dc, X_CREATE);
        _d_k := k;
        _d_m := m;
        _d_b := nil;
        b := nil;
        x_barycentricfitreport_init(_d_rep);
        _error_code := x_xv2_barycentricfitfloaterhormannwc(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_n, @_d_xc, @_d_yc, @_d_dc, @_d_k, @_d_m, @_d_info, @_d_b, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentricfitfloaterhormannwc call');
        end;
        info := _d_info;
        b := Tbarycentricinterpolant.Create(_d_b);
        x_barycentricfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_xc);
        x_clear(_d_yc);
        x_clear(_d_dc);
        if (_d_b<>nil) and (b=nil) then
            x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to Delphi objects
        x_barycentricfitreport_clear(_d_rep);
    end;
end;


procedure barycentricfitfloaterhormannwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  b: Tbarycentricinterpolant; out  rep: Tbarycentricfitreport; const _xparams: UInt64 = 0);
begin
    _core_barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, k, m, info, b, rep, _xparams);
end;


procedure _core_barycentricfitfloaterhormann( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  b: Tbarycentricinterpolant; out  rep: Tbarycentricfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_b : Pointer;
    _d_rep: x_barycentricfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_b := nil;
        b := nil;
        x_barycentricfitreport_init(_d_rep);
        _error_code := x_xv2_barycentricfitfloaterhormann(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m, @_d_info, @_d_b, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during barycentricfitfloaterhormann call');
        end;
        info := _d_info;
        b := Tbarycentricinterpolant.Create(_d_b);
        x_barycentricfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_b<>nil) and (b=nil) then
            x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to Delphi objects
        x_barycentricfitreport_clear(_d_rep);
    end;
end;


procedure barycentricfitfloaterhormann( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  b: Tbarycentricinterpolant; out  rep: Tbarycentricfitreport; const _xparams: UInt64 = 0);
begin
    _core_barycentricfitfloaterhormann(x, y, n, m, info, b, rep, _xparams);
end;


procedure _core_spline1dfitcubicwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_n: NativeInt;
    _d_xc: x_vector;
    _d_yc: x_vector;
    _d_dc: x_vector;
    _d_k: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_s : Pointer;
    _d_rep: x_spline1dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        _d_n := n;
        x_from_array(_d_xc, xc, X_CREATE);
        x_from_array(_d_yc, yc, X_CREATE);
        x_from_array(_d_dc, dc, X_CREATE);
        _d_k := k;
        _d_m := m;
        _d_s := nil;
        s := nil;
        x_spline1dfitreport_init(_d_rep);
        _error_code := x_xv2_spline1dfitcubicwc(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_n, @_d_xc, @_d_yc, @_d_dc, @_d_k, @_d_m, @_d_info, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dfitcubicwc call');
        end;
        info := _d_info;
        s := Tspline1dinterpolant.Create(_d_s);
        x_spline1dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_xc);
        x_clear(_d_yc);
        x_clear(_d_dc);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline1dfitreport_clear(_d_rep);
    end;
end;


procedure spline1dfitcubicwc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dfitcubicwc(x, y, w, n, xc, yc, dc, k, m, info, s, rep, _xparams);
end;


procedure spline1dfitcubicwc( x: TVector;  y: TVector;  w: TVector;  xc: TVector;  yc: TVector;  dc: TIVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) or ((xlen(x)<>xlen(w))) then
    raise Exception.Create('Error while calling spline1dfitcubicwc: looks like one of arguments has wrong size');
    if ((xlen(xc)<>xlen(yc))) or ((xlen(xc)<>xlen(dc))) then
    raise Exception.Create('Error while calling spline1dfitcubicwc: looks like one of arguments has wrong size');

    n := xlen(x);
    k := xlen(xc);

    _core_spline1dfitcubicwc(x, y, w, n, xc, yc, dc, k, m, info, s, rep, _xparams);

end;


procedure _core_spline1dfithermitewc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_n: NativeInt;
    _d_xc: x_vector;
    _d_yc: x_vector;
    _d_dc: x_vector;
    _d_k: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_s : Pointer;
    _d_rep: x_spline1dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        _d_n := n;
        x_from_array(_d_xc, xc, X_CREATE);
        x_from_array(_d_yc, yc, X_CREATE);
        x_from_array(_d_dc, dc, X_CREATE);
        _d_k := k;
        _d_m := m;
        _d_s := nil;
        s := nil;
        x_spline1dfitreport_init(_d_rep);
        _error_code := x_xv2_spline1dfithermitewc(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_n, @_d_xc, @_d_yc, @_d_dc, @_d_k, @_d_m, @_d_info, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dfithermitewc call');
        end;
        info := _d_info;
        s := Tspline1dinterpolant.Create(_d_s);
        x_spline1dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_xc);
        x_clear(_d_yc);
        x_clear(_d_dc);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline1dfitreport_clear(_d_rep);
    end;
end;


procedure spline1dfithermitewc( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  xc: TVector;  yc: TVector;  dc: TIVector;  k: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dfithermitewc(x, y, w, n, xc, yc, dc, k, m, info, s, rep, _xparams);
end;


procedure spline1dfithermitewc( x: TVector;  y: TVector;  w: TVector;  xc: TVector;  yc: TVector;  dc: TIVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) or ((xlen(x)<>xlen(w))) then
    raise Exception.Create('Error while calling spline1dfithermitewc: looks like one of arguments has wrong size');
    if ((xlen(xc)<>xlen(yc))) or ((xlen(xc)<>xlen(dc))) then
    raise Exception.Create('Error while calling spline1dfithermitewc: looks like one of arguments has wrong size');

    n := xlen(x);
    k := xlen(xc);

    _core_spline1dfithermitewc(x, y, w, n, xc, yc, dc, k, m, info, s, rep, _xparams);

end;


procedure _core_spline1dfitcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_s : Pointer;
    _d_rep: x_spline1dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_s := nil;
        s := nil;
        x_spline1dfitreport_init(_d_rep);
        _error_code := x_xv2_spline1dfitcubic(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m, @_d_info, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dfitcubic call');
        end;
        info := _d_info;
        s := Tspline1dinterpolant.Create(_d_s);
        x_spline1dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline1dfitreport_clear(_d_rep);
    end;
end;


procedure spline1dfitcubic( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dfitcubic(x, y, n, m, info, s, rep, _xparams);
end;


procedure spline1dfitcubic( x: TVector;  y: TVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dfitcubic: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dfitcubic(x, y, n, m, info, s, rep, _xparams);

end;


procedure _core_spline1dfithermite( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_s : Pointer;
    _d_rep: x_spline1dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_s := nil;
        s := nil;
        x_spline1dfitreport_init(_d_rep);
        _error_code := x_xv2_spline1dfithermite(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m, @_d_info, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dfithermite call');
        end;
        info := _d_info;
        s := Tspline1dinterpolant.Create(_d_s);
        x_spline1dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline1dfitreport_clear(_d_rep);
    end;
end;


procedure spline1dfithermite( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dfithermite(x, y, n, m, info, s, rep, _xparams);
end;


procedure spline1dfithermite( x: TVector;  y: TVector;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dfithermite: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dfithermite(x, y, n, m, info, s, rep, _xparams);

end;


procedure _core_lsfitlinearw( y: TVector;  w: TVector;  fmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_fmatrix: x_matrix;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_c: x_vector;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        x_from_array(_d_fmatrix, fmatrix, X_CREATE);
        _d_n := n;
        _d_m := m;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_lsfitlinearw(@_s_error_msg, @_d_y, @_d_w, @_d_fmatrix, @_d_n, @_d_m, @_d_info, @_d_c, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitlinearw call');
        end;
        info := _d_info;
        x_to_array(_d_c, c);
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_fmatrix);
        x_clear(_d_c);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure lsfitlinearw( y: TVector;  w: TVector;  fmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitlinearw(y, w, fmatrix, n, m, info, c, rep, _xparams);
end;


procedure lsfitlinearw( y: TVector;  w: TVector;  fmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;

begin
    if ((xlen(y)<>xlen(w))) or ((xlen(y)<>xrows(fmatrix))) then
    raise Exception.Create('Error while calling lsfitlinearw: looks like one of arguments has wrong size');

    n := xlen(y);
    m := xcols(fmatrix);

    _core_lsfitlinearw(y, w, fmatrix, n, m, info, c, rep, _xparams);

end;


procedure _core_lsfitlinearwc( y: TVector;  w: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_fmatrix: x_matrix;
    _d_cmatrix: x_matrix;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_info: NativeInt;
    _d_c: x_vector;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        x_from_array(_d_fmatrix, fmatrix, X_CREATE);
        x_from_array(_d_cmatrix, cmatrix, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_lsfitlinearwc(@_s_error_msg, @_d_y, @_d_w, @_d_fmatrix, @_d_cmatrix, @_d_n, @_d_m, @_d_k, @_d_info, @_d_c, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitlinearwc call');
        end;
        info := _d_info;
        x_to_array(_d_c, c);
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_fmatrix);
        x_clear(_d_cmatrix);
        x_clear(_d_c);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure lsfitlinearwc( y: TVector;  w: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, info, c, rep, _xparams);
end;


procedure lsfitlinearwc( y: TVector;  w: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xlen(y)<>xlen(w))) or ((xlen(y)<>xrows(fmatrix))) then
    raise Exception.Create('Error while calling lsfitlinearwc: looks like one of arguments has wrong size');
    if ((xcols(fmatrix)<>xcols(cmatrix)-1)) then
    raise Exception.Create('Error while calling lsfitlinearwc: looks like one of arguments has wrong size');

    n := xlen(y);
    m := xcols(fmatrix);
    k := xrows(cmatrix);

    _core_lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, info, c, rep, _xparams);

end;


procedure _core_lsfitlinear( y: TVector;  fmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_y: x_vector;
    _d_fmatrix: x_matrix;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_info: NativeInt;
    _d_c: x_vector;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_fmatrix, fmatrix, X_CREATE);
        _d_n := n;
        _d_m := m;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_lsfitlinear(@_s_error_msg, @_d_y, @_d_fmatrix, @_d_n, @_d_m, @_d_info, @_d_c, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitlinear call');
        end;
        info := _d_info;
        x_to_array(_d_c, c);
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        x_clear(_d_fmatrix);
        x_clear(_d_c);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure lsfitlinear( y: TVector;  fmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitlinear(y, fmatrix, n, m, info, c, rep, _xparams);
end;


procedure lsfitlinear( y: TVector;  fmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;

begin
    if ((xlen(y)<>xrows(fmatrix))) then
    raise Exception.Create('Error while calling lsfitlinear: looks like one of arguments has wrong size');

    n := xlen(y);
    m := xcols(fmatrix);

    _core_lsfitlinear(y, fmatrix, n, m, info, c, rep, _xparams);

end;


procedure _core_lsfitlinearc( y: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_y: x_vector;
    _d_fmatrix: x_matrix;
    _d_cmatrix: x_matrix;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_info: NativeInt;
    _d_c: x_vector;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_fmatrix, fmatrix, X_CREATE);
        x_from_array(_d_cmatrix, cmatrix, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_lsfitlinearc(@_s_error_msg, @_d_y, @_d_fmatrix, @_d_cmatrix, @_d_n, @_d_m, @_d_k, @_d_info, @_d_c, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitlinearc call');
        end;
        info := _d_info;
        x_to_array(_d_c, c);
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_y);
        x_clear(_d_fmatrix);
        x_clear(_d_cmatrix);
        x_clear(_d_c);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure lsfitlinearc( y: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitlinearc(y, fmatrix, cmatrix, n, m, k, info, c, rep, _xparams);
end;


procedure lsfitlinearc( y: TVector;  fmatrix: TMatrix;  cmatrix: TMatrix; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xlen(y)<>xrows(fmatrix))) then
    raise Exception.Create('Error while calling lsfitlinearc: looks like one of arguments has wrong size');
    if ((xcols(fmatrix)<>xcols(cmatrix)-1)) then
    raise Exception.Create('Error while calling lsfitlinearc: looks like one of arguments has wrong size');

    n := xlen(y);
    m := xcols(fmatrix);
    k := xrows(cmatrix);

    _core_lsfitlinearc(y, fmatrix, cmatrix, n, m, k, info, c, rep, _xparams);

end;


procedure _core_lsfitcreatewf( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  diffstep: Double; out  state: Tlsfitstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_lsfitcreatewf(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_c, @_d_n, @_d_m, @_d_k, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitcreatewf call');
        end;
        state := Tlsfitstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_c);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lsfitcreatewf( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitcreatewf(x, y, w, c, n, m, k, diffstep, state, _xparams);
end;


procedure lsfitcreatewf( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xrows(x)<>xlen(y))) or ((xrows(x)<>xlen(w))) then
    raise Exception.Create('Error while calling lsfitcreatewf: looks like one of arguments has wrong size');

    n := xrows(x);
    m := xcols(x);
    k := xlen(c);

    _core_lsfitcreatewf(x, y, w, c, n, m, k, diffstep, state, _xparams);

end;


procedure _core_lsfitcreatef( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  diffstep: Double; out  state: Tlsfitstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_vector;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_diffstep: Double;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        _d_diffstep := diffstep;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_lsfitcreatef(@_s_error_msg, @_d_x, @_d_y, @_d_c, @_d_n, @_d_m, @_d_k, @_d_diffstep, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitcreatef call');
        end;
        state := Tlsfitstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_c);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lsfitcreatef( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitcreatef(x, y, c, n, m, k, diffstep, state, _xparams);
end;


procedure lsfitcreatef( x: TMatrix;  y: TVector;  c: TVector;  diffstep: Double; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xrows(x)<>xlen(y))) then
    raise Exception.Create('Error while calling lsfitcreatef: looks like one of arguments has wrong size');

    n := xrows(x);
    m := xcols(x);
    k := xlen(c);

    _core_lsfitcreatef(x, y, c, n, m, k, diffstep, state, _xparams);

end;


procedure _core_lsfitcreatewfg( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  cheapfg: Boolean; out  state: Tlsfitstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_cheapfg: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        _d_cheapfg := Bool2Byte(cheapfg);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_lsfitcreatewfg(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_c, @_d_n, @_d_m, @_d_k, @_d_cheapfg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitcreatewfg call');
        end;
        state := Tlsfitstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_c);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lsfitcreatewfg( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitcreatewfg(x, y, w, c, n, m, k, cheapfg, state, _xparams);
end;


procedure lsfitcreatewfg( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xrows(x)<>xlen(y))) or ((xrows(x)<>xlen(w))) then
    raise Exception.Create('Error while calling lsfitcreatewfg: looks like one of arguments has wrong size');

    n := xrows(x);
    m := xcols(x);
    k := xlen(c);

    _core_lsfitcreatewfg(x, y, w, c, n, m, k, cheapfg, state, _xparams);

end;


procedure _core_lsfitcreatefg( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  cheapfg: Boolean; out  state: Tlsfitstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_vector;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_cheapfg: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        _d_cheapfg := Bool2Byte(cheapfg);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_lsfitcreatefg(@_s_error_msg, @_d_x, @_d_y, @_d_c, @_d_n, @_d_m, @_d_k, @_d_cheapfg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitcreatefg call');
        end;
        state := Tlsfitstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_c);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lsfitcreatefg( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitcreatefg(x, y, c, n, m, k, cheapfg, state, _xparams);
end;


procedure lsfitcreatefg( x: TMatrix;  y: TVector;  c: TVector;  cheapfg: Boolean; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xrows(x)<>xlen(y))) then
    raise Exception.Create('Error while calling lsfitcreatefg: looks like one of arguments has wrong size');

    n := xrows(x);
    m := xcols(x);
    k := xlen(c);

    _core_lsfitcreatefg(x, y, c, n, m, k, cheapfg, state, _xparams);

end;


procedure _core_lsfitcreatewfgh( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  state: Tlsfitstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_lsfitcreatewfgh(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_c, @_d_n, @_d_m, @_d_k, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitcreatewfgh call');
        end;
        state := Tlsfitstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        x_clear(_d_c);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lsfitcreatewfgh( x: TMatrix;  y: TVector;  w: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitcreatewfgh(x, y, w, c, n, m, k, state, _xparams);
end;


procedure lsfitcreatewfgh( x: TMatrix;  y: TVector;  w: TVector;  c: TVector; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xrows(x)<>xlen(y))) or ((xrows(x)<>xlen(w))) then
    raise Exception.Create('Error while calling lsfitcreatewfgh: looks like one of arguments has wrong size');

    n := xrows(x);
    m := xcols(x);
    k := xlen(c);

    _core_lsfitcreatewfgh(x, y, w, c, n, m, k, state, _xparams);

end;


procedure _core_lsfitcreatefgh( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  state: Tlsfitstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_matrix;
    _d_y: x_vector;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_k: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_k := k;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_lsfitcreatefgh(@_s_error_msg, @_d_x, @_d_y, @_d_c, @_d_n, @_d_m, @_d_k, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitcreatefgh call');
        end;
        state := Tlsfitstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_c);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lsfitcreatefgh( x: TMatrix;  y: TVector;  c: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  k: TALGLIBInteger; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitcreatefgh(x, y, c, n, m, k, state, _xparams);
end;


procedure lsfitcreatefgh( x: TMatrix;  y: TVector;  c: TVector; out  state: Tlsfitstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;
    m: TALGLIBInteger;
    k: TALGLIBInteger;

begin
    if ((xrows(x)<>xlen(y))) then
    raise Exception.Create('Error while calling lsfitcreatefgh: looks like one of arguments has wrong size');

    n := xrows(x);
    m := xcols(x);
    k := xlen(c);

    _core_lsfitcreatefgh(x, y, c, n, m, k, state, _xparams);

end;


procedure _core_lsfitsetcond( state: Tlsfitstate;  epsx: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsx: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsx := epsx;
        _d_maxits := maxits;
        _error_code := x_xv2_lsfitsetcond(@_s_error_msg, @_d_state, @_d_epsx, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lsfitsetcond( state: Tlsfitstate;  epsx: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_lsfitsetcond(state, epsx, maxits, _xparams);
end;


procedure _core_lsfitsetstpmax( state: Tlsfitstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_lsfitsetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitsetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lsfitsetstpmax( state: Tlsfitstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_lsfitsetstpmax(state, stpmax, _xparams);
end;


procedure _core_lsfitsetxrep( state: Tlsfitstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_lsfitsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lsfitsetxrep( state: Tlsfitstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_lsfitsetxrep(state, needxrep, _xparams);
end;


procedure _core_lsfitsetscale( state: Tlsfitstate;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_lsfitsetscale(@_s_error_msg, @_d_state, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitsetscale call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_s);
    end;
end;


procedure lsfitsetscale( state: Tlsfitstate;  s: TVector; const _xparams: UInt64 = 0);
begin
    _core_lsfitsetscale(state, s, _xparams);
end;


procedure _core_lsfitsetbc( state: Tlsfitstate;  bndl: TVector;  bndu: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_bndl: x_vector;
    _d_bndu: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_bndl, bndl, X_CREATE);
        x_from_array(_d_bndu, bndu, X_CREATE);
        _error_code := x_xv2_lsfitsetbc(@_s_error_msg, @_d_state, @_d_bndl, @_d_bndu, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitsetbc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_bndl);
        x_clear(_d_bndu);
    end;
end;


procedure lsfitsetbc( state: Tlsfitstate;  bndl: TVector;  bndu: TVector; const _xparams: UInt64 = 0);
begin
    _core_lsfitsetbc(state, bndl, bndu, _xparams);
end;


procedure _core_lsfitsetlc( state: Tlsfitstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_c: x_matrix;
    _d_ct: x_vector;
    _d_k: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_c, c, X_CREATE);
        x_from_array(_d_ct, ct, X_CREATE);
        _d_k := k;
        _error_code := x_xv2_lsfitsetlc(@_s_error_msg, @_d_state, @_d_c, @_d_ct, @_d_k, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitsetlc call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_clear(_d_ct);
    end;
end;


procedure lsfitsetlc( state: Tlsfitstate;  c: TMatrix;  ct: TIVector;  k: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_lsfitsetlc(state, c, ct, k, _xparams);
end;


procedure lsfitsetlc( state: Tlsfitstate;  c: TMatrix;  ct: TIVector; const _xparams: UInt64 = 0);overload;
var
    k: TALGLIBInteger;

begin
    if ((xrows(c)<>xlen(ct))) then
    raise Exception.Create('Error while calling lsfitsetlc: looks like one of arguments has wrong size');

    k := xrows(c);

    _core_lsfitsetlc(state, c, ct, k, _xparams);

end;


function _core_lsfititeration( state: Tlsfitstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_lsfititeration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfititeration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function lsfititeration( state: Tlsfitstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_lsfititeration(state, _xparams);
end;

procedure lsfitfit(state: Tlsfitstate; func: Tndimensional_pfunc; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_par: x_vector;
    _pas_par: TVector;
    _pas_f: Double;
    _xc_needf: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in lsfitfit() (func is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_par, DT_REAL);
    x_lsfitstate_get_c(_state, @_xc_arg);
    x_lsfitstate_get_x(_state, @_xc_par);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_par, _xc_par.cnt);
    _pas_f:=0;

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_lsfititeration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfititeration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_lsfitstate_get_xupdated(_state, @_xc_xupdated);
        x_lsfitstate_get_needf(_state, @_xc_needf);
        x_to_array(_xc_arg, _pas_arg);
        x_to_array(_xc_par, _pas_par);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_par, _pas_f, obj);
            x_lsfitstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_lsfitstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in lsfitfit (some derivatives were not provided?)');
    end;
end;
procedure lsfitfit(state: Tlsfitstate; func: Tndimensional_pfunc; grad: Tndimensional_pgrad; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_par: x_vector;
    _pas_par: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_needf: Byte;
    _xc_needfg: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in lsfitfit() (func is nil)');
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in lsfitfit() (grad is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_par, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_lsfitstate_get_c(_state, @_xc_arg);
    x_lsfitstate_get_x(_state, @_xc_par);
    x_lsfitstate_get_g(_state, @_xc_g);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_par, _xc_par.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_lsfititeration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfititeration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_lsfitstate_get_xupdated(_state, @_xc_xupdated);
        x_lsfitstate_get_needf(_state, @_xc_needf);
        x_lsfitstate_get_needfg(_state, @_xc_needfg);
        x_to_array(_xc_arg, _pas_arg);
        x_to_array(_xc_par, _pas_par);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_par, _pas_f, obj);
            x_lsfitstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_par, _pas_f, _pas_g, obj);
            x_lsfitstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_lsfitstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in lsfitfit (some derivatives were not provided?)');
    end;
end;
procedure lsfitfit(state: Tlsfitstate; func: Tndimensional_pfunc; grad: Tndimensional_pgrad; hess: Tndimensional_phess; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _xc_par: x_vector;
    _pas_par: TVector;
    _pas_f: Double;
    _xc_g: x_vector;
    _pas_g: TVector;
    _xc_h: x_matrix;
    _pas_h: TMatrix;
    _xc_needf: Byte;
    _xc_needfg: Byte;
    _xc_needfgh: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in lsfitfit() (func is nil)');
    if @grad=nil then
        raise Exception.Create('ALGLIB: error in lsfitfit() (grad is nil)');
    if @hess=nil then
        raise Exception.Create('ALGLIB: error in lsfitfit() (hess is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_par, DT_REAL);
    x_create_empty(_xc_g, DT_REAL);
    x_create_empty(_xc_h, DT_REAL);
    x_lsfitstate_get_c(_state, @_xc_arg);
    x_lsfitstate_get_x(_state, @_xc_par);
    x_lsfitstate_get_g(_state, @_xc_g);
    x_lsfitstate_get_h(_state, @_xc_h);
    SetLength(_pas_arg, _xc_arg.cnt);
    SetLength(_pas_par, _xc_par.cnt);
    _pas_f:=0;
    SetLength(_pas_g, _xc_g.cnt);
    SetLength(_pas_h, _xc_h.rows, _xc_h.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_lsfititeration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfititeration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_lsfitstate_get_xupdated(_state, @_xc_xupdated);
        x_lsfitstate_get_needf(_state, @_xc_needf);
        x_lsfitstate_get_needfg(_state, @_xc_needfg);
        x_lsfitstate_get_needfgh(_state, @_xc_needfgh);
        x_to_array(_xc_arg, _pas_arg);
        x_to_array(_xc_par, _pas_par);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_par, _pas_f, obj);
            x_lsfitstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_needfg<>0 then
        begin
            grad(_pas_arg, _pas_par, _pas_f, _pas_g, obj);
            x_lsfitstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            Continue;
        end;
        if _xc_needfgh<>0 then
        begin
            hess(_pas_arg, _pas_par, _pas_f, _pas_g, _pas_h, obj);
            x_lsfitstate_set_f(_state, @_pas_f);
            x_from_array(_xc_g, _pas_g, X_REWRITE);
            x_from_array(_xc_h, _pas_h, X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_lsfitstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in lsfitfit (some derivatives were not provided?)');
    end;
end;


procedure _core_lsfitresults( state: Tlsfitstate; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_info: NativeInt;
    _d_c: x_vector;
    _d_rep: x_lsfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        x_lsfitreport_init(_d_rep);
        _error_code := x_xv2_lsfitresults(@_s_error_msg, @_d_state, @_d_info, @_d_c, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        info := _d_info;
        x_to_array(_d_c, c);
        x_lsfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
        x_lsfitreport_clear(_d_rep);
    end;
end;


procedure lsfitresults( state: Tlsfitstate; out  info: TALGLIBInteger; out  c: TVector; out  rep: Tlsfitreport; const _xparams: UInt64 = 0);
begin
    _core_lsfitresults(state, info, c, rep, _xparams);
end;


procedure _core_lsfitsetgradientcheck( state: Tlsfitstate;  teststep: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_teststep: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_teststep := teststep;
        _error_code := x_xv2_lsfitsetgradientcheck(@_s_error_msg, @_d_state, @_d_teststep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lsfitsetgradientcheck call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lsfitsetgradientcheck( state: Tlsfitstate;  teststep: Double; const _xparams: UInt64 = 0);
begin
    _core_lsfitsetgradientcheck(state, teststep, _xparams);
end;

constructor Tspline2dinterpolant.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tspline2dinterpolant.Destroy();
begin
    Deallocate();
end;

function Tspline2dinterpolant.Clone():Tspline2dinterpolant;
begin
    if ptr=nil then
        Result:=Tspline2dinterpolant.Create(nil)
    else
        Result:=Tspline2dinterpolant.Create(x_obj_copy_spline2dinterpolant(ptr));
end;

procedure Tspline2dinterpolant.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_spline2dinterpolant(ptr);
    ptr:=nil;
end;

constructor Tspline2dbuilder.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tspline2dbuilder.Destroy();
begin
    Deallocate();
end;

function Tspline2dbuilder.Clone():Tspline2dbuilder;
begin
    if ptr=nil then
        Result:=Tspline2dbuilder.Create(nil)
    else
        Result:=Tspline2dbuilder.Create(x_obj_copy_spline2dbuilder(ptr));
end;

procedure Tspline2dbuilder.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_spline2dbuilder(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tspline2dfitreport):Tspline2dfitreport;overload;
begin
    Result.rmserror := src.rmserror;
    Result.avgerror := src.avgerror;
    Result.maxerror := src.maxerror;
    Result.r2 := src.r2;
end;

procedure x_spline2dfitreport_init(var x: x_spline2dfitreport);
begin
    x.rmserror := 0;
    x.avgerror := 0;
    x.maxerror := 0;
    x.r2 := 0;
end;

procedure x_spline2dfitreport_clear(var x: x_spline2dfitreport);
begin
end;

procedure x_spline2dfitreport_init_from(var x: x_spline2dfitreport; const v: Tspline2dfitreport);
begin
    x.rmserror := v.rmserror;
    x.avgerror := v.avgerror;
    x.maxerror := v.maxerror;
    x.r2 := v.r2;
end;

procedure x_spline2dfitreport_to_record(const x: x_spline2dfitreport; var v: Tspline2dfitreport);
begin
    v.rmserror := x.rmserror;
    v.avgerror := x.avgerror;
    v.maxerror := x.maxerror;
    v.r2 := x.r2;
end;

procedure spline2dserialize(const obj: Tspline2dinterpolant; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_spline2dserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure spline2dunserialize(const s_in: AnsiString; out obj: Tspline2dinterpolant);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_spline2dunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dunserialize() call');
        end;
        obj:=Tspline2dinterpolant.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_spline2dinterpolant(_x);
    end;
end;

procedure spline2dserialize(const obj: Tspline2dinterpolant; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_spline2dserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during spline2dserialize_stream() call');
    end;
end;

procedure spline2dunserialize(stream: TStream; out obj: Tspline2dinterpolant);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_spline2dunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dunserialize_stream() call');
        end;
        obj:=Tspline2dinterpolant.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_spline2dinterpolant(_x);
    end;
end;


function _core_spline2dcalc( c: Tspline2dinterpolant;  x: Double;  y: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        _error_code := x_xv2_spline2dcalc(@_s_error_msg, @_d_result, @_d_c, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dcalc call');
        end;
        result := _d_result;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function spline2dcalc( c: Tspline2dinterpolant;  x: Double;  y: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spline2dcalc(c, x, y, _xparams);
end;


procedure _core_spline2ddiff( c: Tspline2dinterpolant;  x: Double;  y: Double; out  f: Double; out  fx: Double; out  fy: Double; out  fxy: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_f: Double;
    _d_fx: Double;
    _d_fy: Double;
    _d_fxy: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        _error_code := x_xv2_spline2ddiff(@_s_error_msg, @_d_c, @_d_x, @_d_y, @_d_f, @_d_fx, @_d_fy, @_d_fxy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2ddiff call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        f := _d_f;
        fx := _d_fx;
        fy := _d_fy;
        fxy := _d_fxy;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2ddiff( c: Tspline2dinterpolant;  x: Double;  y: Double; out  f: Double; out  fx: Double; out  fy: Double; out  fxy: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2ddiff(c, x, y, f, fx, fy, fxy, _xparams);
end;


procedure _core_spline2dcalcvbuf( c: Tspline2dinterpolant;  x: Double;  y: Double; var  f: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_f: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        x_from_array(_d_f, f, X_CREATE);
        _error_code := x_xv2_spline2dcalcvbuf(@_s_error_msg, @_d_c, @_d_x, @_d_y, @_d_f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dcalcvbuf call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_f, f);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
    end;
end;


procedure spline2dcalcvbuf( c: Tspline2dinterpolant;  x: Double;  y: Double; var  f: TVector; const _xparams: UInt64 = 0);
begin
    _core_spline2dcalcvbuf(c, x, y, f, _xparams);
end;


function _core_spline2dcalcvi( c: Tspline2dinterpolant;  x: Double;  y: Double;  i: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_i: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        _d_i := i;
        _error_code := x_xv2_spline2dcalcvi(@_s_error_msg, @_d_result, @_d_c, @_d_x, @_d_y, @_d_i, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dcalcvi call');
        end;
        result := _d_result;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function spline2dcalcvi( c: Tspline2dinterpolant;  x: Double;  y: Double;  i: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_spline2dcalcvi(c, x, y, i, _xparams);
end;


procedure _core_spline2dcalcv( c: Tspline2dinterpolant;  x: Double;  y: Double; out  f: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_f: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        x_create_empty(_d_f, DT_REAL);
        f := nil;
        _error_code := x_xv2_spline2dcalcv(@_s_error_msg, @_d_c, @_d_x, @_d_y, @_d_f, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dcalcv call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_f, f);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_f);
    end;
end;


procedure spline2dcalcv( c: Tspline2dinterpolant;  x: Double;  y: Double; out  f: TVector; const _xparams: UInt64 = 0);
begin
    _core_spline2dcalcv(c, x, y, f, _xparams);
end;


procedure _core_spline2ddiffvi( c: Tspline2dinterpolant;  x: Double;  y: Double;  i: TALGLIBInteger; out  f: Double; out  fx: Double; out  fy: Double; out  fxy: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_x: Double;
    _d_y: Double;
    _d_i: NativeInt;
    _d_f: Double;
    _d_fx: Double;
    _d_fy: Double;
    _d_fxy: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_x := x;
        _d_y := y;
        _d_i := i;
        _error_code := x_xv2_spline2ddiffvi(@_s_error_msg, @_d_c, @_d_x, @_d_y, @_d_i, @_d_f, @_d_fx, @_d_fy, @_d_fxy, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2ddiffvi call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        f := _d_f;
        fx := _d_fx;
        fy := _d_fy;
        fxy := _d_fxy;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2ddiffvi( c: Tspline2dinterpolant;  x: Double;  y: Double;  i: TALGLIBInteger; out  f: Double; out  fx: Double; out  fy: Double; out  fxy: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2ddiffvi(c, x, y, i, f, fx, fy, fxy, _xparams);
end;


procedure _core_spline2dlintransxy( c: Tspline2dinterpolant;  ax: Double;  bx: Double;  ay: Double;  by: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_ax: Double;
    _d_bx: Double;
    _d_ay: Double;
    _d_by: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_ax := ax;
        _d_bx := bx;
        _d_ay := ay;
        _d_by := by;
        _error_code := x_xv2_spline2dlintransxy(@_s_error_msg, @_d_c, @_d_ax, @_d_bx, @_d_ay, @_d_by, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dlintransxy call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dlintransxy( c: Tspline2dinterpolant;  ax: Double;  bx: Double;  ay: Double;  by: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2dlintransxy(c, ax, bx, ay, by, _xparams);
end;


procedure _core_spline2dlintransf( c: Tspline2dinterpolant;  a: Double;  b: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_a: Double;
    _d_b: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_a := a;
        _d_b := b;
        _error_code := x_xv2_spline2dlintransf(@_s_error_msg, @_d_c, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dlintransf call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dlintransf( c: Tspline2dinterpolant;  a: Double;  b: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2dlintransf(c, a, b, _xparams);
end;


procedure _core_spline2dcopy( c: Tspline2dinterpolant; out  cc: Tspline2dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_cc : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        _d_cc := nil;
        cc := nil;
        _error_code := x_xv2_spline2dcopy(@_s_error_msg, @_d_c, @_d_cc, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dcopy call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        cc := Tspline2dinterpolant.Create(_d_cc);
    finally
        SetXExceptionMask(fpumask);
        if (_d_cc<>nil) and (cc=nil) then
            x_obj_free_spline2dinterpolant(_d_cc); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline2dcopy( c: Tspline2dinterpolant; out  cc: Tspline2dinterpolant; const _xparams: UInt64 = 0);
begin
    _core_spline2dcopy(c, cc, _xparams);
end;


procedure _core_spline2dresamplebicubic( a: TMatrix;  oldheight: TALGLIBInteger;  oldwidth: TALGLIBInteger; out  b: TMatrix;  newheight: TALGLIBInteger;  newwidth: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_oldheight: NativeInt;
    _d_oldwidth: NativeInt;
    _d_b: x_matrix;
    _d_newheight: NativeInt;
    _d_newwidth: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_oldheight := oldheight;
        _d_oldwidth := oldwidth;
        x_create_empty(_d_b, DT_REAL);
        b := nil;
        _d_newheight := newheight;
        _d_newwidth := newwidth;
        _error_code := x_xv2_spline2dresamplebicubic(@_s_error_msg, @_d_a, @_d_oldheight, @_d_oldwidth, @_d_b, @_d_newheight, @_d_newwidth, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dresamplebicubic call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure spline2dresamplebicubic( a: TMatrix;  oldheight: TALGLIBInteger;  oldwidth: TALGLIBInteger; out  b: TMatrix;  newheight: TALGLIBInteger;  newwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spline2dresamplebicubic(a, oldheight, oldwidth, b, newheight, newwidth, _xparams);
end;


procedure _core_spline2dresamplebilinear( a: TMatrix;  oldheight: TALGLIBInteger;  oldwidth: TALGLIBInteger; out  b: TMatrix;  newheight: TALGLIBInteger;  newwidth: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_matrix;
    _d_oldheight: NativeInt;
    _d_oldwidth: NativeInt;
    _d_b: x_matrix;
    _d_newheight: NativeInt;
    _d_newwidth: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_oldheight := oldheight;
        _d_oldwidth := oldwidth;
        x_create_empty(_d_b, DT_REAL);
        b := nil;
        _d_newheight := newheight;
        _d_newwidth := newwidth;
        _error_code := x_xv2_spline2dresamplebilinear(@_s_error_msg, @_d_a, @_d_oldheight, @_d_oldwidth, @_d_b, @_d_newheight, @_d_newwidth, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dresamplebilinear call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure spline2dresamplebilinear( a: TMatrix;  oldheight: TALGLIBInteger;  oldwidth: TALGLIBInteger; out  b: TMatrix;  newheight: TALGLIBInteger;  newwidth: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spline2dresamplebilinear(a, oldheight, oldwidth, b, newheight, newwidth, _xparams);
end;


procedure _core_spline2dbuildbilinearv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline2dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_y: x_vector;
    _d_m: NativeInt;
    _d_f: x_vector;
    _d_d: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        x_from_array(_d_y, y, X_CREATE);
        _d_m := m;
        x_from_array(_d_f, f, X_CREATE);
        _d_d := d;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline2dbuildbilinearv(@_s_error_msg, @_d_x, @_d_n, @_d_y, @_d_m, @_d_f, @_d_d, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildbilinearv call');
        end;
        c := Tspline2dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_f);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline2dbuildbilinearv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildbilinearv(x, n, y, m, f, d, c, _xparams);
end;


procedure _core_spline2dbuildbicubicv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline2dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_y: x_vector;
    _d_m: NativeInt;
    _d_f: x_vector;
    _d_d: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        x_from_array(_d_y, y, X_CREATE);
        _d_m := m;
        x_from_array(_d_f, f, X_CREATE);
        _d_d := d;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline2dbuildbicubicv(@_s_error_msg, @_d_x, @_d_n, @_d_y, @_d_m, @_d_f, @_d_d, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildbicubicv call');
        end;
        c := Tspline2dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_f);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline2dbuildbicubicv( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger;  f: TVector;  d: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildbicubicv(x, n, y, m, f, d, c, _xparams);
end;


procedure _core_spline2dunpackv( c: Tspline2dinterpolant; out  m: TALGLIBInteger; out  n: TALGLIBInteger; out  d: TALGLIBInteger; out  tbl: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_d: NativeInt;
    _d_tbl: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        x_create_empty(_d_tbl, DT_REAL);
        tbl := nil;
        _error_code := x_xv2_spline2dunpackv(@_s_error_msg, @_d_c, @_d_m, @_d_n, @_d_d, @_d_tbl, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dunpackv call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        m := _d_m;
        n := _d_n;
        d := _d_d;
        x_to_array(_d_tbl, tbl);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_tbl);
    end;
end;


procedure spline2dunpackv( c: Tspline2dinterpolant; out  m: TALGLIBInteger; out  n: TALGLIBInteger; out  d: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_spline2dunpackv(c, m, n, d, tbl, _xparams);
end;


procedure _core_spline2dbuildbilinear( x: TVector;  y: TVector;  f: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  c: Tspline2dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_f: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_f, f, X_CREATE);
        _d_m := m;
        _d_n := n;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline2dbuildbilinear(@_s_error_msg, @_d_x, @_d_y, @_d_f, @_d_m, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildbilinear call');
        end;
        c := Tspline2dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_f);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline2dbuildbilinear( x: TVector;  y: TVector;  f: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildbilinear(x, y, f, m, n, c, _xparams);
end;


procedure _core_spline2dbuildbicubic( x: TVector;  y: TVector;  f: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  c: Tspline2dinterpolant; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_f: x_matrix;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_c : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_f, f, X_CREATE);
        _d_m := m;
        _d_n := n;
        _d_c := nil;
        c := nil;
        _error_code := x_xv2_spline2dbuildbicubic(@_s_error_msg, @_d_x, @_d_y, @_d_f, @_d_m, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildbicubic call');
        end;
        c := Tspline2dinterpolant.Create(_d_c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_f);
        if (_d_c<>nil) and (c=nil) then
            x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline2dbuildbicubic( x: TVector;  y: TVector;  f: TMatrix;  m: TALGLIBInteger;  n: TALGLIBInteger; out  c: Tspline2dinterpolant; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildbicubic(x, y, f, m, n, c, _xparams);
end;


procedure _core_spline2dunpack( c: Tspline2dinterpolant; out  m: TALGLIBInteger; out  n: TALGLIBInteger; out  tbl: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_c : Pointer;
    _d_m: NativeInt;
    _d_n: NativeInt;
    _d_tbl: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_c := c.ptr;
        x_create_empty(_d_tbl, DT_REAL);
        tbl := nil;
        _error_code := x_xv2_spline2dunpack(@_s_error_msg, @_d_c, @_d_m, @_d_n, @_d_tbl, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dunpack call');
        end;
        Assert(c.ptr=_d_c, 'ALGLIB: internal error (reference changed for non-out X-object)');
        m := _d_m;
        n := _d_n;
        x_to_array(_d_tbl, tbl);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_tbl);
    end;
end;


procedure spline2dunpack( c: Tspline2dinterpolant; out  m: TALGLIBInteger; out  n: TALGLIBInteger; out  tbl: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_spline2dunpack(c, m, n, tbl, _xparams);
end;


procedure _core_spline2dbuildercreate( d: TALGLIBInteger; out  state: Tspline2dbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_d: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_d := d;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_spline2dbuildercreate(@_s_error_msg, @_d_d, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildercreate call');
        end;
        state := Tspline2dbuilder.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_spline2dbuilder(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure spline2dbuildercreate( d: TALGLIBInteger; out  state: Tspline2dbuilder; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildercreate(d, state, _xparams);
end;


procedure _core_spline2dbuildersetuserterm( state: Tspline2dbuilder;  v: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_v: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_v := v;
        _error_code := x_xv2_spline2dbuildersetuserterm(@_s_error_msg, @_d_state, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetuserterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetuserterm( state: Tspline2dbuilder;  v: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetuserterm(state, v, _xparams);
end;


procedure _core_spline2dbuildersetlinterm( state: Tspline2dbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_spline2dbuildersetlinterm(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetlinterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetlinterm( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetlinterm(state, _xparams);
end;


procedure _core_spline2dbuildersetconstterm( state: Tspline2dbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_spline2dbuildersetconstterm(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetconstterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetconstterm( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetconstterm(state, _xparams);
end;


procedure _core_spline2dbuildersetzeroterm( state: Tspline2dbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_spline2dbuildersetzeroterm(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetzeroterm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetzeroterm( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetzeroterm(state, _xparams);
end;


procedure _core_spline2dbuildersetpoints( state: Tspline2dbuilder;  xy: TMatrix;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_xy: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_spline2dbuildersetpoints(@_s_error_msg, @_d_state, @_d_xy, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetpoints call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure spline2dbuildersetpoints( state: Tspline2dbuilder;  xy: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetpoints(state, xy, n, _xparams);
end;


procedure _core_spline2dbuildersetareaauto( state: Tspline2dbuilder; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_spline2dbuildersetareaauto(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetareaauto call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetareaauto( state: Tspline2dbuilder; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetareaauto(state, _xparams);
end;


procedure _core_spline2dbuildersetarea( state: Tspline2dbuilder;  xa: Double;  xb: Double;  ya: Double;  yb: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_xa: Double;
    _d_xb: Double;
    _d_ya: Double;
    _d_yb: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_xa := xa;
        _d_xb := xb;
        _d_ya := ya;
        _d_yb := yb;
        _error_code := x_xv2_spline2dbuildersetarea(@_s_error_msg, @_d_state, @_d_xa, @_d_xb, @_d_ya, @_d_yb, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetarea call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetarea( state: Tspline2dbuilder;  xa: Double;  xb: Double;  ya: Double;  yb: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetarea(state, xa, xb, ya, yb, _xparams);
end;


procedure _core_spline2dbuildersetgrid( state: Tspline2dbuilder;  kx: TALGLIBInteger;  ky: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_kx: NativeInt;
    _d_ky: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_kx := kx;
        _d_ky := ky;
        _error_code := x_xv2_spline2dbuildersetgrid(@_s_error_msg, @_d_state, @_d_kx, @_d_ky, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetgrid call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetgrid( state: Tspline2dbuilder;  kx: TALGLIBInteger;  ky: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetgrid(state, kx, ky, _xparams);
end;


procedure _core_spline2dbuildersetalgofastddm( state: Tspline2dbuilder;  nlayers: TALGLIBInteger;  lambdav: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_nlayers: NativeInt;
    _d_lambdav: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_nlayers := nlayers;
        _d_lambdav := lambdav;
        _error_code := x_xv2_spline2dbuildersetalgofastddm(@_s_error_msg, @_d_state, @_d_nlayers, @_d_lambdav, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetalgofastddm call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetalgofastddm( state: Tspline2dbuilder;  nlayers: TALGLIBInteger;  lambdav: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetalgofastddm(state, nlayers, lambdav, _xparams);
end;


procedure _core_spline2dbuildersetalgoblocklls( state: Tspline2dbuilder;  lambdans: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_lambdans: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_lambdans := lambdans;
        _error_code := x_xv2_spline2dbuildersetalgoblocklls(@_s_error_msg, @_d_state, @_d_lambdans, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetalgoblocklls call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetalgoblocklls( state: Tspline2dbuilder;  lambdans: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetalgoblocklls(state, lambdans, _xparams);
end;


procedure _core_spline2dbuildersetalgonaivells( state: Tspline2dbuilder;  lambdans: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_lambdans: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_lambdans := lambdans;
        _error_code := x_xv2_spline2dbuildersetalgonaivells(@_s_error_msg, @_d_state, @_d_lambdans, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dbuildersetalgonaivells call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spline2dbuildersetalgonaivells( state: Tspline2dbuilder;  lambdans: Double; const _xparams: UInt64 = 0);
begin
    _core_spline2dbuildersetalgonaivells(state, lambdans, _xparams);
end;


procedure _core_spline2dfit( state: Tspline2dbuilder; out  s: Tspline2dinterpolant; out  rep: Tspline2dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_s : Pointer;
    _d_rep: x_spline2dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_s := nil;
        s := nil;
        x_spline2dfitreport_init(_d_rep);
        _error_code := x_xv2_spline2dfit(@_s_error_msg, @_d_state, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline2dfit call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        s := Tspline2dinterpolant.Create(_d_s);
        x_spline2dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline2dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline2dfitreport_clear(_d_rep);
    end;
end;


procedure spline2dfit( state: Tspline2dbuilder; out  s: Tspline2dinterpolant; out  rep: Tspline2dfitreport; const _xparams: UInt64 = 0);
begin
    _core_spline2dfit(state, s, rep, _xparams);
end;

constructor Trbfcalcbuffer.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Trbfcalcbuffer.Destroy();
begin
    Deallocate();
end;

function Trbfcalcbuffer.Clone():Trbfcalcbuffer;
begin
    if ptr=nil then
        Result:=Trbfcalcbuffer.Create(nil)
    else
        Result:=Trbfcalcbuffer.Create(x_obj_copy_rbfcalcbuffer(ptr));
end;

procedure Trbfcalcbuffer.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_rbfcalcbuffer(ptr);
    ptr:=nil;
end;

constructor Trbfmodel.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Trbfmodel.Destroy();
begin
    Deallocate();
end;

function Trbfmodel.Clone():Trbfmodel;
begin
    if ptr=nil then
        Result:=Trbfmodel.Create(nil)
    else
        Result:=Trbfmodel.Create(x_obj_copy_rbfmodel(ptr));
end;

procedure Trbfmodel.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_rbfmodel(ptr);
    ptr:=nil;
end;

function Clone(const Src: Trbfreport):Trbfreport;overload;
begin
    Result.rmserror := src.rmserror;
    Result.maxerror := src.maxerror;
    Result.arows := src.arows;
    Result.acols := src.acols;
    Result.annz := src.annz;
    Result.iterationscount := src.iterationscount;
    Result.nmv := src.nmv;
    Result.terminationtype := src.terminationtype;
end;

procedure x_rbfreport_init(var x: x_rbfreport);
begin
    x.rmserror := 0;
    x.maxerror := 0;
    x.arows.longval := 0;
    x.acols.longval := 0;
    x.annz.longval := 0;
    x.iterationscount.longval := 0;
    x.nmv.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_rbfreport_clear(var x: x_rbfreport);
begin
end;

procedure x_rbfreport_init_from(var x: x_rbfreport; const v: Trbfreport);
begin
    x.rmserror := v.rmserror;
    x.maxerror := v.maxerror;
    x.arows.longval := v.arows;
    x.acols.longval := v.acols;
    x.annz.longval := v.annz;
    x.iterationscount.longval := v.iterationscount;
    x.nmv.longval := v.nmv;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_rbfreport_to_record(const x: x_rbfreport; var v: Trbfreport);
begin
    v.rmserror := x.rmserror;
    v.maxerror := x.maxerror;
    v.arows := x.arows.val; // long is silently truncated to TALGLIBInteger
    v.acols := x.acols.val; // long is silently truncated to TALGLIBInteger
    v.annz := x.annz.val; // long is silently truncated to TALGLIBInteger
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nmv := x.nmv.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;

procedure rbfserialize(const obj: Trbfmodel; out s_out: AnsiString);overload;
var
    _s_error_msg: PAnsiChar;
    _out: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _out:=nil;
    _x:=obj.ptr;
    try
        _error_code := x_rbfserialize(@_s_error_msg, @_x, @_out);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfserialize() call');
        end;
        s_out:=AnsiString(_out);
    finally
        x_free(_out);
    end;
end;

procedure rbfunserialize(const s_in: AnsiString; out obj: Trbfmodel);overload;
var
    _s_error_msg: PAnsiChar;
    _in: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _in:=PAnsiChar(s_in);
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_rbfunserialize(@_s_error_msg, @_in, @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfunserialize() call');
        end;
        obj:=Trbfmodel.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_rbfmodel(_x);
    end;
end;

procedure rbfserialize(const obj: Trbfmodel; stream: TStream);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=obj.ptr;
    _error_code := x_rbfserialize_stream(@_s_error_msg, @_x, NativeInt(@StreamWriterAdapter), NativeInt(Pointer(stream)));
    if _error_code<>X_OK then
    begin
        if _error_code=X_ASSERTION_FAILED then
            raise Exception.Create(string(_s_error_msg))
        else
            raise Exception.Create('ALGLIB: unknown error during rbfserialize_stream() call');
    end;
end;

procedure rbfunserialize(stream: TStream; out obj: Trbfmodel);overload;
var
    _s_error_msg: PAnsiChar;
    _x: Pointer;
    _error_code: Int32T;
begin
    _s_error_msg:=nil;
    _x:=nil;
    obj:=nil;
    try
        _error_code := x_rbfunserialize_stream(@_s_error_msg, NativeInt(@StreamReaderAdapter), NativeInt(Pointer(stream)), @_x);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfunserialize_stream() call');
        end;
        obj:=Trbfmodel.Create(_x);
    finally
        // on exception clean up X objects which were not attached to Delphi objects
        if (_x<>nil) and (obj=nil) then
            x_obj_free_rbfmodel(_x);
    end;
end;


procedure _core_rbfcreate( nx: TALGLIBInteger;  ny: TALGLIBInteger; out  s: Trbfmodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_nx: NativeInt;
    _d_ny: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nx := nx;
        _d_ny := ny;
        _d_s := nil;
        s := nil;
        _error_code := x_xv2_rbfcreate(@_s_error_msg, @_d_nx, @_d_ny, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfcreate call');
        end;
        s := Trbfmodel.Create(_d_s);
    finally
        SetXExceptionMask(fpumask);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_rbfmodel(_d_s); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure rbfcreate( nx: TALGLIBInteger;  ny: TALGLIBInteger; out  s: Trbfmodel; const _xparams: UInt64 = 0);
begin
    _core_rbfcreate(nx, ny, s, _xparams);
end;


procedure _core_rbfcreatecalcbuffer( s: Trbfmodel; out  buf: Trbfcalcbuffer; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_buf : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_buf := nil;
        buf := nil;
        _error_code := x_xv2_rbfcreatecalcbuffer(@_s_error_msg, @_d_s, @_d_buf, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfcreatecalcbuffer call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        buf := Trbfcalcbuffer.Create(_d_buf);
    finally
        SetXExceptionMask(fpumask);
        if (_d_buf<>nil) and (buf=nil) then
            x_obj_free_rbfcalcbuffer(_d_buf); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure rbfcreatecalcbuffer( s: Trbfmodel; out  buf: Trbfcalcbuffer; const _xparams: UInt64 = 0);
begin
    _core_rbfcreatecalcbuffer(s, buf, _xparams);
end;


procedure _core_rbfsetpoints( s: Trbfmodel;  xy: TMatrix;  n: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_xy: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_rbfsetpoints(@_s_error_msg, @_d_s, @_d_xy, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetpoints call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
    end;
end;


procedure rbfsetpoints( s: Trbfmodel;  xy: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
begin
    _core_rbfsetpoints(s, xy, n, _xparams);
end;


procedure rbfsetpoints( s: Trbfmodel;  xy: TMatrix; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xrows(xy);

    _core_rbfsetpoints(s, xy, n, _xparams);

end;


procedure _core_rbfsetpointsandscales( r: Trbfmodel;  xy: TMatrix;  n: TALGLIBInteger;  s: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_r : Pointer;
    _d_xy: x_matrix;
    _d_n: NativeInt;
    _d_s: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_r := r.ptr;
        x_from_array(_d_xy, xy, X_CREATE);
        _d_n := n;
        x_from_array(_d_s, s, X_CREATE);
        _error_code := x_xv2_rbfsetpointsandscales(@_s_error_msg, @_d_r, @_d_xy, @_d_n, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetpointsandscales call');
        end;
        Assert(r.ptr=_d_r, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_s);
    end;
end;


procedure rbfsetpointsandscales( r: Trbfmodel;  xy: TMatrix;  n: TALGLIBInteger;  s: TVector; const _xparams: UInt64 = 0);overload;
begin
    _core_rbfsetpointsandscales(r, xy, n, s, _xparams);
end;


procedure rbfsetpointsandscales( r: Trbfmodel;  xy: TMatrix;  s: TVector; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xrows(xy);

    _core_rbfsetpointsandscales(r, xy, n, s, _xparams);

end;


procedure _core_rbfsetalgoqnn( s: Trbfmodel;  q: Double;  z: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_q: Double;
    _d_z: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_q := q;
        _d_z := z;
        _error_code := x_xv2_rbfsetalgoqnn(@_s_error_msg, @_d_s, @_d_q, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetalgoqnn call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetalgoqnn( s: Trbfmodel;  q: Double;  z: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_rbfsetalgoqnn(s, q, z, _xparams);
end;


procedure rbfsetalgoqnn( s: Trbfmodel; const _xparams: UInt64 = 0);overload;
var
    q: Double;
    z: Double;

begin

    q := 1.0;
    z := 5.0;

    _core_rbfsetalgoqnn(s, q, z, _xparams);

end;


procedure _core_rbfsetalgomultilayer( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger;  lambdav: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_rbase: Double;
    _d_nlayers: NativeInt;
    _d_lambdav: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_rbase := rbase;
        _d_nlayers := nlayers;
        _d_lambdav := lambdav;
        _error_code := x_xv2_rbfsetalgomultilayer(@_s_error_msg, @_d_s, @_d_rbase, @_d_nlayers, @_d_lambdav, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetalgomultilayer call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetalgomultilayer( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger;  lambdav: Double; const _xparams: UInt64 = 0);overload;
begin
    _core_rbfsetalgomultilayer(s, rbase, nlayers, lambdav, _xparams);
end;


procedure rbfsetalgomultilayer( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger; const _xparams: UInt64 = 0);overload;
var
    lambdav: Double;

begin

    lambdav := 0.01;

    _core_rbfsetalgomultilayer(s, rbase, nlayers, lambdav, _xparams);

end;


procedure _core_rbfsetalgohierarchical( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger;  lambdans: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_rbase: Double;
    _d_nlayers: NativeInt;
    _d_lambdans: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_rbase := rbase;
        _d_nlayers := nlayers;
        _d_lambdans := lambdans;
        _error_code := x_xv2_rbfsetalgohierarchical(@_s_error_msg, @_d_s, @_d_rbase, @_d_nlayers, @_d_lambdans, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetalgohierarchical call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetalgohierarchical( s: Trbfmodel;  rbase: Double;  nlayers: TALGLIBInteger;  lambdans: Double; const _xparams: UInt64 = 0);
begin
    _core_rbfsetalgohierarchical(s, rbase, nlayers, lambdans, _xparams);
end;


procedure _core_rbfsetlinterm( s: Trbfmodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_rbfsetlinterm(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetlinterm call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetlinterm( s: Trbfmodel; const _xparams: UInt64 = 0);
begin
    _core_rbfsetlinterm(s, _xparams);
end;


procedure _core_rbfsetconstterm( s: Trbfmodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_rbfsetconstterm(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetconstterm call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetconstterm( s: Trbfmodel; const _xparams: UInt64 = 0);
begin
    _core_rbfsetconstterm(s, _xparams);
end;


procedure _core_rbfsetzeroterm( s: Trbfmodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_rbfsetzeroterm(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetzeroterm call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetzeroterm( s: Trbfmodel; const _xparams: UInt64 = 0);
begin
    _core_rbfsetzeroterm(s, _xparams);
end;


procedure _core_rbfsetv2bf( s: Trbfmodel;  bf: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_bf: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_bf := bf;
        _error_code := x_xv2_rbfsetv2bf(@_s_error_msg, @_d_s, @_d_bf, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetv2bf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetv2bf( s: Trbfmodel;  bf: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rbfsetv2bf(s, bf, _xparams);
end;


procedure _core_rbfsetv2its( s: Trbfmodel;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_maxits := maxits;
        _error_code := x_xv2_rbfsetv2its(@_s_error_msg, @_d_s, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetv2its call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetv2its( s: Trbfmodel;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rbfsetv2its(s, maxits, _xparams);
end;


procedure _core_rbfsetv2supportr( s: Trbfmodel;  r: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_r: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_r := r;
        _error_code := x_xv2_rbfsetv2supportr(@_s_error_msg, @_d_s, @_d_r, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfsetv2supportr call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfsetv2supportr( s: Trbfmodel;  r: Double; const _xparams: UInt64 = 0);
begin
    _core_rbfsetv2supportr(s, r, _xparams);
end;


procedure _core_rbfbuildmodel( s: Trbfmodel; out  rep: Trbfreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_rep: x_rbfreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_rbfreport_init(_d_rep);
        _error_code := x_xv2_rbfbuildmodel(@_s_error_msg, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfbuildmodel call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_rbfreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_rbfreport_clear(_d_rep);
    end;
end;


procedure rbfbuildmodel( s: Trbfmodel; out  rep: Trbfreport; const _xparams: UInt64 = 0);
begin
    _core_rbfbuildmodel(s, rep, _xparams);
end;


function _core_rbfcalc1( s: Trbfmodel;  x0: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_x0: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_x0 := x0;
        _error_code := x_xv2_rbfcalc1(@_s_error_msg, @_d_result, @_d_s, @_d_x0, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfcalc1 call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function rbfcalc1( s: Trbfmodel;  x0: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rbfcalc1(s, x0, _xparams);
end;


function _core_rbfcalc2( s: Trbfmodel;  x0: Double;  x1: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_x0: Double;
    _d_x1: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_x0 := x0;
        _d_x1 := x1;
        _error_code := x_xv2_rbfcalc2(@_s_error_msg, @_d_result, @_d_s, @_d_x0, @_d_x1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfcalc2 call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function rbfcalc2( s: Trbfmodel;  x0: Double;  x1: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rbfcalc2(s, x0, x1, _xparams);
end;


function _core_rbfcalc3( s: Trbfmodel;  x0: Double;  x1: Double;  x2: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
    _d_x0: Double;
    _d_x1: Double;
    _d_x2: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_x0 := x0;
        _d_x1 := x1;
        _d_x2 := x2;
        _error_code := x_xv2_rbfcalc3(@_s_error_msg, @_d_result, @_d_s, @_d_x0, @_d_x1, @_d_x2, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfcalc3 call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function rbfcalc3( s: Trbfmodel;  x0: Double;  x1: Double;  x2: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rbfcalc3(s, x0, x1, x2, _xparams);
end;


procedure _core_rbfcalc( s: Trbfmodel;  x: TVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_rbfcalc(@_s_error_msg, @_d_s, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfcalc call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure rbfcalc( s: Trbfmodel;  x: TVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_rbfcalc(s, x, y, _xparams);
end;


procedure _core_rbfcalcbuf( s: Trbfmodel;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_rbfcalcbuf(@_s_error_msg, @_d_s, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfcalcbuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure rbfcalcbuf( s: Trbfmodel;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_rbfcalcbuf(s, x, y, _xparams);
end;


procedure _core_rbftscalcbuf( s: Trbfmodel;  buf: Trbfcalcbuffer;  x: TVector; var  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_buf : Pointer;
    _d_x: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _d_buf := buf.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _error_code := x_xv2_rbftscalcbuf(@_s_error_msg, @_d_s, @_d_buf, @_d_x, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbftscalcbuf call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(buf.ptr=_d_buf, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure rbftscalcbuf( s: Trbfmodel;  buf: Trbfcalcbuffer;  x: TVector; var  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_rbftscalcbuf(s, buf, x, y, _xparams);
end;


procedure _core_rbfgridcalc2( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger; out  y: TMatrix; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x0: x_vector;
    _d_n0: NativeInt;
    _d_x1: x_vector;
    _d_n1: NativeInt;
    _d_y: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x0, x0, X_CREATE);
        _d_n0 := n0;
        x_from_array(_d_x1, x1, X_CREATE);
        _d_n1 := n1;
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_rbfgridcalc2(@_s_error_msg, @_d_s, @_d_x0, @_d_n0, @_d_x1, @_d_n1, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfgridcalc2 call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x0);
        x_clear(_d_x1);
        x_clear(_d_y);
    end;
end;


procedure rbfgridcalc2( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger; out  y: TMatrix; const _xparams: UInt64 = 0);
begin
    _core_rbfgridcalc2(s, x0, n0, x1, n1, y, _xparams);
end;


procedure _core_rbfgridcalc2v( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x0: x_vector;
    _d_n0: NativeInt;
    _d_x1: x_vector;
    _d_n1: NativeInt;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x0, x0, X_CREATE);
        _d_n0 := n0;
        x_from_array(_d_x1, x1, X_CREATE);
        _d_n1 := n1;
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_rbfgridcalc2v(@_s_error_msg, @_d_s, @_d_x0, @_d_n0, @_d_x1, @_d_n1, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfgridcalc2v call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x0);
        x_clear(_d_x1);
        x_clear(_d_y);
    end;
end;


procedure rbfgridcalc2v( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_rbfgridcalc2v(s, x0, n0, x1, n1, y, _xparams);
end;


procedure _core_rbfgridcalc2vsubset( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  flagy: TBVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x0: x_vector;
    _d_n0: NativeInt;
    _d_x1: x_vector;
    _d_n1: NativeInt;
    _d_flagy: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x0, x0, X_CREATE);
        _d_n0 := n0;
        x_from_array(_d_x1, x1, X_CREATE);
        _d_n1 := n1;
        x_from_array(_d_flagy, flagy, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_rbfgridcalc2vsubset(@_s_error_msg, @_d_s, @_d_x0, @_d_n0, @_d_x1, @_d_n1, @_d_flagy, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfgridcalc2vsubset call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x0);
        x_clear(_d_x1);
        x_clear(_d_flagy);
        x_clear(_d_y);
    end;
end;


procedure rbfgridcalc2vsubset( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  flagy: TBVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_rbfgridcalc2vsubset(s, x0, n0, x1, n1, flagy, y, _xparams);
end;


procedure _core_rbfgridcalc3v( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  x2: TVector;  n2: TALGLIBInteger; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x0: x_vector;
    _d_n0: NativeInt;
    _d_x1: x_vector;
    _d_n1: NativeInt;
    _d_x2: x_vector;
    _d_n2: NativeInt;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x0, x0, X_CREATE);
        _d_n0 := n0;
        x_from_array(_d_x1, x1, X_CREATE);
        _d_n1 := n1;
        x_from_array(_d_x2, x2, X_CREATE);
        _d_n2 := n2;
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_rbfgridcalc3v(@_s_error_msg, @_d_s, @_d_x0, @_d_n0, @_d_x1, @_d_n1, @_d_x2, @_d_n2, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfgridcalc3v call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x0);
        x_clear(_d_x1);
        x_clear(_d_x2);
        x_clear(_d_y);
    end;
end;


procedure rbfgridcalc3v( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  x2: TVector;  n2: TALGLIBInteger; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_rbfgridcalc3v(s, x0, n0, x1, n1, x2, n2, y, _xparams);
end;


procedure _core_rbfgridcalc3vsubset( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  x2: TVector;  n2: TALGLIBInteger;  flagy: TBVector; out  y: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_x0: x_vector;
    _d_n0: NativeInt;
    _d_x1: x_vector;
    _d_n1: NativeInt;
    _d_x2: x_vector;
    _d_n2: NativeInt;
    _d_flagy: x_vector;
    _d_y: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_from_array(_d_x0, x0, X_CREATE);
        _d_n0 := n0;
        x_from_array(_d_x1, x1, X_CREATE);
        _d_n1 := n1;
        x_from_array(_d_x2, x2, X_CREATE);
        _d_n2 := n2;
        x_from_array(_d_flagy, flagy, X_CREATE);
        x_create_empty(_d_y, DT_REAL);
        y := nil;
        _error_code := x_xv2_rbfgridcalc3vsubset(@_s_error_msg, @_d_s, @_d_x0, @_d_n0, @_d_x1, @_d_n1, @_d_x2, @_d_n2, @_d_flagy, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfgridcalc3vsubset call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_y, y);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x0);
        x_clear(_d_x1);
        x_clear(_d_x2);
        x_clear(_d_flagy);
        x_clear(_d_y);
    end;
end;


procedure rbfgridcalc3vsubset( s: Trbfmodel;  x0: TVector;  n0: TALGLIBInteger;  x1: TVector;  n1: TALGLIBInteger;  x2: TVector;  n2: TALGLIBInteger;  flagy: TBVector; out  y: TVector; const _xparams: UInt64 = 0);
begin
    _core_rbfgridcalc3vsubset(s, x0, n0, x1, n1, x2, n2, flagy, y, _xparams);
end;


procedure _core_rbfunpack( s: Trbfmodel; out  nx: TALGLIBInteger; out  ny: TALGLIBInteger; out  xwr: TMatrix; out  nc: TALGLIBInteger; out  v: TMatrix; out  modelversion: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
    _d_nx: NativeInt;
    _d_ny: NativeInt;
    _d_xwr: x_matrix;
    _d_nc: NativeInt;
    _d_v: x_matrix;
    _d_modelversion: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        x_create_empty(_d_xwr, DT_REAL);
        xwr := nil;
        x_create_empty(_d_v, DT_REAL);
        v := nil;
        _error_code := x_xv2_rbfunpack(@_s_error_msg, @_d_s, @_d_nx, @_d_ny, @_d_xwr, @_d_nc, @_d_v, @_d_modelversion, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfunpack call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
        nx := _d_nx;
        ny := _d_ny;
        x_to_array(_d_xwr, xwr);
        nc := _d_nc;
        x_to_array(_d_v, v);
        modelversion := _d_modelversion;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xwr);
        x_clear(_d_v);
    end;
end;


procedure rbfunpack( s: Trbfmodel; out  nx: TALGLIBInteger; out  ny: TALGLIBInteger; out  xwr: TMatrix; out  nc: TALGLIBInteger; out  v: TMatrix; out  modelversion: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_rbfunpack(s, nx, ny, xwr, nc, v, modelversion, _xparams);
end;


function _core_rbfgetmodelversion( s: Trbfmodel; _xparams: UInt64):TALGLIBInteger;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: NativeInt;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_rbfgetmodelversion(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfgetmodelversion call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function rbfgetmodelversion( s: Trbfmodel; const _xparams: UInt64 = 0):TALGLIBInteger;
begin
    Result := _core_rbfgetmodelversion(s, _xparams);
end;


function _core_rbfpeekprogress( s: Trbfmodel; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_rbfpeekprogress(@_s_error_msg, @_d_result, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfpeekprogress call');
        end;
        result := _d_result;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function rbfpeekprogress( s: Trbfmodel; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_rbfpeekprogress(s, _xparams);
end;


procedure _core_rbfrequesttermination( s: Trbfmodel; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_s : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_s := s.ptr;
        _error_code := x_xv2_rbfrequesttermination(@_s_error_msg, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rbfrequesttermination call');
        end;
        Assert(s.ptr=_d_s, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure rbfrequesttermination( s: Trbfmodel; const _xparams: UInt64 = 0);
begin
    _core_rbfrequesttermination(s, _xparams);
end;


procedure _core_nsfitspheremcc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rhi: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_cx: x_vector;
    _d_rhi: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_nsfitspheremcc(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_cx, @_d_rhi, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nsfitspheremcc call');
        end;
        x_to_array(_d_cx, cx);
        rhi := _d_rhi;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure nsfitspheremcc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rhi: Double; const _xparams: UInt64 = 0);
begin
    _core_nsfitspheremcc(xy, npoints, nx, cx, rhi, _xparams);
end;


procedure _core_nsfitspheremic( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_cx: x_vector;
    _d_rlo: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_nsfitspheremic(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_cx, @_d_rlo, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nsfitspheremic call');
        end;
        x_to_array(_d_cx, cx);
        rlo := _d_rlo;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure nsfitspheremic( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; const _xparams: UInt64 = 0);
begin
    _core_nsfitspheremic(xy, npoints, nx, cx, rlo, _xparams);
end;


procedure _core_nsfitspheremzc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; out  rhi: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_cx: x_vector;
    _d_rlo: Double;
    _d_rhi: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_nsfitspheremzc(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_cx, @_d_rlo, @_d_rhi, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nsfitspheremzc call');
        end;
        x_to_array(_d_cx, cx);
        rlo := _d_rlo;
        rhi := _d_rhi;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure nsfitspheremzc( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
begin
    _core_nsfitspheremzc(xy, npoints, nx, cx, rlo, rhi, _xparams);
end;


procedure _core_nsfitspherex( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger;  problemtype: TALGLIBInteger;  epsx: Double;  aulits: TALGLIBInteger;  penalty: Double; out  cx: TVector; out  rlo: Double; out  rhi: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_xy: x_matrix;
    _d_npoints: NativeInt;
    _d_nx: NativeInt;
    _d_problemtype: NativeInt;
    _d_epsx: Double;
    _d_aulits: NativeInt;
    _d_penalty: Double;
    _d_cx: x_vector;
    _d_rlo: Double;
    _d_rhi: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_xy, xy, X_CREATE);
        _d_npoints := npoints;
        _d_nx := nx;
        _d_problemtype := problemtype;
        _d_epsx := epsx;
        _d_aulits := aulits;
        _d_penalty := penalty;
        x_create_empty(_d_cx, DT_REAL);
        cx := nil;
        _error_code := x_xv2_nsfitspherex(@_s_error_msg, @_d_xy, @_d_npoints, @_d_nx, @_d_problemtype, @_d_epsx, @_d_aulits, @_d_penalty, @_d_cx, @_d_rlo, @_d_rhi, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nsfitspherex call');
        end;
        x_to_array(_d_cx, cx);
        rlo := _d_rlo;
        rhi := _d_rhi;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_xy);
        x_clear(_d_cx);
    end;
end;


procedure nsfitspherex( xy: TMatrix;  npoints: TALGLIBInteger;  nx: TALGLIBInteger;  problemtype: TALGLIBInteger;  epsx: Double;  aulits: TALGLIBInteger;  penalty: Double; out  cx: TVector; out  rlo: Double; out  rhi: Double; const _xparams: UInt64 = 0);
begin
    _core_nsfitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, cx, rlo, rhi, _xparams);
end;


procedure _core_spline1dfitpenalized( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_rho: Double;
    _d_info: NativeInt;
    _d_s : Pointer;
    _d_rep: x_spline1dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_rho := rho;
        _d_s := nil;
        s := nil;
        x_spline1dfitreport_init(_d_rep);
        _error_code := x_xv2_spline1dfitpenalized(@_s_error_msg, @_d_x, @_d_y, @_d_n, @_d_m, @_d_rho, @_d_info, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dfitpenalized call');
        end;
        info := _d_info;
        s := Tspline1dinterpolant.Create(_d_s);
        x_spline1dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline1dfitreport_clear(_d_rep);
    end;
end;


procedure spline1dfitpenalized( x: TVector;  y: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dfitpenalized(x, y, n, m, rho, info, s, rep, _xparams);
end;


procedure spline1dfitpenalized( x: TVector;  y: TVector;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) then
    raise Exception.Create('Error while calling spline1dfitpenalized: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dfitpenalized(x, y, n, m, rho, info, s, rep, _xparams);

end;


procedure _core_spline1dfitpenalizedw( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_y: x_vector;
    _d_w: x_vector;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_rho: Double;
    _d_info: NativeInt;
    _d_s : Pointer;
    _d_rep: x_spline1dfitreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        x_from_array(_d_y, y, X_CREATE);
        x_from_array(_d_w, w, X_CREATE);
        _d_n := n;
        _d_m := m;
        _d_rho := rho;
        _d_s := nil;
        s := nil;
        x_spline1dfitreport_init(_d_rep);
        _error_code := x_xv2_spline1dfitpenalizedw(@_s_error_msg, @_d_x, @_d_y, @_d_w, @_d_n, @_d_m, @_d_rho, @_d_info, @_d_s, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spline1dfitpenalizedw call');
        end;
        info := _d_info;
        s := Tspline1dinterpolant.Create(_d_s);
        x_spline1dfitreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
        x_clear(_d_w);
        if (_d_s<>nil) and (s=nil) then
            x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to Delphi objects
        x_spline1dfitreport_clear(_d_rep);
    end;
end;


procedure spline1dfitpenalizedw( x: TVector;  y: TVector;  w: TVector;  n: TALGLIBInteger;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
begin
    _core_spline1dfitpenalizedw(x, y, w, n, m, rho, info, s, rep, _xparams);
end;


procedure spline1dfitpenalizedw( x: TVector;  y: TVector;  w: TVector;  m: TALGLIBInteger;  rho: Double; out  info: TALGLIBInteger; out  s: Tspline1dinterpolant; out  rep: Tspline1dfitreport; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin
    if ((xlen(x)<>xlen(y))) or ((xlen(x)<>xlen(w))) then
    raise Exception.Create('Error while calling spline1dfitpenalizedw: looks like one of arguments has wrong size');

    n := xlen(x);

    _core_spline1dfitpenalizedw(x, y, w, n, m, rho, info, s, rep, _xparams);

end;


function _core_ellipticintegralk( m: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_m: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _error_code := x_xv2_ellipticintegralk(@_s_error_msg, @_d_result, @_d_m, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ellipticintegralk call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function ellipticintegralk( m: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_ellipticintegralk(m, _xparams);
end;


function _core_ellipticintegralkhighprecision( m1: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_m1: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m1 := m1;
        _error_code := x_xv2_ellipticintegralkhighprecision(@_s_error_msg, @_d_result, @_d_m1, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ellipticintegralkhighprecision call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function ellipticintegralkhighprecision( m1: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_ellipticintegralkhighprecision(m1, _xparams);
end;


function _core_incompleteellipticintegralk( phi: Double;  m: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_phi: Double;
    _d_m: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_phi := phi;
        _d_m := m;
        _error_code := x_xv2_incompleteellipticintegralk(@_s_error_msg, @_d_result, @_d_phi, @_d_m, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during incompleteellipticintegralk call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function incompleteellipticintegralk( phi: Double;  m: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_incompleteellipticintegralk(phi, m, _xparams);
end;


function _core_ellipticintegrale( m: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_m: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_m := m;
        _error_code := x_xv2_ellipticintegrale(@_s_error_msg, @_d_result, @_d_m, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ellipticintegrale call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function ellipticintegrale( m: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_ellipticintegrale(m, _xparams);
end;


function _core_incompleteellipticintegrale( phi: Double;  m: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_phi: Double;
    _d_m: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_phi := phi;
        _d_m := m;
        _error_code := x_xv2_incompleteellipticintegrale(@_s_error_msg, @_d_result, @_d_phi, @_d_m, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during incompleteellipticintegrale call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function incompleteellipticintegrale( phi: Double;  m: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_incompleteellipticintegrale(phi, m, _xparams);
end;


function _core_hermitecalculate( n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_hermitecalculate(@_s_error_msg, @_d_result, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hermitecalculate call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function hermitecalculate( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hermitecalculate(n, x, _xparams);
end;


function _core_hermitesum( c: TVector;  n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_hermitesum(@_s_error_msg, @_d_result, @_d_c, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hermitesum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


function hermitesum( c: TVector;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_hermitesum(c, n, x, _xparams);
end;


procedure _core_hermitecoefficients( n: TALGLIBInteger; out  c: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_hermitecoefficients(@_s_error_msg, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hermitecoefficients call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


procedure hermitecoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
begin
    _core_hermitecoefficients(n, c, _xparams);
end;


function _core_dawsonintegral( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_dawsonintegral(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during dawsonintegral call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function dawsonintegral( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_dawsonintegral(x, _xparams);
end;


procedure _core_sinecosineintegrals( x: Double; out  si: Double; out  ci: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: Double;
    _d_si: Double;
    _d_ci: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_sinecosineintegrals(@_s_error_msg, @_d_x, @_d_si, @_d_ci, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sinecosineintegrals call');
        end;
        si := _d_si;
        ci := _d_ci;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure sinecosineintegrals( x: Double; out  si: Double; out  ci: Double; const _xparams: UInt64 = 0);
begin
    _core_sinecosineintegrals(x, si, ci, _xparams);
end;


procedure _core_hyperbolicsinecosineintegrals( x: Double; out  shi: Double; out  chi: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: Double;
    _d_shi: Double;
    _d_chi: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_hyperbolicsinecosineintegrals(@_s_error_msg, @_d_x, @_d_shi, @_d_chi, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during hyperbolicsinecosineintegrals call');
        end;
        shi := _d_shi;
        chi := _d_chi;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure hyperbolicsinecosineintegrals( x: Double; out  shi: Double; out  chi: Double; const _xparams: UInt64 = 0);
begin
    _core_hyperbolicsinecosineintegrals(x, shi, chi, _xparams);
end;


function _core_poissondistribution( k: TALGLIBInteger;  m: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_m: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_m := m;
        _error_code := x_xv2_poissondistribution(@_s_error_msg, @_d_result, @_d_k, @_d_m, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during poissondistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function poissondistribution( k: TALGLIBInteger;  m: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_poissondistribution(k, m, _xparams);
end;


function _core_poissoncdistribution( k: TALGLIBInteger;  m: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_m: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_m := m;
        _error_code := x_xv2_poissoncdistribution(@_s_error_msg, @_d_result, @_d_k, @_d_m, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during poissoncdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function poissoncdistribution( k: TALGLIBInteger;  m: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_poissoncdistribution(k, m, _xparams);
end;


function _core_invpoissondistribution( k: TALGLIBInteger;  y: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_y := y;
        _error_code := x_xv2_invpoissondistribution(@_s_error_msg, @_d_result, @_d_k, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invpoissondistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invpoissondistribution( k: TALGLIBInteger;  y: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invpoissondistribution(k, y, _xparams);
end;


function _core_besselj0( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_besselj0(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besselj0 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besselj0( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besselj0(x, _xparams);
end;


function _core_besselj1( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_besselj1(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besselj1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besselj1( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besselj1(x, _xparams);
end;


function _core_besseljn( n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_besseljn(@_s_error_msg, @_d_result, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besseljn call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besseljn( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besseljn(n, x, _xparams);
end;


function _core_bessely0( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_bessely0(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during bessely0 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function bessely0( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_bessely0(x, _xparams);
end;


function _core_bessely1( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_bessely1(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during bessely1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function bessely1( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_bessely1(x, _xparams);
end;


function _core_besselyn( n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_besselyn(@_s_error_msg, @_d_result, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besselyn call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besselyn( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besselyn(n, x, _xparams);
end;


function _core_besseli0( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_besseli0(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besseli0 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besseli0( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besseli0(x, _xparams);
end;


function _core_besseli1( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_besseli1(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besseli1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besseli1( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besseli1(x, _xparams);
end;


function _core_besselk0( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_besselk0(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besselk0 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besselk0( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besselk0(x, _xparams);
end;


function _core_besselk1( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_besselk1(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besselk1 call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besselk1( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besselk1(x, _xparams);
end;


function _core_besselkn( nn: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_nn: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_nn := nn;
        _d_x := x;
        _error_code := x_xv2_besselkn(@_s_error_msg, @_d_result, @_d_nn, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during besselkn call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function besselkn( nn: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_besselkn(nn, x, _xparams);
end;


function _core_incompletebeta( a: Double;  b: Double;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_b: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_x := x;
        _error_code := x_xv2_incompletebeta(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during incompletebeta call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function incompletebeta( a: Double;  b: Double;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_incompletebeta(a, b, x, _xparams);
end;


function _core_invincompletebeta( a: Double;  b: Double;  y: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_b: Double;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_y := y;
        _error_code := x_xv2_invincompletebeta(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invincompletebeta call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invincompletebeta( a: Double;  b: Double;  y: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invincompletebeta(a, b, y, _xparams);
end;


function _core_fdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: NativeInt;
    _d_b: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_x := x;
        _error_code := x_xv2_fdistribution(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function fdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_fdistribution(a, b, x, _xparams);
end;


function _core_fcdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: NativeInt;
    _d_b: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_x := x;
        _error_code := x_xv2_fcdistribution(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fcdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function fcdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_fcdistribution(a, b, x, _xparams);
end;


function _core_invfdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  y: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: NativeInt;
    _d_b: NativeInt;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _d_y := y;
        _error_code := x_xv2_invfdistribution(@_s_error_msg, @_d_result, @_d_a, @_d_b, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invfdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invfdistribution( a: TALGLIBInteger;  b: TALGLIBInteger;  y: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invfdistribution(a, b, y, _xparams);
end;


procedure _core_fresnelintegral( x: Double; var  c: Double; var  s: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: Double;
    _d_c: Double;
    _d_s: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _d_c := c;
        _d_s := s;
        _error_code := x_xv2_fresnelintegral(@_s_error_msg, @_d_x, @_d_c, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fresnelintegral call');
        end;
        c := _d_c;
        s := _d_s;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure fresnelintegral( x: Double; var  c: Double; var  s: Double; const _xparams: UInt64 = 0);
begin
    _core_fresnelintegral(x, c, s, _xparams);
end;


procedure _core_jacobianellipticfunctions( u: Double;  m: Double; out  sn: Double; out  cn: Double; out  dn: Double; out  ph: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_u: Double;
    _d_m: Double;
    _d_sn: Double;
    _d_cn: Double;
    _d_dn: Double;
    _d_ph: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_u := u;
        _d_m := m;
        _error_code := x_xv2_jacobianellipticfunctions(@_s_error_msg, @_d_u, @_d_m, @_d_sn, @_d_cn, @_d_dn, @_d_ph, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during jacobianellipticfunctions call');
        end;
        sn := _d_sn;
        cn := _d_cn;
        dn := _d_dn;
        ph := _d_ph;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure jacobianellipticfunctions( u: Double;  m: Double; out  sn: Double; out  cn: Double; out  dn: Double; out  ph: Double; const _xparams: UInt64 = 0);
begin
    _core_jacobianellipticfunctions(u, m, sn, cn, dn, ph, _xparams);
end;


function _core_psi( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_psi(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during psi call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function psi( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_psi(x, _xparams);
end;


function _core_exponentialintegralei( x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_exponentialintegralei(@_s_error_msg, @_d_result, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during exponentialintegralei call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function exponentialintegralei( x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_exponentialintegralei(x, _xparams);
end;


function _core_exponentialintegralen( x: Double;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_x: Double;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _d_n := n;
        _error_code := x_xv2_exponentialintegralen(@_s_error_msg, @_d_result, @_d_x, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during exponentialintegralen call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function exponentialintegralen( x: Double;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_exponentialintegralen(x, n, _xparams);
end;


function _core_laguerrecalculate( n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_laguerrecalculate(@_s_error_msg, @_d_result, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during laguerrecalculate call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function laguerrecalculate( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_laguerrecalculate(n, x, _xparams);
end;


function _core_laguerresum( c: TVector;  n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_laguerresum(@_s_error_msg, @_d_result, @_d_c, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during laguerresum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


function laguerresum( c: TVector;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_laguerresum(c, n, x, _xparams);
end;


procedure _core_laguerrecoefficients( n: TALGLIBInteger; out  c: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_laguerrecoefficients(@_s_error_msg, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during laguerrecoefficients call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


procedure laguerrecoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
begin
    _core_laguerrecoefficients(n, c, _xparams);
end;


function _core_chisquaredistribution( v: Double;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_v: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_v := v;
        _d_x := x;
        _error_code := x_xv2_chisquaredistribution(@_s_error_msg, @_d_result, @_d_v, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during chisquaredistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function chisquaredistribution( v: Double;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_chisquaredistribution(v, x, _xparams);
end;


function _core_chisquarecdistribution( v: Double;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_v: Double;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_v := v;
        _d_x := x;
        _error_code := x_xv2_chisquarecdistribution(@_s_error_msg, @_d_result, @_d_v, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during chisquarecdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function chisquarecdistribution( v: Double;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_chisquarecdistribution(v, x, _xparams);
end;


function _core_invchisquaredistribution( v: Double;  y: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_v: Double;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_v := v;
        _d_y := y;
        _error_code := x_xv2_invchisquaredistribution(@_s_error_msg, @_d_result, @_d_v, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invchisquaredistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invchisquaredistribution( v: Double;  y: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invchisquaredistribution(v, y, _xparams);
end;


function _core_legendrecalculate( n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_legendrecalculate(@_s_error_msg, @_d_result, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during legendrecalculate call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function legendrecalculate( n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_legendrecalculate(n, x, _xparams);
end;


function _core_legendresum( c: TVector;  n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c: x_vector;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_c, c, X_CREATE);
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_legendresum(@_s_error_msg, @_d_result, @_d_c, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during legendresum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


function legendresum( c: TVector;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_legendresum(c, n, x, _xparams);
end;


procedure _core_legendrecoefficients( n: TALGLIBInteger; out  c: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_legendrecoefficients(@_s_error_msg, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during legendrecoefficients call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


procedure legendrecoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
begin
    _core_legendrecoefficients(n, c, _xparams);
end;


function _core_beta( a: Double;  b: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: Double;
    _d_b: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a;
        _d_b := b;
        _error_code := x_xv2_beta(@_s_error_msg, @_d_result, @_d_a, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during beta call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function beta( a: Double;  b: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_beta(a, b, _xparams);
end;


function _core_chebyshevcalculate( r: TALGLIBInteger;  n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_r: NativeInt;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_r := r;
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_chebyshevcalculate(@_s_error_msg, @_d_result, @_d_r, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during chebyshevcalculate call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function chebyshevcalculate( r: TALGLIBInteger;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_chebyshevcalculate(r, n, x, _xparams);
end;


function _core_chebyshevsum( c: TVector;  r: TALGLIBInteger;  n: TALGLIBInteger;  x: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_c: x_vector;
    _d_r: NativeInt;
    _d_n: NativeInt;
    _d_x: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_c, c, X_CREATE);
        _d_r := r;
        _d_n := n;
        _d_x := x;
        _error_code := x_xv2_chebyshevsum(@_s_error_msg, @_d_result, @_d_c, @_d_r, @_d_n, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during chebyshevsum call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


function chebyshevsum( c: TVector;  r: TALGLIBInteger;  n: TALGLIBInteger;  x: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_chebyshevsum(c, r, n, x, _xparams);
end;


procedure _core_chebyshevcoefficients( n: TALGLIBInteger; out  c: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_c: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        x_create_empty(_d_c, DT_REAL);
        c := nil;
        _error_code := x_xv2_chebyshevcoefficients(@_s_error_msg, @_d_n, @_d_c, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during chebyshevcoefficients call');
        end;
        x_to_array(_d_c, c);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_c);
    end;
end;


procedure chebyshevcoefficients( n: TALGLIBInteger; out  c: TVector; const _xparams: UInt64 = 0);
begin
    _core_chebyshevcoefficients(n, c, _xparams);
end;


procedure _core_fromchebyshev( a: TVector;  n: TALGLIBInteger; out  b: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_create_empty(_d_b, DT_REAL);
        b := nil;
        _error_code := x_xv2_fromchebyshev(@_s_error_msg, @_d_a, @_d_n, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during fromchebyshev call');
        end;
        x_to_array(_d_b, b);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
    end;
end;


procedure fromchebyshev( a: TVector;  n: TALGLIBInteger; out  b: TVector; const _xparams: UInt64 = 0);
begin
    _core_fromchebyshev(a, n, b, _xparams);
end;


function _core_studenttdistribution( k: TALGLIBInteger;  t: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_t: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_t := t;
        _error_code := x_xv2_studenttdistribution(@_s_error_msg, @_d_result, @_d_k, @_d_t, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during studenttdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function studenttdistribution( k: TALGLIBInteger;  t: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_studenttdistribution(k, t, _xparams);
end;


function _core_invstudenttdistribution( k: TALGLIBInteger;  p: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_p: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_p := p;
        _error_code := x_xv2_invstudenttdistribution(@_s_error_msg, @_d_result, @_d_k, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invstudenttdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invstudenttdistribution( k: TALGLIBInteger;  p: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invstudenttdistribution(k, p, _xparams);
end;


function _core_binomialdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  p: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_n: NativeInt;
    _d_p: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_n := n;
        _d_p := p;
        _error_code := x_xv2_binomialdistribution(@_s_error_msg, @_d_result, @_d_k, @_d_n, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during binomialdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function binomialdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  p: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_binomialdistribution(k, n, p, _xparams);
end;


function _core_binomialcdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  p: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_n: NativeInt;
    _d_p: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_n := n;
        _d_p := p;
        _error_code := x_xv2_binomialcdistribution(@_s_error_msg, @_d_result, @_d_k, @_d_n, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during binomialcdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function binomialcdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  p: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_binomialcdistribution(k, n, p, _xparams);
end;


function _core_invbinomialdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  y: Double; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_k: NativeInt;
    _d_n: NativeInt;
    _d_y: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_k := k;
        _d_n := n;
        _d_y := y;
        _error_code := x_xv2_invbinomialdistribution(@_s_error_msg, @_d_result, @_d_k, @_d_n, @_d_y, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during invbinomialdistribution call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function invbinomialdistribution( k: TALGLIBInteger;  n: TALGLIBInteger;  y: Double; const _xparams: UInt64 = 0):Double;
begin
    Result := _core_invbinomialdistribution(k, n, y, _xparams);
end;


procedure _core_airy( x: Double; out  ai: Double; out  aip: Double; out  bi: Double; out  bip: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: Double;
    _d_ai: Double;
    _d_aip: Double;
    _d_bi: Double;
    _d_bip: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_x := x;
        _error_code := x_xv2_airy(@_s_error_msg, @_d_x, @_d_ai, @_d_aip, @_d_bi, @_d_bip, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during airy call');
        end;
        ai := _d_ai;
        aip := _d_aip;
        bi := _d_bi;
        bip := _d_bip;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure airy( x: Double; out  ai: Double; out  aip: Double; out  bi: Double; out  bip: Double; const _xparams: UInt64 = 0);
begin
    _core_airy(x, ai, aip, bi, bip, _xparams);
end;


procedure _core_wilcoxonsignedranktest( x: TVector;  n: TALGLIBInteger;  e: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_e: Double;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_e := e;
        _error_code := x_xv2_wilcoxonsignedranktest(@_s_error_msg, @_d_x, @_d_n, @_d_e, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during wilcoxonsignedranktest call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure wilcoxonsignedranktest( x: TVector;  n: TALGLIBInteger;  e: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_wilcoxonsignedranktest(x, n, e, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_onesamplesigntest( x: TVector;  n: TALGLIBInteger;  median: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_median: Double;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_median := median;
        _error_code := x_xv2_onesamplesigntest(@_s_error_msg, @_d_x, @_d_n, @_d_median, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during onesamplesigntest call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure onesamplesigntest( x: TVector;  n: TALGLIBInteger;  median: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_onesamplesigntest(x, n, median, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_pearsoncorrelationsignificance( r: Double;  n: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_r: Double;
    _d_n: NativeInt;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_r := r;
        _d_n := n;
        _error_code := x_xv2_pearsoncorrelationsignificance(@_s_error_msg, @_d_r, @_d_n, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during pearsoncorrelationsignificance call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure pearsoncorrelationsignificance( r: Double;  n: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_pearsoncorrelationsignificance(r, n, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_spearmanrankcorrelationsignificance( r: Double;  n: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_r: Double;
    _d_n: NativeInt;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_r := r;
        _d_n := n;
        _error_code := x_xv2_spearmanrankcorrelationsignificance(@_s_error_msg, @_d_r, @_d_n, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spearmanrankcorrelationsignificance call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure spearmanrankcorrelationsignificance( r: Double;  n: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_spearmanrankcorrelationsignificance(r, n, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_studentttest1( x: TVector;  n: TALGLIBInteger;  mean: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_mean: Double;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_mean := mean;
        _error_code := x_xv2_studentttest1(@_s_error_msg, @_d_x, @_d_n, @_d_mean, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during studentttest1 call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure studentttest1( x: TVector;  n: TALGLIBInteger;  mean: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_studentttest1(x, n, mean, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_studentttest2( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_y: x_vector;
    _d_m: NativeInt;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        x_from_array(_d_y, y, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_studentttest2(@_s_error_msg, @_d_x, @_d_n, @_d_y, @_d_m, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during studentttest2 call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure studentttest2( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_studentttest2(x, n, y, m, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_unequalvariancettest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_y: x_vector;
    _d_m: NativeInt;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        x_from_array(_d_y, y, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_unequalvariancettest(@_s_error_msg, @_d_x, @_d_n, @_d_y, @_d_m, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during unequalvariancettest call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure unequalvariancettest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_unequalvariancettest(x, n, y, m, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_mannwhitneyutest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_y: x_vector;
    _d_m: NativeInt;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        x_from_array(_d_y, y, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_mannwhitneyutest(@_s_error_msg, @_d_x, @_d_n, @_d_y, @_d_m, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during mannwhitneyutest call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure mannwhitneyutest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_mannwhitneyutest(x, n, y, m, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_jarqueberatest( x: TVector;  n: TALGLIBInteger; out  p: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_p: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_jarqueberatest(@_s_error_msg, @_d_x, @_d_n, @_d_p, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during jarqueberatest call');
        end;
        p := _d_p;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure jarqueberatest( x: TVector;  n: TALGLIBInteger; out  p: Double; const _xparams: UInt64 = 0);
begin
    _core_jarqueberatest(x, n, p, _xparams);
end;


procedure _core_ftest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_y: x_vector;
    _d_m: NativeInt;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        x_from_array(_d_y, y, X_CREATE);
        _d_m := m;
        _error_code := x_xv2_ftest(@_s_error_msg, @_d_x, @_d_n, @_d_y, @_d_m, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during ftest call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_clear(_d_y);
    end;
end;


procedure ftest( x: TVector;  n: TALGLIBInteger;  y: TVector;  m: TALGLIBInteger; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_ftest(x, n, y, m, bothtails, lefttail, righttail, _xparams);
end;


procedure _core_onesamplevariancetest( x: TVector;  n: TALGLIBInteger;  variance: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_x: x_vector;
    _d_n: NativeInt;
    _d_variance: Double;
    _d_bothtails: Double;
    _d_lefttail: Double;
    _d_righttail: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_x, x, X_CREATE);
        _d_n := n;
        _d_variance := variance;
        _error_code := x_xv2_onesamplevariancetest(@_s_error_msg, @_d_x, @_d_n, @_d_variance, @_d_bothtails, @_d_lefttail, @_d_righttail, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during onesamplevariancetest call');
        end;
        bothtails := _d_bothtails;
        lefttail := _d_lefttail;
        righttail := _d_righttail;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure onesamplevariancetest( x: TVector;  n: TALGLIBInteger;  variance: Double; out  bothtails: Double; out  lefttail: Double; out  righttail: Double; const _xparams: UInt64 = 0);
begin
    _core_onesamplevariancetest(x, n, variance, bothtails, lefttail, righttail, _xparams);
end;


function _core_rmatrixschur(var  a: TMatrix;  n: TALGLIBInteger; out  s: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_s: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_create_empty(_d_s, DT_REAL);
        s := nil;
        _error_code := x_xv2_rmatrixschur(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_s, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixschur call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_a, a);
        x_to_array(_d_s, s);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_s);
    end;
end;


function rmatrixschur(var  a: TMatrix;  n: TALGLIBInteger; out  s: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_rmatrixschur(a, n, s, _xparams);
end;


function _core_smatrixgevd( a: TMatrix;  n: TALGLIBInteger;  isuppera: Boolean;  b: TMatrix;  isupperb: Boolean;  zneeded: TALGLIBInteger;  problemtype: TALGLIBInteger; out  d: TVector; out  z: TMatrix; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isuppera: Byte;
    _d_b: x_matrix;
    _d_isupperb: Byte;
    _d_zneeded: NativeInt;
    _d_problemtype: NativeInt;
    _d_d: x_vector;
    _d_z: x_matrix;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isuppera := Bool2Byte(isuppera);
        x_from_array(_d_b, b, X_CREATE);
        _d_isupperb := Bool2Byte(isupperb);
        _d_zneeded := zneeded;
        _d_problemtype := problemtype;
        x_create_empty(_d_d, DT_REAL);
        d := nil;
        x_create_empty(_d_z, DT_REAL);
        z := nil;
        _error_code := x_xv2_smatrixgevd(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isuppera, @_d_b, @_d_isupperb, @_d_zneeded, @_d_problemtype, @_d_d, @_d_z, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixgevd call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_d, d);
        x_to_array(_d_z, z);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_d);
        x_clear(_d_z);
    end;
end;


function smatrixgevd( a: TMatrix;  n: TALGLIBInteger;  isuppera: Boolean;  b: TMatrix;  isupperb: Boolean;  zneeded: TALGLIBInteger;  problemtype: TALGLIBInteger; out  d: TVector; out  z: TMatrix; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixgevd(a, n, isuppera, b, isupperb, zneeded, problemtype, d, z, _xparams);
end;


function _core_smatrixgevdreduce(var  a: TMatrix;  n: TALGLIBInteger;  isuppera: Boolean;  b: TMatrix;  isupperb: Boolean;  problemtype: TALGLIBInteger; out  r: TMatrix; out  isupperr: Boolean; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isuppera: Byte;
    _d_b: x_matrix;
    _d_isupperb: Byte;
    _d_problemtype: NativeInt;
    _d_r: x_matrix;
    _d_isupperr: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isuppera := Bool2Byte(isuppera);
        x_from_array(_d_b, b, X_CREATE);
        _d_isupperb := Bool2Byte(isupperb);
        _d_problemtype := problemtype;
        x_create_empty(_d_r, DT_REAL);
        r := nil;
        _error_code := x_xv2_smatrixgevdreduce(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isuppera, @_d_b, @_d_isupperb, @_d_problemtype, @_d_r, @_d_isupperr, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during smatrixgevdreduce call');
        end;
        result := Byte2Bool(_d_result);
        x_to_array(_d_a, a);
        x_to_array(_d_r, r);
        isupperr := Byte2Bool(_d_isupperr);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_b);
        x_clear(_d_r);
    end;
end;


function smatrixgevdreduce(var  a: TMatrix;  n: TALGLIBInteger;  isuppera: Boolean;  b: TMatrix;  isupperb: Boolean;  problemtype: TALGLIBInteger; out  r: TMatrix; out  isupperr: Boolean; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_smatrixgevdreduce(a, n, isuppera, b, isupperb, problemtype, r, isupperr, _xparams);
end;


procedure _core_rmatrixinvupdatesimple(var  inva: TMatrix;  n: TALGLIBInteger;  updrow: TALGLIBInteger;  updcolumn: TALGLIBInteger;  updval: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_inva: x_matrix;
    _d_n: NativeInt;
    _d_updrow: NativeInt;
    _d_updcolumn: NativeInt;
    _d_updval: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_inva, inva, X_CREATE);
        _d_n := n;
        _d_updrow := updrow;
        _d_updcolumn := updcolumn;
        _d_updval := updval;
        _error_code := x_xv2_rmatrixinvupdatesimple(@_s_error_msg, @_d_inva, @_d_n, @_d_updrow, @_d_updcolumn, @_d_updval, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixinvupdatesimple call');
        end;
        x_to_array(_d_inva, inva);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_inva);
    end;
end;


procedure rmatrixinvupdatesimple(var  inva: TMatrix;  n: TALGLIBInteger;  updrow: TALGLIBInteger;  updcolumn: TALGLIBInteger;  updval: Double; const _xparams: UInt64 = 0);
begin
    _core_rmatrixinvupdatesimple(inva, n, updrow, updcolumn, updval, _xparams);
end;


procedure _core_rmatrixinvupdaterow(var  inva: TMatrix;  n: TALGLIBInteger;  updrow: TALGLIBInteger;  v: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_inva: x_matrix;
    _d_n: NativeInt;
    _d_updrow: NativeInt;
    _d_v: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_inva, inva, X_CREATE);
        _d_n := n;
        _d_updrow := updrow;
        x_from_array(_d_v, v, X_CREATE);
        _error_code := x_xv2_rmatrixinvupdaterow(@_s_error_msg, @_d_inva, @_d_n, @_d_updrow, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixinvupdaterow call');
        end;
        x_to_array(_d_inva, inva);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_inva);
        x_clear(_d_v);
    end;
end;


procedure rmatrixinvupdaterow(var  inva: TMatrix;  n: TALGLIBInteger;  updrow: TALGLIBInteger;  v: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixinvupdaterow(inva, n, updrow, v, _xparams);
end;


procedure _core_rmatrixinvupdatecolumn(var  inva: TMatrix;  n: TALGLIBInteger;  updcolumn: TALGLIBInteger;  u: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_inva: x_matrix;
    _d_n: NativeInt;
    _d_updcolumn: NativeInt;
    _d_u: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_inva, inva, X_CREATE);
        _d_n := n;
        _d_updcolumn := updcolumn;
        x_from_array(_d_u, u, X_CREATE);
        _error_code := x_xv2_rmatrixinvupdatecolumn(@_s_error_msg, @_d_inva, @_d_n, @_d_updcolumn, @_d_u, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixinvupdatecolumn call');
        end;
        x_to_array(_d_inva, inva);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_inva);
        x_clear(_d_u);
    end;
end;


procedure rmatrixinvupdatecolumn(var  inva: TMatrix;  n: TALGLIBInteger;  updcolumn: TALGLIBInteger;  u: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixinvupdatecolumn(inva, n, updcolumn, u, _xparams);
end;


procedure _core_rmatrixinvupdateuv(var  inva: TMatrix;  n: TALGLIBInteger;  u: TVector;  v: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_inva: x_matrix;
    _d_n: NativeInt;
    _d_u: x_vector;
    _d_v: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_inva, inva, X_CREATE);
        _d_n := n;
        x_from_array(_d_u, u, X_CREATE);
        x_from_array(_d_v, v, X_CREATE);
        _error_code := x_xv2_rmatrixinvupdateuv(@_s_error_msg, @_d_inva, @_d_n, @_d_u, @_d_v, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixinvupdateuv call');
        end;
        x_to_array(_d_inva, inva);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_inva);
        x_clear(_d_u);
        x_clear(_d_v);
    end;
end;


procedure rmatrixinvupdateuv(var  inva: TMatrix;  n: TALGLIBInteger;  u: TVector;  v: TVector; const _xparams: UInt64 = 0);
begin
    _core_rmatrixinvupdateuv(inva, n, u, v, _xparams);
end;


function _core_rmatrixludet( a: TMatrix;  pivots: TIVector;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_pivots: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_pivots, pivots, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_rmatrixludet(@_s_error_msg, @_d_result, @_d_a, @_d_pivots, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixludet call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_pivots);
    end;
end;


function rmatrixludet( a: TMatrix;  pivots: TIVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_rmatrixludet(a, pivots, n, _xparams);
end;


function rmatrixludet( a: TMatrix;  pivots: TIVector; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin
    if ((xrows(a)<>xcols(a))) or ((xrows(a)<>xlen(pivots))) then
    raise Exception.Create('Error while calling rmatrixludet: looks like one of arguments has wrong size');

    n := xrows(a);

    Result := _core_rmatrixludet(a, pivots, n, _xparams);

end;


function _core_rmatrixdet( a: TMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_rmatrixdet(@_s_error_msg, @_d_result, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during rmatrixdet call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function rmatrixdet( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_rmatrixdet(a, n, _xparams);
end;


function rmatrixdet( a: TMatrix; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin
    if ((xrows(a)<>xcols(a))) then
    raise Exception.Create('Error while calling rmatrixdet: looks like one of arguments has wrong size');

    n := xrows(a);

    Result := _core_rmatrixdet(a, n, _xparams);

end;


function _core_cmatrixludet( a: TCMatrix;  pivots: TIVector;  n: TALGLIBInteger; _xparams: UInt64):Complex;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Complex;
    _d_a: x_matrix;
    _d_pivots: x_vector;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        x_from_array(_d_pivots, pivots, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_cmatrixludet(@_s_error_msg, @_d_result, @_d_a, @_d_pivots, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixludet call');
        end;
        result.x := _d_result.x;
        result.y := _d_result.y;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_pivots);
    end;
end;


function cmatrixludet( a: TCMatrix;  pivots: TIVector;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Complex;overload;
begin
    Result := _core_cmatrixludet(a, pivots, n, _xparams);
end;


function cmatrixludet( a: TCMatrix;  pivots: TIVector; const _xparams: UInt64 = 0):Complex;overload;
var
    n: TALGLIBInteger;

begin
    if ((xrows(a)<>xcols(a))) or ((xrows(a)<>xlen(pivots))) then
    raise Exception.Create('Error while calling cmatrixludet: looks like one of arguments has wrong size');

    n := xrows(a);

    Result := _core_cmatrixludet(a, pivots, n, _xparams);

end;


function _core_cmatrixdet( a: TCMatrix;  n: TALGLIBInteger; _xparams: UInt64):Complex;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Complex;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_cmatrixdet(@_s_error_msg, @_d_result, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during cmatrixdet call');
        end;
        result.x := _d_result.x;
        result.y := _d_result.y;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function cmatrixdet( a: TCMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Complex;overload;
begin
    Result := _core_cmatrixdet(a, n, _xparams);
end;


function cmatrixdet( a: TCMatrix; const _xparams: UInt64 = 0):Complex;overload;
var
    n: TALGLIBInteger;

begin
    if ((xrows(a)<>xcols(a))) then
    raise Exception.Create('Error while calling cmatrixdet: looks like one of arguments has wrong size');

    n := xrows(a);

    Result := _core_cmatrixdet(a, n, _xparams);

end;


function _core_spdmatrixcholeskydet( a: TMatrix;  n: TALGLIBInteger; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _error_code := x_xv2_spdmatrixcholeskydet(@_s_error_msg, @_d_result, @_d_a, @_d_n, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixcholeskydet call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function spdmatrixcholeskydet( a: TMatrix;  n: TALGLIBInteger; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_spdmatrixcholeskydet(a, n, _xparams);
end;


function spdmatrixcholeskydet( a: TMatrix; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;

begin
    if ((xrows(a)<>xcols(a))) then
    raise Exception.Create('Error while calling spdmatrixcholeskydet: looks like one of arguments has wrong size');

    n := xrows(a);

    Result := _core_spdmatrixcholeskydet(a, n, _xparams);

end;


function _core_spdmatrixdet( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; _xparams: UInt64):Double;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Double;
    _d_a: x_matrix;
    _d_n: NativeInt;
    _d_isupper: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        _error_code := x_xv2_spdmatrixdet(@_s_error_msg, @_d_result, @_d_a, @_d_n, @_d_isupper, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during spdmatrixdet call');
        end;
        result := _d_result;
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
    end;
end;


function spdmatrixdet( a: TMatrix;  n: TALGLIBInteger;  isupper: Boolean; const _xparams: UInt64 = 0):Double;overload;
begin
    Result := _core_spdmatrixdet(a, n, isupper, _xparams);
end;


function spdmatrixdet( a: TMatrix; const _xparams: UInt64 = 0):Double;overload;
var
    n: TALGLIBInteger;
    isupper: Boolean;

begin
    if not xissymmetric(a) then
        raise Exception.Create('a parameter is not symmetric matrix');
    if ((xrows(a)<>xcols(a))) then
    raise Exception.Create('Error while calling spdmatrixdet: looks like one of arguments has wrong size');

    n := xrows(a);
    isupper := False;

    Result := _core_spdmatrixdet(a, n, isupper, _xparams);

end;

function Clone(const Src: Tpolynomialsolverreport):Tpolynomialsolverreport;overload;
begin
    Result.maxerr := src.maxerr;
end;

procedure x_polynomialsolverreport_init(var x: x_polynomialsolverreport);
begin
    x.maxerr := 0;
end;

procedure x_polynomialsolverreport_clear(var x: x_polynomialsolverreport);
begin
end;

procedure x_polynomialsolverreport_init_from(var x: x_polynomialsolverreport; const v: Tpolynomialsolverreport);
begin
    x.maxerr := v.maxerr;
end;

procedure x_polynomialsolverreport_to_record(const x: x_polynomialsolverreport; var v: Tpolynomialsolverreport);
begin
    v.maxerr := x.maxerr;
end;


procedure _core_polynomialsolve( a: TVector;  n: TALGLIBInteger; out  x: TCVector; out  rep: Tpolynomialsolverreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a: x_vector;
    _d_n: NativeInt;
    _d_x: x_vector;
    _d_rep: x_polynomialsolverreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        x_from_array(_d_a, a, X_CREATE);
        _d_n := n;
        x_create_empty(_d_x, DT_COMPLEX);
        x := nil;
        x_polynomialsolverreport_init(_d_rep);
        _error_code := x_xv2_polynomialsolve(@_s_error_msg, @_d_a, @_d_n, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during polynomialsolve call');
        end;
        x_to_array(_d_x, x);
        x_polynomialsolverreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_a);
        x_clear(_d_x);
        x_polynomialsolverreport_clear(_d_rep);
    end;
end;


procedure polynomialsolve( a: TVector;  n: TALGLIBInteger; out  x: TCVector; out  rep: Tpolynomialsolverreport; const _xparams: UInt64 = 0);
begin
    _core_polynomialsolve(a, n, x, rep, _xparams);
end;

constructor Tnleqstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tnleqstate.Destroy();
begin
    Deallocate();
end;

function Tnleqstate.Clone():Tnleqstate;
begin
    if ptr=nil then
        Result:=Tnleqstate.Create(nil)
    else
        Result:=Tnleqstate.Create(x_obj_copy_nleqstate(ptr));
end;

procedure Tnleqstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_nleqstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tnleqreport):Tnleqreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nfunc := src.nfunc;
    Result.njac := src.njac;
    Result.terminationtype := src.terminationtype;
end;

procedure x_nleqreport_init(var x: x_nleqreport);
begin
    x.iterationscount.longval := 0;
    x.nfunc.longval := 0;
    x.njac.longval := 0;
    x.terminationtype.longval := 0;
end;

procedure x_nleqreport_clear(var x: x_nleqreport);
begin
end;

procedure x_nleqreport_init_from(var x: x_nleqreport; const v: Tnleqreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nfunc.longval := v.nfunc;
    x.njac.longval := v.njac;
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_nleqreport_to_record(const x: x_nleqreport; var v: Tnleqreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nfunc := x.nfunc.val; // long is silently truncated to TALGLIBInteger
    v.njac := x.njac.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_nleqcreatelm( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tnleqstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_m: NativeInt;
    _d_x: x_vector;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_m := m;
        x_from_array(_d_x, x, X_CREATE);
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_nleqcreatelm(@_s_error_msg, @_d_n, @_d_m, @_d_x, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqcreatelm call');
        end;
        state := Tnleqstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_nleqstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure nleqcreatelm( n: TALGLIBInteger;  m: TALGLIBInteger;  x: TVector; out  state: Tnleqstate; const _xparams: UInt64 = 0);overload;
begin
    _core_nleqcreatelm(n, m, x, state, _xparams);
end;


procedure nleqcreatelm( m: TALGLIBInteger;  x: TVector; out  state: Tnleqstate; const _xparams: UInt64 = 0);overload;
var
    n: TALGLIBInteger;

begin

    n := xlen(x);

    _core_nleqcreatelm(n, m, x, state, _xparams);

end;


procedure _core_nleqsetcond( state: Tnleqstate;  epsf: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsf: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsf := epsf;
        _d_maxits := maxits;
        _error_code := x_xv2_nleqsetcond(@_s_error_msg, @_d_state, @_d_epsf, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure nleqsetcond( state: Tnleqstate;  epsf: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_nleqsetcond(state, epsf, maxits, _xparams);
end;


procedure _core_nleqsetxrep( state: Tnleqstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_nleqsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure nleqsetxrep( state: Tnleqstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_nleqsetxrep(state, needxrep, _xparams);
end;


procedure _core_nleqsetstpmax( state: Tnleqstate;  stpmax: Double; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_stpmax: Double;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_stpmax := stpmax;
        _error_code := x_xv2_nleqsetstpmax(@_s_error_msg, @_d_state, @_d_stpmax, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqsetstpmax call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure nleqsetstpmax( state: Tnleqstate;  stpmax: Double; const _xparams: UInt64 = 0);
begin
    _core_nleqsetstpmax(state, stpmax, _xparams);
end;


function _core_nleqiteration( state: Tnleqstate; _xparams: UInt64):Boolean;
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_result: Byte;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_nleqiteration(@_s_error_msg, @_d_result, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqiteration call');
        end;
        result := Byte2Bool(_d_result);
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


function nleqiteration( state: Tnleqstate; const _xparams: UInt64 = 0):Boolean;
begin
    Result := _core_nleqiteration(state, _xparams);
end;

procedure nleqsolve(state: Tnleqstate; func: Tndimensional_func; jac:  Tndimensional_jac; rep: Tndimensional_rep; obj: Pointer; _xparams: UInt64 = 0);overload;
var
    _s_error_msg: PAnsiChar;
    _error_code: Int32T;
    _b_result: Byte;
    _xc_xupdated: Byte;
    _local_f: Double;
    _state: Pointer;
    _xc_arg: x_vector;
    _pas_arg: TVector;
    _pas_f: Double;
    _xc_fi: x_vector;
    _pas_fi: TVector;
    _xc_j: x_matrix;
    _pas_j: TMatrix;
    _xc_needf: Byte;
    _xc_needfij: Byte;
begin
    _s_error_msg:=nil;
    _b_result:=0;
    _xc_xupdated:=0;
    _state:=state.ptr;

    //
    // Check correctness of function pointers
    //
    if @func=nil then
        raise Exception.Create('ALGLIB: error in nleqsolve() (func is nil)');
    if @jac=nil then
        raise Exception.Create('ALGLIB: error in nleqsolve() (jac is nil)');

    //
    // Attach x-structures to internal arrays
    //
    x_create_empty(_xc_arg, DT_REAL);
    x_create_empty(_xc_fi, DT_REAL);
    x_create_empty(_xc_j, DT_REAL);
    x_nleqstate_get_x(_state, @_xc_arg);
    x_nleqstate_get_fi(_state, @_xc_fi);
    x_nleqstate_get_j(_state, @_xc_j);
    SetLength(_pas_arg, _xc_arg.cnt);
    _pas_f:=0;
    SetLength(_pas_fi, _xc_fi.cnt);
    SetLength(_pas_j, _xc_j.rows, _xc_j.cols);

    //
    // Main loop
    //
    while True do
    begin
        //
        // Call iteration function.
        // Terminate iterations if it returned false.
        //
        _error_code := x_xv2_nleqiteration(@_s_error_msg, @_b_result, @_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqiteration call');
        end;
        Assert(_state=state.ptr, 'ALGLIB: internal error (reference changed for non-out X-object)');
        if _b_result=0 then
            Break;
        
        //
        // Reverse communication interface:
        // * fetch flags
        // * call callbacks
        //
        x_nleqstate_get_xupdated(_state, @_xc_xupdated);
        x_nleqstate_get_needf(_state, @_xc_needf);
        x_nleqstate_get_needfij(_state, @_xc_needfij);
        x_to_array(_xc_arg, _pas_arg);
        if _xc_needf<>0 then
        begin
            func(_pas_arg, _pas_f, obj);
            x_nleqstate_set_f(_state, @_pas_f);
            Continue;
        end;
        if _xc_needfij<>0 then
        begin
            jac(_pas_arg, _pas_fi, _pas_j, obj);
            x_from_array(_xc_fi, _pas_fi, X_REWRITE);
            x_from_array(_xc_j,  _pas_j,  X_REWRITE);
            Continue;
        end;
        if _xc_xupdated<>0 then
        begin
            if @rep<>nil then
            begin
                x_nleqstate_get_f(_state, @_local_f);
                rep(_pas_arg, _local_f, obj);
            end;
            Continue;
        end;
        raise Exception.Create('ALGLIB: error in nleqsolve (some derivatives were not provided?)');
    end;
end;


procedure _core_nleqresults( state: Tnleqstate; out  x: TVector; out  rep: Tnleqreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_nleqreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_nleqreport_init(_d_rep);
        _error_code := x_xv2_nleqresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_nleqreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_nleqreport_clear(_d_rep);
    end;
end;


procedure nleqresults( state: Tnleqstate; out  x: TVector; out  rep: Tnleqreport; const _xparams: UInt64 = 0);
begin
    _core_nleqresults(state, x, rep, _xparams);
end;


procedure _core_nleqresultsbuf( state: Tnleqstate; var  x: TVector;  rep: Tnleqreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_nleqreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        x_nleqreport_init_from(_d_rep, rep);
        _error_code := x_xv2_nleqresultsbuf(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqresultsbuf call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_nleqreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_nleqreport_clear(_d_rep);
    end;
end;


procedure nleqresultsbuf( state: Tnleqstate; var  x: TVector;  rep: Tnleqreport; const _xparams: UInt64 = 0);
begin
    _core_nleqresultsbuf(state, x, rep, _xparams);
end;


procedure _core_nleqrestartfrom( state: Tnleqstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_nleqrestartfrom(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during nleqrestartfrom call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure nleqrestartfrom( state: Tnleqstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_nleqrestartfrom(state, x, _xparams);
end;

function Clone(const Src: Tsparsesolverreport):Tsparsesolverreport;overload;
begin
    Result.terminationtype := src.terminationtype;
end;

procedure x_sparsesolverreport_init(var x: x_sparsesolverreport);
begin
    x.terminationtype.longval := 0;
end;

procedure x_sparsesolverreport_clear(var x: x_sparsesolverreport);
begin
end;

procedure x_sparsesolverreport_init_from(var x: x_sparsesolverreport; const v: Tsparsesolverreport);
begin
    x.terminationtype.longval := v.terminationtype;
end;

procedure x_sparsesolverreport_to_record(const x: x_sparsesolverreport; var v: Tsparsesolverreport);
begin
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
end;


procedure _core_sparsesolvesks( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  rep: Tsparsesolverreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a : Pointer;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_rep: x_sparsesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a.ptr;
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        x_sparsesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_sparsesolvesks(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsesolvesks call');
        end;
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_sparsesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_b);
        x_sparsesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure sparsesolvesks( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  rep: Tsparsesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsesolvesks(a, n, isupper, b, rep, x, _xparams);
end;


procedure _core_sparsecholeskysolvesks( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  rep: Tsparsesolverreport; out  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a : Pointer;
    _d_n: NativeInt;
    _d_isupper: Byte;
    _d_b: x_vector;
    _d_rep: x_sparsesolverreport;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a.ptr;
        _d_n := n;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        x_sparsesolverreport_init(_d_rep);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        _error_code := x_xv2_sparsecholeskysolvesks(@_s_error_msg, @_d_a, @_d_n, @_d_isupper, @_d_b, @_d_rep, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsecholeskysolvesks call');
        end;
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_sparsesolverreport_to_record(_d_rep, rep);
        x_to_array(_d_x, x);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_b);
        x_sparsesolverreport_clear(_d_rep);
        x_clear(_d_x);
    end;
end;


procedure sparsecholeskysolvesks( a: Tsparsematrix;  n: TALGLIBInteger;  isupper: Boolean;  b: TVector; out  rep: Tsparsesolverreport; out  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_sparsecholeskysolvesks(a, n, isupper, b, rep, x, _xparams);
end;


procedure _core_sparsesolve( a: Tsparsematrix;  n: TALGLIBInteger;  b: TVector; out  x: TVector; out  rep: Tsparsesolverreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a : Pointer;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_x: x_vector;
    _d_rep: x_sparsesolverreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a.ptr;
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_sparsesolverreport_init(_d_rep);
        _error_code := x_xv2_sparsesolve(@_s_error_msg, @_d_a, @_d_n, @_d_b, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparsesolve call');
        end;
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_sparsesolverreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_b);
        x_clear(_d_x);
        x_sparsesolverreport_clear(_d_rep);
    end;
end;


procedure sparsesolve( a: Tsparsematrix;  n: TALGLIBInteger;  b: TVector; out  x: TVector; out  rep: Tsparsesolverreport; const _xparams: UInt64 = 0);
begin
    _core_sparsesolve(a, n, b, x, rep, _xparams);
end;


procedure _core_sparselusolve( a: Tsparsematrix;  p: TIVector;  q: TIVector;  n: TALGLIBInteger;  b: TVector; out  x: TVector; out  rep: Tsparsesolverreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_a : Pointer;
    _d_p: x_vector;
    _d_q: x_vector;
    _d_n: NativeInt;
    _d_b: x_vector;
    _d_x: x_vector;
    _d_rep: x_sparsesolverreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_a := a.ptr;
        x_from_array(_d_p, p, X_CREATE);
        x_from_array(_d_q, q, X_CREATE);
        _d_n := n;
        x_from_array(_d_b, b, X_CREATE);
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_sparsesolverreport_init(_d_rep);
        _error_code := x_xv2_sparselusolve(@_s_error_msg, @_d_a, @_d_p, @_d_q, @_d_n, @_d_b, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during sparselusolve call');
        end;
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_sparsesolverreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_p);
        x_clear(_d_q);
        x_clear(_d_b);
        x_clear(_d_x);
        x_sparsesolverreport_clear(_d_rep);
    end;
end;


procedure sparselusolve( a: Tsparsematrix;  p: TIVector;  q: TIVector;  n: TALGLIBInteger;  b: TVector; out  x: TVector; out  rep: Tsparsesolverreport; const _xparams: UInt64 = 0);
begin
    _core_sparselusolve(a, p, q, n, b, x, rep, _xparams);
end;

constructor Tlincgstate.Create(x_obj: Pointer);
begin
    ptr:=x_obj;
end;

destructor Tlincgstate.Destroy();
begin
    Deallocate();
end;

function Tlincgstate.Clone():Tlincgstate;
begin
    if ptr=nil then
        Result:=Tlincgstate.Create(nil)
    else
        Result:=Tlincgstate.Create(x_obj_copy_lincgstate(ptr));
end;

procedure Tlincgstate.Deallocate();
begin
    if ptr<>nil then
        x_obj_free_lincgstate(ptr);
    ptr:=nil;
end;

function Clone(const Src: Tlincgreport):Tlincgreport;overload;
begin
    Result.iterationscount := src.iterationscount;
    Result.nmv := src.nmv;
    Result.terminationtype := src.terminationtype;
    Result.r2 := src.r2;
end;

procedure x_lincgreport_init(var x: x_lincgreport);
begin
    x.iterationscount.longval := 0;
    x.nmv.longval := 0;
    x.terminationtype.longval := 0;
    x.r2 := 0;
end;

procedure x_lincgreport_clear(var x: x_lincgreport);
begin
end;

procedure x_lincgreport_init_from(var x: x_lincgreport; const v: Tlincgreport);
begin
    x.iterationscount.longval := v.iterationscount;
    x.nmv.longval := v.nmv;
    x.terminationtype.longval := v.terminationtype;
    x.r2 := v.r2;
end;

procedure x_lincgreport_to_record(const x: x_lincgreport; var v: Tlincgreport);
begin
    v.iterationscount := x.iterationscount.val; // long is silently truncated to TALGLIBInteger
    v.nmv := x.nmv.val; // long is silently truncated to TALGLIBInteger
    v.terminationtype := x.terminationtype.val; // long is silently truncated to TALGLIBInteger
    v.r2 := x.r2;
end;


procedure _core_lincgcreate( n: TALGLIBInteger; out  state: Tlincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_n: NativeInt;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_n := n;
        _d_state := nil;
        state := nil;
        _error_code := x_xv2_lincgcreate(@_s_error_msg, @_d_n, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgcreate call');
        end;
        state := Tlincgstate.Create(_d_state);
    finally
        SetXExceptionMask(fpumask);
        if (_d_state<>nil) and (state=nil) then
            x_obj_free_lincgstate(_d_state); // on exception clean up X objects which were not attached to Delphi objects
    end;
end;


procedure lincgcreate( n: TALGLIBInteger; out  state: Tlincgstate; const _xparams: UInt64 = 0);
begin
    _core_lincgcreate(n, state, _xparams);
end;


procedure _core_lincgsetstartingpoint( state: Tlincgstate;  x: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_from_array(_d_x, x, X_CREATE);
        _error_code := x_xv2_lincgsetstartingpoint(@_s_error_msg, @_d_state, @_d_x, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsetstartingpoint call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
    end;
end;


procedure lincgsetstartingpoint( state: Tlincgstate;  x: TVector; const _xparams: UInt64 = 0);
begin
    _core_lincgsetstartingpoint(state, x, _xparams);
end;


procedure _core_lincgsetprecunit( state: Tlincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_lincgsetprecunit(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsetprecunit call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lincgsetprecunit( state: Tlincgstate; const _xparams: UInt64 = 0);
begin
    _core_lincgsetprecunit(state, _xparams);
end;


procedure _core_lincgsetprecdiag( state: Tlincgstate; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _error_code := x_xv2_lincgsetprecdiag(@_s_error_msg, @_d_state, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsetprecdiag call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lincgsetprecdiag( state: Tlincgstate; const _xparams: UInt64 = 0);
begin
    _core_lincgsetprecdiag(state, _xparams);
end;


procedure _core_lincgsetcond( state: Tlincgstate;  epsf: Double;  maxits: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_epsf: Double;
    _d_maxits: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_epsf := epsf;
        _d_maxits := maxits;
        _error_code := x_xv2_lincgsetcond(@_s_error_msg, @_d_state, @_d_epsf, @_d_maxits, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsetcond call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lincgsetcond( state: Tlincgstate;  epsf: Double;  maxits: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_lincgsetcond(state, epsf, maxits, _xparams);
end;


procedure _core_lincgsolvesparse( state: Tlincgstate;  a: Tsparsematrix;  isupper: Boolean;  b: TVector; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_a : Pointer;
    _d_isupper: Byte;
    _d_b: x_vector;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_a := a.ptr;
        _d_isupper := Bool2Byte(isupper);
        x_from_array(_d_b, b, X_CREATE);
        _error_code := x_xv2_lincgsolvesparse(@_s_error_msg, @_d_state, @_d_a, @_d_isupper, @_d_b, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsolvesparse call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        Assert(a.ptr=_d_a, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_b);
    end;
end;


procedure lincgsolvesparse( state: Tlincgstate;  a: Tsparsematrix;  isupper: Boolean;  b: TVector; const _xparams: UInt64 = 0);
begin
    _core_lincgsolvesparse(state, a, isupper, b, _xparams);
end;


procedure _core_lincgresults( state: Tlincgstate; out  x: TVector; out  rep: Tlincgreport; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_x: x_vector;
    _d_rep: x_lincgreport;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        x_create_empty(_d_x, DT_REAL);
        x := nil;
        x_lincgreport_init(_d_rep);
        _error_code := x_xv2_lincgresults(@_s_error_msg, @_d_state, @_d_x, @_d_rep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgresults call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
        x_to_array(_d_x, x);
        x_lincgreport_to_record(_d_rep, rep);
    finally
        SetXExceptionMask(fpumask);
        x_clear(_d_x);
        x_lincgreport_clear(_d_rep);
    end;
end;


procedure lincgresults( state: Tlincgstate; out  x: TVector; out  rep: Tlincgreport; const _xparams: UInt64 = 0);
begin
    _core_lincgresults(state, x, rep, _xparams);
end;


procedure _core_lincgsetrestartfreq( state: Tlincgstate;  srf: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_srf: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_srf := srf;
        _error_code := x_xv2_lincgsetrestartfreq(@_s_error_msg, @_d_state, @_d_srf, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsetrestartfreq call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lincgsetrestartfreq( state: Tlincgstate;  srf: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_lincgsetrestartfreq(state, srf, _xparams);
end;


procedure _core_lincgsetrupdatefreq( state: Tlincgstate;  freq: TALGLIBInteger; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_freq: NativeInt;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_freq := freq;
        _error_code := x_xv2_lincgsetrupdatefreq(@_s_error_msg, @_d_state, @_d_freq, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsetrupdatefreq call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lincgsetrupdatefreq( state: Tlincgstate;  freq: TALGLIBInteger; const _xparams: UInt64 = 0);
begin
    _core_lincgsetrupdatefreq(state, freq, _xparams);
end;


procedure _core_lincgsetxrep( state: Tlincgstate;  needxrep: Boolean; _xparams: UInt64);
var
    _s_error_msg:PAnsiChar;
    _error_code: Int32T;
    fpumask: XExceptionMask;
    _d_state : Pointer;
    _d_needxrep: Byte;
begin
    _s_error_msg := nil;
    
    // Pack, call, unpack
    fpumask:=SetXExceptionMask(xMaskAllExceptions);
    try
        _d_state := state.ptr;
        _d_needxrep := Bool2Byte(needxrep);
        _error_code := x_xv2_lincgsetxrep(@_s_error_msg, @_d_state, @_d_needxrep, _xparams);
        if _error_code<>X_OK then
        begin
            if _error_code=X_ASSERTION_FAILED then
                raise Exception.Create(string(_s_error_msg))
            else
                raise Exception.Create('ALGLIB: unknown error during lincgsetxrep call');
        end;
        Assert(state.ptr=_d_state, 'ALGLIB: internal error (reference changed for non-out X-object)');
    finally
        SetXExceptionMask(fpumask);
        // No dynamically allocated data to clear
    end;
end;


procedure lincgsetxrep( state: Tlincgstate;  needxrep: Boolean; const _xparams: UInt64 = 0);
begin
    _core_lincgsetxrep(state, needxrep, _xparams);
end;


initialization
{$IFDEF FPC}
    XDecimalSeparator:=DefaultFormatSettings.DecimalSeparator;
{$ELSE}
    XDefFS:=TFormatSettings.Create;
    XDecimalSeparator:=AnsiChar(XDefFS.DecimalSeparator);
{$ENDIF}
    _shared_lib_filename := 'alglib316_'+IntToStr(SizeOf(NativeInt)*8)+'free'+PlatformLibSuffix;

    //
    // Try loading ALGLIB shared lib from application dir (default option)
    //
    _shared_lib_name:=ExpandFileName(ExtractFilePath(ParamStr(0))+_shared_lib_filename);
    _lib_alglib:=XLoadLibrary(_shared_lib_name);

{$IFDEF MSWINDOWS}
    //
    // Failed to load from app dir?
    // Try loading from Windows system directories
    //
    if _lib_alglib=0 then
        if GetWindowsDirectory(WindowsPath, MaxSystemPathLen)>0 then
        begin
            //
            // First, try loading from system32 dir
            //
            _shared_lib_name:=XStringType(WindowsPath)+PathSeparator+'system32'+PathSeparator+_shared_lib_filename;
            _lib_alglib:=XLoadLibrary(_shared_lib_name);

            //
            // Second, try loading from SysWOW64 dir
            //
            if _lib_alglib=0 then
            begin
                _shared_lib_name:=XStringType(WindowsPath)+PathSeparator+'syswow64'+PathSeparator+_shared_lib_filename;
                _lib_alglib:=XLoadLibrary(_shared_lib_name);
            end;
        end;
{$ENDIF}

    //
    // Failed to load ALGLIB shared lib
    //
    if _lib_alglib=0 then
        raise Exception.Create('ALGLIB: unable to load shared library');

    //
    // Load service functions
    //
    XActivateCoreFunc           := TXActivateCoreFunc(XGetProcAddress(_lib_alglib, 'x_activate_core'));
    XMallocFunc                 := TXMallocFunc(XGetProcAddress(_lib_alglib, 'x_malloc'));
    XFreeFunc                   := TXFreeFunc(XGetProcAddress(_lib_alglib, 'x_free'));
    XSetNWorkersFunc            := TXSetNWorkersFunc(XGetProcAddress(_lib_alglib, 'x_setnworkers'));
    XSetDbgFlag                 := TXSetDbgFlag(XGetProcAddress(_lib_alglib, 'x_set_dbg_flag'));
    XGetDbgValue                := TXGetDbgValue(XGetProcAddress(_lib_alglib, 'x_get_dbg_value'));
    XAllocCounterFunc           := TXAllocCounterFunc(XGetProcAddress(_lib_alglib, 'x_alloc_counter'));
    XAllocCounterActivateFunc   := TXAllocCounterActivateFunc(XGetProcAddress(_lib_alglib, 'x_alloc_counter_activate'));
    XFreeDisposedItemsFunc      := TXFreeDisposedItemsFunc(XGetProcAddress(_lib_alglib, 'x_free_disposed_items'));
    
    //
    // Activate core
    //
    XActivateCoreFunc();
    
    //
    // Load ALGLIB functions
    //
    x_obj_copy_kdtreerequestbuffer := Tx_obj_copy_kdtreerequestbuffer(XGetProcAddress(_lib_alglib, 'x_obj_copy_kdtreerequestbuffer'));
    x_obj_free_kdtreerequestbuffer := Tx_obj_free_kdtreerequestbuffer(XGetProcAddress(_lib_alglib, 'x_obj_free_kdtreerequestbuffer'));
    x_obj_copy_kdtree := Tx_obj_copy_kdtree(XGetProcAddress(_lib_alglib, 'x_obj_copy_kdtree'));
    x_obj_free_kdtree := Tx_obj_free_kdtree(XGetProcAddress(_lib_alglib, 'x_obj_free_kdtree'));
    x_kdtreeserialize := Tkdtreeserialize(  XGetProcAddress(_lib_alglib, 'alglib_kdtreeserialize'));
    x_kdtreeunserialize := Tkdtreeunserialize(XGetProcAddress(_lib_alglib, 'alglib_kdtreeunserialize'));
    x_kdtreeserialize_stream := Tkdtreeserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_kdtreeserialize_stream'));
    x_kdtreeunserialize_stream := Tkdtreeunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_kdtreeunserialize_stream'));
    x_xv2_kdtreebuild := Tkdtreebuild(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreebuild'));
    x_xv2_kdtreebuildtagged := Tkdtreebuildtagged(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreebuildtagged'));
    x_xv2_kdtreecreaterequestbuffer := Tkdtreecreaterequestbuffer(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreecreaterequestbuffer'));
    x_xv2_kdtreequeryknn := Tkdtreequeryknn(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryknn'));
    x_xv2_kdtreetsqueryknn := Tkdtreetsqueryknn(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryknn'));
    x_xv2_kdtreequeryrnn := Tkdtreequeryrnn(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryrnn'));
    x_xv2_kdtreequeryrnnu := Tkdtreequeryrnnu(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryrnnu'));
    x_xv2_kdtreetsqueryrnn := Tkdtreetsqueryrnn(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryrnn'));
    x_xv2_kdtreetsqueryrnnu := Tkdtreetsqueryrnnu(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryrnnu'));
    x_xv2_kdtreequeryaknn := Tkdtreequeryaknn(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryaknn'));
    x_xv2_kdtreetsqueryaknn := Tkdtreetsqueryaknn(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryaknn'));
    x_xv2_kdtreequerybox := Tkdtreequerybox(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequerybox'));
    x_xv2_kdtreetsquerybox := Tkdtreetsquerybox(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsquerybox'));
    x_xv2_kdtreequeryresultsx := Tkdtreequeryresultsx(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultsx'));
    x_xv2_kdtreequeryresultsxy := Tkdtreequeryresultsxy(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultsxy'));
    x_xv2_kdtreequeryresultstags := Tkdtreequeryresultstags(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultstags'));
    x_xv2_kdtreequeryresultsdistances := Tkdtreequeryresultsdistances(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultsdistances'));
    x_xv2_kdtreetsqueryresultsx := Tkdtreetsqueryresultsx(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryresultsx'));
    x_xv2_kdtreetsqueryresultsxy := Tkdtreetsqueryresultsxy(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryresultsxy'));
    x_xv2_kdtreetsqueryresultstags := Tkdtreetsqueryresultstags(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryresultstags'));
    x_xv2_kdtreetsqueryresultsdistances := Tkdtreetsqueryresultsdistances(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreetsqueryresultsdistances'));
    x_xv2_kdtreequeryresultsxi := Tkdtreequeryresultsxi(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultsxi'));
    x_xv2_kdtreequeryresultsxyi := Tkdtreequeryresultsxyi(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultsxyi'));
    x_xv2_kdtreequeryresultstagsi := Tkdtreequeryresultstagsi(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultstagsi'));
    x_xv2_kdtreequeryresultsdistancesi := Tkdtreequeryresultsdistancesi(XGetProcAddress(_lib_alglib, 'alglib_xv2_kdtreequeryresultsdistancesi'));
    x_obj_copy_hqrndstate := Tx_obj_copy_hqrndstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_hqrndstate'));
    x_obj_free_hqrndstate := Tx_obj_free_hqrndstate(XGetProcAddress(_lib_alglib, 'x_obj_free_hqrndstate'));
    x_xv2_hqrndrandomize := Thqrndrandomize(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrndrandomize'));
    x_xv2_hqrndseed := Thqrndseed(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrndseed'));
    x_xv2_hqrnduniformr := Thqrnduniformr(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrnduniformr'));
    x_xv2_hqrnduniformi := Thqrnduniformi(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrnduniformi'));
    x_xv2_hqrndnormal := Thqrndnormal(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrndnormal'));
    x_xv2_hqrndunit2 := Thqrndunit2(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrndunit2'));
    x_xv2_hqrndnormal2 := Thqrndnormal2(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrndnormal2'));
    x_xv2_hqrndexponential := Thqrndexponential(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrndexponential'));
    x_xv2_hqrnddiscrete := Thqrnddiscrete(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrnddiscrete'));
    x_xv2_hqrndcontinuous := Thqrndcontinuous(XGetProcAddress(_lib_alglib, 'alglib_xv2_hqrndcontinuous'));
    x_xv2_xdebuginitrecord1 := Txdebuginitrecord1(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebuginitrecord1'));
    x_xv2_xdebugb1count := Txdebugb1count(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb1count'));
    x_xv2_xdebugb1not := Txdebugb1not(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb1not'));
    x_xv2_xdebugb1appendcopy := Txdebugb1appendcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb1appendcopy'));
    x_xv2_xdebugb1outeven := Txdebugb1outeven(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb1outeven'));
    x_xv2_xdebugi1sum := Txdebugi1sum(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi1sum'));
    x_xv2_xdebugi1neg := Txdebugi1neg(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi1neg'));
    x_xv2_xdebugi1appendcopy := Txdebugi1appendcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi1appendcopy'));
    x_xv2_xdebugi1outeven := Txdebugi1outeven(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi1outeven'));
    x_xv2_xdebugr1sum := Txdebugr1sum(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr1sum'));
    x_xv2_xdebugr1neg := Txdebugr1neg(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr1neg'));
    x_xv2_xdebugr1appendcopy := Txdebugr1appendcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr1appendcopy'));
    x_xv2_xdebugr1outeven := Txdebugr1outeven(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr1outeven'));
    x_xv2_xdebugc1sum := Txdebugc1sum(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc1sum'));
    x_xv2_xdebugc1neg := Txdebugc1neg(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc1neg'));
    x_xv2_xdebugc1appendcopy := Txdebugc1appendcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc1appendcopy'));
    x_xv2_xdebugc1outeven := Txdebugc1outeven(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc1outeven'));
    x_xv2_xdebugb2count := Txdebugb2count(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb2count'));
    x_xv2_xdebugb2not := Txdebugb2not(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb2not'));
    x_xv2_xdebugb2transpose := Txdebugb2transpose(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb2transpose'));
    x_xv2_xdebugb2outsin := Txdebugb2outsin(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugb2outsin'));
    x_xv2_xdebugi2sum := Txdebugi2sum(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi2sum'));
    x_xv2_xdebugi2neg := Txdebugi2neg(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi2neg'));
    x_xv2_xdebugi2transpose := Txdebugi2transpose(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi2transpose'));
    x_xv2_xdebugi2outsin := Txdebugi2outsin(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugi2outsin'));
    x_xv2_xdebugr2sum := Txdebugr2sum(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr2sum'));
    x_xv2_xdebugr2neg := Txdebugr2neg(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr2neg'));
    x_xv2_xdebugr2transpose := Txdebugr2transpose(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr2transpose'));
    x_xv2_xdebugr2outsin := Txdebugr2outsin(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugr2outsin'));
    x_xv2_xdebugc2sum := Txdebugc2sum(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc2sum'));
    x_xv2_xdebugc2neg := Txdebugc2neg(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc2neg'));
    x_xv2_xdebugc2transpose := Txdebugc2transpose(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc2transpose'));
    x_xv2_xdebugc2outsincos := Txdebugc2outsincos(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugc2outsincos'));
    x_xv2_xdebugmaskedbiasedproductsum := Txdebugmaskedbiasedproductsum(XGetProcAddress(_lib_alglib, 'alglib_xv2_xdebugmaskedbiasedproductsum'));
    x_obj_copy_odesolverstate := Tx_obj_copy_odesolverstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_odesolverstate'));
    x_obj_free_odesolverstate := Tx_obj_free_odesolverstate(XGetProcAddress(_lib_alglib, 'x_obj_free_odesolverstate'));
    x_odesolverstate_get_needdy := Tx_odesolverstate_get_needdy(XGetProcAddress(_lib_alglib, 'x_odesolverstate_get_needdy'));
    Touch(x_odesolverstate_get_needdy); // avoid messages about unused variables
    x_odesolverstate_set_needdy := Tx_odesolverstate_set_needdy(XGetProcAddress(_lib_alglib, 'x_odesolverstate_set_needdy'));
    Touch(x_odesolverstate_set_needdy);
    x_odesolverstate_get_y := Tx_odesolverstate_get_y(XGetProcAddress(_lib_alglib, 'x_odesolverstate_get_y'));
    Touch(x_odesolverstate_get_y); // avoid messages about unused variables
    x_odesolverstate_get_dy := Tx_odesolverstate_get_dy(XGetProcAddress(_lib_alglib, 'x_odesolverstate_get_dy'));
    Touch(x_odesolverstate_get_dy); // avoid messages about unused variables
    x_odesolverstate_get_x := Tx_odesolverstate_get_x(XGetProcAddress(_lib_alglib, 'x_odesolverstate_get_x'));
    Touch(x_odesolverstate_get_x); // avoid messages about unused variables
    x_odesolverstate_set_x := Tx_odesolverstate_set_x(XGetProcAddress(_lib_alglib, 'x_odesolverstate_set_x'));
    Touch(x_odesolverstate_set_x);
    x_xv2_odesolverrkck := Todesolverrkck(XGetProcAddress(_lib_alglib, 'alglib_xv2_odesolverrkck'));
    x_xv2_odesolveriteration := Todesolveriteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_odesolveriteration'));
    x_xv2_odesolverresults := Todesolverresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_odesolverresults'));
    x_obj_copy_sparsematrix := Tx_obj_copy_sparsematrix(XGetProcAddress(_lib_alglib, 'x_obj_copy_sparsematrix'));
    x_obj_free_sparsematrix := Tx_obj_free_sparsematrix(XGetProcAddress(_lib_alglib, 'x_obj_free_sparsematrix'));
    x_obj_copy_sparsebuffers := Tx_obj_copy_sparsebuffers(XGetProcAddress(_lib_alglib, 'x_obj_copy_sparsebuffers'));
    x_obj_free_sparsebuffers := Tx_obj_free_sparsebuffers(XGetProcAddress(_lib_alglib, 'x_obj_free_sparsebuffers'));
    x_xv2_sparsecreate := Tsparsecreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreate'));
    x_xv2_sparsecreatebuf := Tsparsecreatebuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreatebuf'));
    x_xv2_sparsecreatecrs := Tsparsecreatecrs(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreatecrs'));
    x_xv2_sparsecreatecrsbuf := Tsparsecreatecrsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreatecrsbuf'));
    x_xv2_sparsecreatesks := Tsparsecreatesks(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreatesks'));
    x_xv2_sparsecreatesksbuf := Tsparsecreatesksbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreatesksbuf'));
    x_xv2_sparsecreatesksband := Tsparsecreatesksband(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreatesksband'));
    x_xv2_sparsecreatesksbandbuf := Tsparsecreatesksbandbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecreatesksbandbuf'));
    x_xv2_sparsecopy := Tsparsecopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopy'));
    x_xv2_sparsecopybuf := Tsparsecopybuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopybuf'));
    x_xv2_sparseswap := Tsparseswap(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseswap'));
    x_xv2_sparseadd := Tsparseadd(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseadd'));
    x_xv2_sparseset := Tsparseset(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseset'));
    x_xv2_sparseget := Tsparseget(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseget'));
    x_xv2_sparsegetdiagonal := Tsparsegetdiagonal(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetdiagonal'));
    x_xv2_sparsemv := Tsparsemv(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsemv'));
    x_xv2_sparsemtv := Tsparsemtv(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsemtv'));
    x_xv2_sparsegemv := Tsparsegemv(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegemv'));
    x_xv2_sparsemv2 := Tsparsemv2(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsemv2'));
    x_xv2_sparsesmv := Tsparsesmv(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsesmv'));
    x_xv2_sparsevsmv := Tsparsevsmv(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsevsmv'));
    x_xv2_sparsemm := Tsparsemm(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsemm'));
    x_xv2_sparsemtm := Tsparsemtm(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsemtm'));
    x_xv2_sparsemm2 := Tsparsemm2(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsemm2'));
    x_xv2_sparsesmm := Tsparsesmm(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsesmm'));
    x_xv2_sparsetrmv := Tsparsetrmv(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsetrmv'));
    x_xv2_sparsetrsv := Tsparsetrsv(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsetrsv'));
    x_xv2_sparseresizematrix := Tsparseresizematrix(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseresizematrix'));
    x_xv2_sparseenumerate := Tsparseenumerate(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseenumerate'));
    x_xv2_sparserewriteexisting := Tsparserewriteexisting(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparserewriteexisting'));
    x_xv2_sparsegetrow := Tsparsegetrow(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetrow'));
    x_xv2_sparsegetcompressedrow := Tsparsegetcompressedrow(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetcompressedrow'));
    x_xv2_sparsetransposesks := Tsparsetransposesks(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsetransposesks'));
    x_xv2_sparsetransposecrs := Tsparsetransposecrs(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsetransposecrs'));
    x_xv2_sparsecopytransposecrs := Tsparsecopytransposecrs(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytransposecrs'));
    x_xv2_sparsecopytransposecrsbuf := Tsparsecopytransposecrsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytransposecrsbuf'));
    x_xv2_sparseconvertto := Tsparseconvertto(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseconvertto'));
    x_xv2_sparsecopytobuf := Tsparsecopytobuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytobuf'));
    x_xv2_sparseconverttohash := Tsparseconverttohash(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseconverttohash'));
    x_xv2_sparsecopytohash := Tsparsecopytohash(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytohash'));
    x_xv2_sparsecopytohashbuf := Tsparsecopytohashbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytohashbuf'));
    x_xv2_sparseconverttocrs := Tsparseconverttocrs(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseconverttocrs'));
    x_xv2_sparsecopytocrs := Tsparsecopytocrs(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytocrs'));
    x_xv2_sparsecopytocrsbuf := Tsparsecopytocrsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytocrsbuf'));
    x_xv2_sparseconverttosks := Tsparseconverttosks(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseconverttosks'));
    x_xv2_sparsecopytosks := Tsparsecopytosks(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytosks'));
    x_xv2_sparsecopytosksbuf := Tsparsecopytosksbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecopytosksbuf'));
    x_xv2_sparsegetmatrixtype := Tsparsegetmatrixtype(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetmatrixtype'));
    x_xv2_sparseishash := Tsparseishash(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseishash'));
    x_xv2_sparseiscrs := Tsparseiscrs(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseiscrs'));
    x_xv2_sparseissks := Tsparseissks(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparseissks'));
    x_xv2_sparsefree := Tsparsefree(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsefree'));
    x_xv2_sparsegetnrows := Tsparsegetnrows(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetnrows'));
    x_xv2_sparsegetncols := Tsparsegetncols(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetncols'));
    x_xv2_sparsegetuppercount := Tsparsegetuppercount(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetuppercount'));
    x_xv2_sparsegetlowercount := Tsparsegetlowercount(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsegetlowercount'));
    x_xv2_cmatrixtranspose := Tcmatrixtranspose(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixtranspose'));
    x_xv2_rmatrixtranspose := Trmatrixtranspose(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixtranspose'));
    x_xv2_rmatrixenforcesymmetricity := Trmatrixenforcesymmetricity(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixenforcesymmetricity'));
    x_xv2_cmatrixcopy := Tcmatrixcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixcopy'));
    x_xv2_rvectorcopy := Trvectorcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_rvectorcopy'));
    x_xv2_rmatrixcopy := Trmatrixcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixcopy'));
    x_xv2_rmatrixgencopy := Trmatrixgencopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixgencopy'));
    x_xv2_rmatrixger := Trmatrixger(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixger'));
    x_xv2_cmatrixrank1 := Tcmatrixrank1(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrank1'));
    x_xv2_rmatrixrank1 := Trmatrixrank1(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrank1'));
    x_xv2_rmatrixgemv := Trmatrixgemv(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixgemv'));
    x_xv2_cmatrixmv := Tcmatrixmv(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixmv'));
    x_xv2_rmatrixmv := Trmatrixmv(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixmv'));
    x_xv2_rmatrixsymv := Trmatrixsymv(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsymv'));
    x_xv2_rmatrixsyvmv := Trmatrixsyvmv(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsyvmv'));
    x_xv2_rmatrixtrsv := Trmatrixtrsv(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixtrsv'));
    x_xv2_cmatrixrighttrsm := Tcmatrixrighttrsm(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrighttrsm'));
    x_xv2_cmatrixlefttrsm := Tcmatrixlefttrsm(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlefttrsm'));
    x_xv2_rmatrixrighttrsm := Trmatrixrighttrsm(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrighttrsm'));
    x_xv2_rmatrixlefttrsm := Trmatrixlefttrsm(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlefttrsm'));
    x_xv2_cmatrixherk := Tcmatrixherk(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixherk'));
    x_xv2_rmatrixsyrk := Trmatrixsyrk(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsyrk'));
    x_xv2_cmatrixgemm := Tcmatrixgemm(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixgemm'));
    x_xv2_rmatrixgemm := Trmatrixgemm(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixgemm'));
    x_xv2_cmatrixsyrk := Tcmatrixsyrk(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixsyrk'));
    x_xv2_rmatrixrndorthogonal := Trmatrixrndorthogonal(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrndorthogonal'));
    x_xv2_rmatrixrndcond := Trmatrixrndcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrndcond'));
    x_xv2_cmatrixrndorthogonal := Tcmatrixrndorthogonal(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrndorthogonal'));
    x_xv2_cmatrixrndcond := Tcmatrixrndcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrndcond'));
    x_xv2_smatrixrndcond := Tsmatrixrndcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixrndcond'));
    x_xv2_spdmatrixrndcond := Tspdmatrixrndcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixrndcond'));
    x_xv2_hmatrixrndcond := Thmatrixrndcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_hmatrixrndcond'));
    x_xv2_hpdmatrixrndcond := Thpdmatrixrndcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixrndcond'));
    x_xv2_rmatrixrndorthogonalfromtheright := Trmatrixrndorthogonalfromtheright(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrndorthogonalfromtheright'));
    x_xv2_rmatrixrndorthogonalfromtheleft := Trmatrixrndorthogonalfromtheleft(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrndorthogonalfromtheleft'));
    x_xv2_cmatrixrndorthogonalfromtheright := Tcmatrixrndorthogonalfromtheright(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrndorthogonalfromtheright'));
    x_xv2_cmatrixrndorthogonalfromtheleft := Tcmatrixrndorthogonalfromtheleft(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrndorthogonalfromtheleft'));
    x_xv2_smatrixrndmultiply := Tsmatrixrndmultiply(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixrndmultiply'));
    x_xv2_hmatrixrndmultiply := Thmatrixrndmultiply(XGetProcAddress(_lib_alglib, 'alglib_xv2_hmatrixrndmultiply'));
    x_xv2_rmatrixlu := Trmatrixlu(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlu'));
    x_xv2_cmatrixlu := Tcmatrixlu(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlu'));
    x_xv2_hpdmatrixcholesky := Thpdmatrixcholesky(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixcholesky'));
    x_xv2_spdmatrixcholesky := Tspdmatrixcholesky(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholesky'));
    x_xv2_spdmatrixcholeskyupdateadd1 := Tspdmatrixcholeskyupdateadd1(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskyupdateadd1'));
    x_xv2_spdmatrixcholeskyupdatefix := Tspdmatrixcholeskyupdatefix(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskyupdatefix'));
    x_xv2_spdmatrixcholeskyupdateadd1buf := Tspdmatrixcholeskyupdateadd1buf(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskyupdateadd1buf'));
    x_xv2_spdmatrixcholeskyupdatefixbuf := Tspdmatrixcholeskyupdatefixbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskyupdatefixbuf'));
    x_xv2_sparselu := Tsparselu(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparselu'));
    x_xv2_sparsecholeskyskyline := Tsparsecholeskyskyline(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecholeskyskyline'));
    x_xv2_rmatrixrcond1 := Trmatrixrcond1(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrcond1'));
    x_xv2_rmatrixrcondinf := Trmatrixrcondinf(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixrcondinf'));
    x_xv2_spdmatrixrcond := Tspdmatrixrcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixrcond'));
    x_xv2_rmatrixtrrcond1 := Trmatrixtrrcond1(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixtrrcond1'));
    x_xv2_rmatrixtrrcondinf := Trmatrixtrrcondinf(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixtrrcondinf'));
    x_xv2_hpdmatrixrcond := Thpdmatrixrcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixrcond'));
    x_xv2_cmatrixrcond1 := Tcmatrixrcond1(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrcond1'));
    x_xv2_cmatrixrcondinf := Tcmatrixrcondinf(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixrcondinf'));
    x_xv2_rmatrixlurcond1 := Trmatrixlurcond1(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlurcond1'));
    x_xv2_rmatrixlurcondinf := Trmatrixlurcondinf(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlurcondinf'));
    x_xv2_spdmatrixcholeskyrcond := Tspdmatrixcholeskyrcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskyrcond'));
    x_xv2_hpdmatrixcholeskyrcond := Thpdmatrixcholeskyrcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixcholeskyrcond'));
    x_xv2_cmatrixlurcond1 := Tcmatrixlurcond1(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlurcond1'));
    x_xv2_cmatrixlurcondinf := Tcmatrixlurcondinf(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlurcondinf'));
    x_xv2_cmatrixtrrcond1 := Tcmatrixtrrcond1(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixtrrcond1'));
    x_xv2_cmatrixtrrcondinf := Tcmatrixtrrcondinf(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixtrrcondinf'));
    x_xv2_rmatrixluinverse := Trmatrixluinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixluinverse'));
    x_xv2_rmatrixinverse := Trmatrixinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixinverse'));
    x_xv2_cmatrixluinverse := Tcmatrixluinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixluinverse'));
    x_xv2_cmatrixinverse := Tcmatrixinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixinverse'));
    x_xv2_spdmatrixcholeskyinverse := Tspdmatrixcholeskyinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskyinverse'));
    x_xv2_spdmatrixinverse := Tspdmatrixinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixinverse'));
    x_xv2_hpdmatrixcholeskyinverse := Thpdmatrixcholeskyinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixcholeskyinverse'));
    x_xv2_hpdmatrixinverse := Thpdmatrixinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixinverse'));
    x_xv2_rmatrixtrinverse := Trmatrixtrinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixtrinverse'));
    x_xv2_cmatrixtrinverse := Tcmatrixtrinverse(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixtrinverse'));
    x_xv2_rmatrixqr := Trmatrixqr(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixqr'));
    x_xv2_rmatrixlq := Trmatrixlq(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlq'));
    x_xv2_cmatrixqr := Tcmatrixqr(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixqr'));
    x_xv2_cmatrixlq := Tcmatrixlq(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlq'));
    x_xv2_rmatrixqrunpackq := Trmatrixqrunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixqrunpackq'));
    x_xv2_rmatrixqrunpackr := Trmatrixqrunpackr(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixqrunpackr'));
    x_xv2_rmatrixlqunpackq := Trmatrixlqunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlqunpackq'));
    x_xv2_rmatrixlqunpackl := Trmatrixlqunpackl(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlqunpackl'));
    x_xv2_cmatrixqrunpackq := Tcmatrixqrunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixqrunpackq'));
    x_xv2_cmatrixqrunpackr := Tcmatrixqrunpackr(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixqrunpackr'));
    x_xv2_cmatrixlqunpackq := Tcmatrixlqunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlqunpackq'));
    x_xv2_cmatrixlqunpackl := Tcmatrixlqunpackl(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlqunpackl'));
    x_xv2_rmatrixbd := Trmatrixbd(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixbd'));
    x_xv2_rmatrixbdunpackq := Trmatrixbdunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixbdunpackq'));
    x_xv2_rmatrixbdmultiplybyq := Trmatrixbdmultiplybyq(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixbdmultiplybyq'));
    x_xv2_rmatrixbdunpackpt := Trmatrixbdunpackpt(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixbdunpackpt'));
    x_xv2_rmatrixbdmultiplybyp := Trmatrixbdmultiplybyp(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixbdmultiplybyp'));
    x_xv2_rmatrixbdunpackdiagonals := Trmatrixbdunpackdiagonals(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixbdunpackdiagonals'));
    x_xv2_rmatrixhessenberg := Trmatrixhessenberg(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixhessenberg'));
    x_xv2_rmatrixhessenbergunpackq := Trmatrixhessenbergunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixhessenbergunpackq'));
    x_xv2_rmatrixhessenbergunpackh := Trmatrixhessenbergunpackh(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixhessenbergunpackh'));
    x_xv2_smatrixtd := Tsmatrixtd(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixtd'));
    x_xv2_smatrixtdunpackq := Tsmatrixtdunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixtdunpackq'));
    x_xv2_hmatrixtd := Thmatrixtd(XGetProcAddress(_lib_alglib, 'alglib_xv2_hmatrixtd'));
    x_xv2_hmatrixtdunpackq := Thmatrixtdunpackq(XGetProcAddress(_lib_alglib, 'alglib_xv2_hmatrixtdunpackq'));
    x_xv2_rmatrixbdsvd := Trmatrixbdsvd(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixbdsvd'));
    x_xv2_rmatrixsvd := Trmatrixsvd(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsvd'));
    x_xv2_rmatrixsolve := Trmatrixsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsolve'));
    x_xv2_rmatrixsolvefast := Trmatrixsolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsolvefast'));
    x_xv2_rmatrixsolvem := Trmatrixsolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsolvem'));
    x_xv2_rmatrixsolvemfast := Trmatrixsolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsolvemfast'));
    x_xv2_rmatrixlusolve := Trmatrixlusolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlusolve'));
    x_xv2_rmatrixlusolvefast := Trmatrixlusolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlusolvefast'));
    x_xv2_rmatrixlusolvem := Trmatrixlusolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlusolvem'));
    x_xv2_rmatrixlusolvemfast := Trmatrixlusolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixlusolvemfast'));
    x_xv2_rmatrixmixedsolve := Trmatrixmixedsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixmixedsolve'));
    x_xv2_rmatrixmixedsolvem := Trmatrixmixedsolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixmixedsolvem'));
    x_xv2_cmatrixsolvem := Tcmatrixsolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixsolvem'));
    x_xv2_cmatrixsolvemfast := Tcmatrixsolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixsolvemfast'));
    x_xv2_cmatrixsolve := Tcmatrixsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixsolve'));
    x_xv2_cmatrixsolvefast := Tcmatrixsolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixsolvefast'));
    x_xv2_cmatrixlusolvem := Tcmatrixlusolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlusolvem'));
    x_xv2_cmatrixlusolvemfast := Tcmatrixlusolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlusolvemfast'));
    x_xv2_cmatrixlusolve := Tcmatrixlusolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlusolve'));
    x_xv2_cmatrixlusolvefast := Tcmatrixlusolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixlusolvefast'));
    x_xv2_cmatrixmixedsolvem := Tcmatrixmixedsolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixmixedsolvem'));
    x_xv2_cmatrixmixedsolve := Tcmatrixmixedsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixmixedsolve'));
    x_xv2_spdmatrixsolvem := Tspdmatrixsolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixsolvem'));
    x_xv2_spdmatrixsolvemfast := Tspdmatrixsolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixsolvemfast'));
    x_xv2_spdmatrixsolve := Tspdmatrixsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixsolve'));
    x_xv2_spdmatrixsolvefast := Tspdmatrixsolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixsolvefast'));
    x_xv2_spdmatrixcholeskysolvem := Tspdmatrixcholeskysolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskysolvem'));
    x_xv2_spdmatrixcholeskysolvemfast := Tspdmatrixcholeskysolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskysolvemfast'));
    x_xv2_spdmatrixcholeskysolve := Tspdmatrixcholeskysolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskysolve'));
    x_xv2_spdmatrixcholeskysolvefast := Tspdmatrixcholeskysolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskysolvefast'));
    x_xv2_hpdmatrixsolvem := Thpdmatrixsolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixsolvem'));
    x_xv2_hpdmatrixsolvemfast := Thpdmatrixsolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixsolvemfast'));
    x_xv2_hpdmatrixsolve := Thpdmatrixsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixsolve'));
    x_xv2_hpdmatrixsolvefast := Thpdmatrixsolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixsolvefast'));
    x_xv2_hpdmatrixcholeskysolvem := Thpdmatrixcholeskysolvem(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixcholeskysolvem'));
    x_xv2_hpdmatrixcholeskysolvemfast := Thpdmatrixcholeskysolvemfast(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixcholeskysolvemfast'));
    x_xv2_hpdmatrixcholeskysolve := Thpdmatrixcholeskysolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixcholeskysolve'));
    x_xv2_hpdmatrixcholeskysolvefast := Thpdmatrixcholeskysolvefast(XGetProcAddress(_lib_alglib, 'alglib_xv2_hpdmatrixcholeskysolvefast'));
    x_xv2_rmatrixsolvels := Trmatrixsolvels(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixsolvels'));
    x_obj_copy_minlbfgsstate := Tx_obj_copy_minlbfgsstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minlbfgsstate'));
    x_obj_free_minlbfgsstate := Tx_obj_free_minlbfgsstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minlbfgsstate'));
    x_minlbfgsstate_get_needf := Tx_minlbfgsstate_get_needf(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_get_needf'));
    Touch(x_minlbfgsstate_get_needf); // avoid messages about unused variables
    x_minlbfgsstate_set_needf := Tx_minlbfgsstate_set_needf(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_set_needf'));
    Touch(x_minlbfgsstate_set_needf);
    x_minlbfgsstate_get_needfg := Tx_minlbfgsstate_get_needfg(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_get_needfg'));
    Touch(x_minlbfgsstate_get_needfg); // avoid messages about unused variables
    x_minlbfgsstate_set_needfg := Tx_minlbfgsstate_set_needfg(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_set_needfg'));
    Touch(x_minlbfgsstate_set_needfg);
    x_minlbfgsstate_get_xupdated := Tx_minlbfgsstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_get_xupdated'));
    Touch(x_minlbfgsstate_get_xupdated); // avoid messages about unused variables
    x_minlbfgsstate_set_xupdated := Tx_minlbfgsstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_set_xupdated'));
    Touch(x_minlbfgsstate_set_xupdated);
    x_minlbfgsstate_get_f := Tx_minlbfgsstate_get_f(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_get_f'));
    Touch(x_minlbfgsstate_get_f); // avoid messages about unused variables
    x_minlbfgsstate_set_f := Tx_minlbfgsstate_set_f(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_set_f'));
    Touch(x_minlbfgsstate_set_f);
    x_minlbfgsstate_get_g := Tx_minlbfgsstate_get_g(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_get_g'));
    Touch(x_minlbfgsstate_get_g); // avoid messages about unused variables
    x_minlbfgsstate_get_x := Tx_minlbfgsstate_get_x(XGetProcAddress(_lib_alglib, 'x_minlbfgsstate_get_x'));
    Touch(x_minlbfgsstate_get_x); // avoid messages about unused variables
    x_xv2_minlbfgscreate := Tminlbfgscreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgscreate'));
    x_xv2_minlbfgscreatef := Tminlbfgscreatef(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgscreatef'));
    x_xv2_minlbfgssetcond := Tminlbfgssetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetcond'));
    x_xv2_minlbfgssetxrep := Tminlbfgssetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetxrep'));
    x_xv2_minlbfgssetstpmax := Tminlbfgssetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetstpmax'));
    x_xv2_minlbfgssetscale := Tminlbfgssetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetscale'));
    x_xv2_minlbfgssetprecdefault := Tminlbfgssetprecdefault(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetprecdefault'));
    x_xv2_minlbfgssetpreccholesky := Tminlbfgssetpreccholesky(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetpreccholesky'));
    x_xv2_minlbfgssetprecdiag := Tminlbfgssetprecdiag(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetprecdiag'));
    x_xv2_minlbfgssetprecscale := Tminlbfgssetprecscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetprecscale'));
    x_xv2_minlbfgsiteration := Tminlbfgsiteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsiteration'));
    x_xv2_minlbfgsoptguardgradient := Tminlbfgsoptguardgradient(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsoptguardgradient'));
    x_xv2_minlbfgsoptguardsmoothness := Tminlbfgsoptguardsmoothness(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsoptguardsmoothness'));
    x_xv2_minlbfgsoptguardresults := Tminlbfgsoptguardresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsoptguardresults'));
    x_xv2_minlbfgsoptguardnonc1test0results := Tminlbfgsoptguardnonc1test0results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsoptguardnonc1test0results'));
    x_xv2_minlbfgsoptguardnonc1test1results := Tminlbfgsoptguardnonc1test1results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsoptguardnonc1test1results'));
    x_xv2_minlbfgsresults := Tminlbfgsresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsresults'));
    x_xv2_minlbfgsresultsbuf := Tminlbfgsresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsresultsbuf'));
    x_xv2_minlbfgsrestartfrom := Tminlbfgsrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsrestartfrom'));
    x_xv2_minlbfgsrequesttermination := Tminlbfgsrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgsrequesttermination'));
    x_obj_copy_normestimatorstate := Tx_obj_copy_normestimatorstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_normestimatorstate'));
    x_obj_free_normestimatorstate := Tx_obj_free_normestimatorstate(XGetProcAddress(_lib_alglib, 'x_obj_free_normestimatorstate'));
    x_xv2_normestimatorcreate := Tnormestimatorcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_normestimatorcreate'));
    x_xv2_normestimatorsetseed := Tnormestimatorsetseed(XGetProcAddress(_lib_alglib, 'alglib_xv2_normestimatorsetseed'));
    x_xv2_normestimatorestimatesparse := Tnormestimatorestimatesparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_normestimatorestimatesparse'));
    x_xv2_normestimatorresults := Tnormestimatorresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_normestimatorresults'));
    x_obj_copy_linlsqrstate := Tx_obj_copy_linlsqrstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_linlsqrstate'));
    x_obj_free_linlsqrstate := Tx_obj_free_linlsqrstate(XGetProcAddress(_lib_alglib, 'x_obj_free_linlsqrstate'));
    x_xv2_linlsqrcreate := Tlinlsqrcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrcreate'));
    x_xv2_linlsqrcreatebuf := Tlinlsqrcreatebuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrcreatebuf'));
    x_xv2_linlsqrsetprecunit := Tlinlsqrsetprecunit(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrsetprecunit'));
    x_xv2_linlsqrsetprecdiag := Tlinlsqrsetprecdiag(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrsetprecdiag'));
    x_xv2_linlsqrsetlambdai := Tlinlsqrsetlambdai(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrsetlambdai'));
    x_xv2_linlsqrsolvesparse := Tlinlsqrsolvesparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrsolvesparse'));
    x_xv2_linlsqrsetcond := Tlinlsqrsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrsetcond'));
    x_xv2_linlsqrresults := Tlinlsqrresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrresults'));
    x_xv2_linlsqrsetxrep := Tlinlsqrsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrsetxrep'));
    x_xv2_linlsqrpeekiterationscount := Tlinlsqrpeekiterationscount(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrpeekiterationscount'));
    x_xv2_linlsqrrequesttermination := Tlinlsqrrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_linlsqrrequesttermination'));
    x_obj_copy_minbleicstate := Tx_obj_copy_minbleicstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minbleicstate'));
    x_obj_free_minbleicstate := Tx_obj_free_minbleicstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minbleicstate'));
    x_minbleicstate_get_needf := Tx_minbleicstate_get_needf(XGetProcAddress(_lib_alglib, 'x_minbleicstate_get_needf'));
    Touch(x_minbleicstate_get_needf); // avoid messages about unused variables
    x_minbleicstate_set_needf := Tx_minbleicstate_set_needf(XGetProcAddress(_lib_alglib, 'x_minbleicstate_set_needf'));
    Touch(x_minbleicstate_set_needf);
    x_minbleicstate_get_needfg := Tx_minbleicstate_get_needfg(XGetProcAddress(_lib_alglib, 'x_minbleicstate_get_needfg'));
    Touch(x_minbleicstate_get_needfg); // avoid messages about unused variables
    x_minbleicstate_set_needfg := Tx_minbleicstate_set_needfg(XGetProcAddress(_lib_alglib, 'x_minbleicstate_set_needfg'));
    Touch(x_minbleicstate_set_needfg);
    x_minbleicstate_get_xupdated := Tx_minbleicstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_minbleicstate_get_xupdated'));
    Touch(x_minbleicstate_get_xupdated); // avoid messages about unused variables
    x_minbleicstate_set_xupdated := Tx_minbleicstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_minbleicstate_set_xupdated'));
    Touch(x_minbleicstate_set_xupdated);
    x_minbleicstate_get_f := Tx_minbleicstate_get_f(XGetProcAddress(_lib_alglib, 'x_minbleicstate_get_f'));
    Touch(x_minbleicstate_get_f); // avoid messages about unused variables
    x_minbleicstate_set_f := Tx_minbleicstate_set_f(XGetProcAddress(_lib_alglib, 'x_minbleicstate_set_f'));
    Touch(x_minbleicstate_set_f);
    x_minbleicstate_get_g := Tx_minbleicstate_get_g(XGetProcAddress(_lib_alglib, 'x_minbleicstate_get_g'));
    Touch(x_minbleicstate_get_g); // avoid messages about unused variables
    x_minbleicstate_get_x := Tx_minbleicstate_get_x(XGetProcAddress(_lib_alglib, 'x_minbleicstate_get_x'));
    Touch(x_minbleicstate_get_x); // avoid messages about unused variables
    x_xv2_minbleiccreate := Tminbleiccreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleiccreate'));
    x_xv2_minbleiccreatef := Tminbleiccreatef(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleiccreatef'));
    x_xv2_minbleicsetbc := Tminbleicsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetbc'));
    x_xv2_minbleicsetlc := Tminbleicsetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetlc'));
    x_xv2_minbleicsetcond := Tminbleicsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetcond'));
    x_xv2_minbleicsetscale := Tminbleicsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetscale'));
    x_xv2_minbleicsetprecdefault := Tminbleicsetprecdefault(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetprecdefault'));
    x_xv2_minbleicsetprecdiag := Tminbleicsetprecdiag(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetprecdiag'));
    x_xv2_minbleicsetprecscale := Tminbleicsetprecscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetprecscale'));
    x_xv2_minbleicsetxrep := Tminbleicsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetxrep'));
    x_xv2_minbleicsetstpmax := Tminbleicsetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetstpmax'));
    x_xv2_minbleiciteration := Tminbleiciteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleiciteration'));
    x_xv2_minbleicoptguardgradient := Tminbleicoptguardgradient(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicoptguardgradient'));
    x_xv2_minbleicoptguardsmoothness := Tminbleicoptguardsmoothness(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicoptguardsmoothness'));
    x_xv2_minbleicoptguardresults := Tminbleicoptguardresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicoptguardresults'));
    x_xv2_minbleicoptguardnonc1test0results := Tminbleicoptguardnonc1test0results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicoptguardnonc1test0results'));
    x_xv2_minbleicoptguardnonc1test1results := Tminbleicoptguardnonc1test1results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicoptguardnonc1test1results'));
    x_xv2_minbleicresults := Tminbleicresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicresults'));
    x_xv2_minbleicresultsbuf := Tminbleicresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicresultsbuf'));
    x_xv2_minbleicrestartfrom := Tminbleicrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicrestartfrom'));
    x_xv2_minbleicrequesttermination := Tminbleicrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicrequesttermination'));
    x_obj_copy_minqpstate := Tx_obj_copy_minqpstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minqpstate'));
    x_obj_free_minqpstate := Tx_obj_free_minqpstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minqpstate'));
    x_xv2_minqpcreate := Tminqpcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpcreate'));
    x_xv2_minqpsetlinearterm := Tminqpsetlinearterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlinearterm'));
    x_xv2_minqpsetquadraticterm := Tminqpsetquadraticterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetquadraticterm'));
    x_xv2_minqpsetquadratictermsparse := Tminqpsetquadratictermsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetquadratictermsparse'));
    x_xv2_minqpsetstartingpoint := Tminqpsetstartingpoint(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetstartingpoint'));
    x_xv2_minqpsetorigin := Tminqpsetorigin(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetorigin'));
    x_xv2_minqpsetscale := Tminqpsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetscale'));
    x_xv2_minqpsetscaleautodiag := Tminqpsetscaleautodiag(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetscaleautodiag'));
    x_xv2_minqpsetalgobleic := Tminqpsetalgobleic(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetalgobleic'));
    x_xv2_minqpsetalgodenseaul := Tminqpsetalgodenseaul(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetalgodenseaul'));
    x_xv2_minqpsetalgodenseipm := Tminqpsetalgodenseipm(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetalgodenseipm'));
    x_xv2_minqpsetalgosparseipm := Tminqpsetalgosparseipm(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetalgosparseipm'));
    x_xv2_minqpsetalgoquickqp := Tminqpsetalgoquickqp(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetalgoquickqp'));
    x_xv2_minqpsetbc := Tminqpsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetbc'));
    x_xv2_minqpsetbcall := Tminqpsetbcall(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetbcall'));
    x_xv2_minqpsetbci := Tminqpsetbci(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetbci'));
    x_xv2_minqpsetlc := Tminqpsetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlc'));
    x_xv2_minqpsetlcsparse := Tminqpsetlcsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlcsparse'));
    x_xv2_minqpsetlcmixed := Tminqpsetlcmixed(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlcmixed'));
    x_xv2_minqpsetlcmixedlegacy := Tminqpsetlcmixedlegacy(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlcmixedlegacy'));
    x_xv2_minqpsetlc2dense := Tminqpsetlc2dense(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlc2dense'));
    x_xv2_minqpsetlc2 := Tminqpsetlc2(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlc2'));
    x_xv2_minqpsetlc2mixed := Tminqpsetlc2mixed(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpsetlc2mixed'));
    x_xv2_minqpaddlc2dense := Tminqpaddlc2dense(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpaddlc2dense'));
    x_xv2_minqpaddlc2 := Tminqpaddlc2(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpaddlc2'));
    x_xv2_minqpoptimize := Tminqpoptimize(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpoptimize'));
    x_xv2_minqpresults := Tminqpresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpresults'));
    x_xv2_minqpresultsbuf := Tminqpresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minqpresultsbuf'));
    x_obj_copy_minlpstate := Tx_obj_copy_minlpstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minlpstate'));
    x_obj_free_minlpstate := Tx_obj_free_minlpstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minlpstate'));
    x_xv2_minlpcreate := Tminlpcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpcreate'));
    x_xv2_minlpsetcost := Tminlpsetcost(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetcost'));
    x_xv2_minlpsetscale := Tminlpsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetscale'));
    x_xv2_minlpsetbc := Tminlpsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetbc'));
    x_xv2_minlpsetbcall := Tminlpsetbcall(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetbcall'));
    x_xv2_minlpsetbci := Tminlpsetbci(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetbci'));
    x_xv2_minlpsetlc := Tminlpsetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetlc'));
    x_xv2_minlpsetlc2dense := Tminlpsetlc2dense(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetlc2dense'));
    x_xv2_minlpsetlc2 := Tminlpsetlc2(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpsetlc2'));
    x_xv2_minlpaddlc2dense := Tminlpaddlc2dense(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpaddlc2dense'));
    x_xv2_minlpaddlc2 := Tminlpaddlc2(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpaddlc2'));
    x_xv2_minlpoptimize := Tminlpoptimize(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpoptimize'));
    x_xv2_minlpresults := Tminlpresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpresults'));
    x_xv2_minlpresultsbuf := Tminlpresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlpresultsbuf'));
    x_obj_copy_minnlcstate := Tx_obj_copy_minnlcstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minnlcstate'));
    x_obj_free_minnlcstate := Tx_obj_free_minnlcstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minnlcstate'));
    x_minnlcstate_get_needfi := Tx_minnlcstate_get_needfi(XGetProcAddress(_lib_alglib, 'x_minnlcstate_get_needfi'));
    Touch(x_minnlcstate_get_needfi); // avoid messages about unused variables
    x_minnlcstate_set_needfi := Tx_minnlcstate_set_needfi(XGetProcAddress(_lib_alglib, 'x_minnlcstate_set_needfi'));
    Touch(x_minnlcstate_set_needfi);
    x_minnlcstate_get_needfij := Tx_minnlcstate_get_needfij(XGetProcAddress(_lib_alglib, 'x_minnlcstate_get_needfij'));
    Touch(x_minnlcstate_get_needfij); // avoid messages about unused variables
    x_minnlcstate_set_needfij := Tx_minnlcstate_set_needfij(XGetProcAddress(_lib_alglib, 'x_minnlcstate_set_needfij'));
    Touch(x_minnlcstate_set_needfij);
    x_minnlcstate_get_xupdated := Tx_minnlcstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_minnlcstate_get_xupdated'));
    Touch(x_minnlcstate_get_xupdated); // avoid messages about unused variables
    x_minnlcstate_set_xupdated := Tx_minnlcstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_minnlcstate_set_xupdated'));
    Touch(x_minnlcstate_set_xupdated);
    x_minnlcstate_get_f := Tx_minnlcstate_get_f(XGetProcAddress(_lib_alglib, 'x_minnlcstate_get_f'));
    Touch(x_minnlcstate_get_f); // avoid messages about unused variables
    x_minnlcstate_set_f := Tx_minnlcstate_set_f(XGetProcAddress(_lib_alglib, 'x_minnlcstate_set_f'));
    Touch(x_minnlcstate_set_f);
    x_minnlcstate_get_fi := Tx_minnlcstate_get_fi(XGetProcAddress(_lib_alglib, 'x_minnlcstate_get_fi'));
    Touch(x_minnlcstate_get_fi); // avoid messages about unused variables
    x_minnlcstate_get_j := Tx_minnlcstate_get_j(XGetProcAddress(_lib_alglib, 'x_minnlcstate_get_j'));
    Touch(x_minnlcstate_get_j); // avoid messages about unused variables
    x_minnlcstate_get_x := Tx_minnlcstate_get_x(XGetProcAddress(_lib_alglib, 'x_minnlcstate_get_x'));
    Touch(x_minnlcstate_get_x); // avoid messages about unused variables
    x_xv2_minnlccreate := Tminnlccreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlccreate'));
    x_xv2_minnlccreatef := Tminnlccreatef(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlccreatef'));
    x_xv2_minnlcsetbc := Tminnlcsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetbc'));
    x_xv2_minnlcsetlc := Tminnlcsetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetlc'));
    x_xv2_minnlcsetnlc := Tminnlcsetnlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetnlc'));
    x_xv2_minnlcsetcond := Tminnlcsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetcond'));
    x_xv2_minnlcsetscale := Tminnlcsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetscale'));
    x_xv2_minnlcsetprecinexact := Tminnlcsetprecinexact(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetprecinexact'));
    x_xv2_minnlcsetprecexactlowrank := Tminnlcsetprecexactlowrank(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetprecexactlowrank'));
    x_xv2_minnlcsetprecexactrobust := Tminnlcsetprecexactrobust(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetprecexactrobust'));
    x_xv2_minnlcsetprecnone := Tminnlcsetprecnone(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetprecnone'));
    x_xv2_minnlcsetstpmax := Tminnlcsetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetstpmax'));
    x_xv2_minnlcsetalgoaul := Tminnlcsetalgoaul(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetalgoaul'));
    x_xv2_minnlcsetalgoslp := Tminnlcsetalgoslp(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetalgoslp'));
    x_xv2_minnlcsetalgosqp := Tminnlcsetalgosqp(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetalgosqp'));
    x_xv2_minnlcsetxrep := Tminnlcsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcsetxrep'));
    x_xv2_minnlciteration := Tminnlciteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlciteration'));
    x_xv2_minnlcoptguardgradient := Tminnlcoptguardgradient(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcoptguardgradient'));
    x_xv2_minnlcoptguardsmoothness := Tminnlcoptguardsmoothness(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcoptguardsmoothness'));
    x_xv2_minnlcoptguardresults := Tminnlcoptguardresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcoptguardresults'));
    x_xv2_minnlcoptguardnonc1test0results := Tminnlcoptguardnonc1test0results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcoptguardnonc1test0results'));
    x_xv2_minnlcoptguardnonc1test1results := Tminnlcoptguardnonc1test1results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcoptguardnonc1test1results'));
    x_xv2_minnlcresults := Tminnlcresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcresults'));
    x_xv2_minnlcresultsbuf := Tminnlcresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcresultsbuf'));
    x_xv2_minnlcrequesttermination := Tminnlcrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcrequesttermination'));
    x_xv2_minnlcrestartfrom := Tminnlcrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnlcrestartfrom'));
    x_obj_copy_minbcstate := Tx_obj_copy_minbcstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minbcstate'));
    x_obj_free_minbcstate := Tx_obj_free_minbcstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minbcstate'));
    x_minbcstate_get_needf := Tx_minbcstate_get_needf(XGetProcAddress(_lib_alglib, 'x_minbcstate_get_needf'));
    Touch(x_minbcstate_get_needf); // avoid messages about unused variables
    x_minbcstate_set_needf := Tx_minbcstate_set_needf(XGetProcAddress(_lib_alglib, 'x_minbcstate_set_needf'));
    Touch(x_minbcstate_set_needf);
    x_minbcstate_get_needfg := Tx_minbcstate_get_needfg(XGetProcAddress(_lib_alglib, 'x_minbcstate_get_needfg'));
    Touch(x_minbcstate_get_needfg); // avoid messages about unused variables
    x_minbcstate_set_needfg := Tx_minbcstate_set_needfg(XGetProcAddress(_lib_alglib, 'x_minbcstate_set_needfg'));
    Touch(x_minbcstate_set_needfg);
    x_minbcstate_get_xupdated := Tx_minbcstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_minbcstate_get_xupdated'));
    Touch(x_minbcstate_get_xupdated); // avoid messages about unused variables
    x_minbcstate_set_xupdated := Tx_minbcstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_minbcstate_set_xupdated'));
    Touch(x_minbcstate_set_xupdated);
    x_minbcstate_get_f := Tx_minbcstate_get_f(XGetProcAddress(_lib_alglib, 'x_minbcstate_get_f'));
    Touch(x_minbcstate_get_f); // avoid messages about unused variables
    x_minbcstate_set_f := Tx_minbcstate_set_f(XGetProcAddress(_lib_alglib, 'x_minbcstate_set_f'));
    Touch(x_minbcstate_set_f);
    x_minbcstate_get_g := Tx_minbcstate_get_g(XGetProcAddress(_lib_alglib, 'x_minbcstate_get_g'));
    Touch(x_minbcstate_get_g); // avoid messages about unused variables
    x_minbcstate_get_x := Tx_minbcstate_get_x(XGetProcAddress(_lib_alglib, 'x_minbcstate_get_x'));
    Touch(x_minbcstate_get_x); // avoid messages about unused variables
    x_xv2_minbccreate := Tminbccreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbccreate'));
    x_xv2_minbccreatef := Tminbccreatef(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbccreatef'));
    x_xv2_minbcsetbc := Tminbcsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetbc'));
    x_xv2_minbcsetcond := Tminbcsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetcond'));
    x_xv2_minbcsetscale := Tminbcsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetscale'));
    x_xv2_minbcsetprecdefault := Tminbcsetprecdefault(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetprecdefault'));
    x_xv2_minbcsetprecdiag := Tminbcsetprecdiag(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetprecdiag'));
    x_xv2_minbcsetprecscale := Tminbcsetprecscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetprecscale'));
    x_xv2_minbcsetxrep := Tminbcsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetxrep'));
    x_xv2_minbcsetstpmax := Tminbcsetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcsetstpmax'));
    x_xv2_minbciteration := Tminbciteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbciteration'));
    x_xv2_minbcoptguardgradient := Tminbcoptguardgradient(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcoptguardgradient'));
    x_xv2_minbcoptguardsmoothness := Tminbcoptguardsmoothness(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcoptguardsmoothness'));
    x_xv2_minbcoptguardresults := Tminbcoptguardresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcoptguardresults'));
    x_xv2_minbcoptguardnonc1test0results := Tminbcoptguardnonc1test0results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcoptguardnonc1test0results'));
    x_xv2_minbcoptguardnonc1test1results := Tminbcoptguardnonc1test1results(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcoptguardnonc1test1results'));
    x_xv2_minbcresults := Tminbcresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcresults'));
    x_xv2_minbcresultsbuf := Tminbcresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcresultsbuf'));
    x_xv2_minbcrestartfrom := Tminbcrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcrestartfrom'));
    x_xv2_minbcrequesttermination := Tminbcrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbcrequesttermination'));
    x_obj_copy_minnsstate := Tx_obj_copy_minnsstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minnsstate'));
    x_obj_free_minnsstate := Tx_obj_free_minnsstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minnsstate'));
    x_minnsstate_get_needfi := Tx_minnsstate_get_needfi(XGetProcAddress(_lib_alglib, 'x_minnsstate_get_needfi'));
    Touch(x_minnsstate_get_needfi); // avoid messages about unused variables
    x_minnsstate_set_needfi := Tx_minnsstate_set_needfi(XGetProcAddress(_lib_alglib, 'x_minnsstate_set_needfi'));
    Touch(x_minnsstate_set_needfi);
    x_minnsstate_get_needfij := Tx_minnsstate_get_needfij(XGetProcAddress(_lib_alglib, 'x_minnsstate_get_needfij'));
    Touch(x_minnsstate_get_needfij); // avoid messages about unused variables
    x_minnsstate_set_needfij := Tx_minnsstate_set_needfij(XGetProcAddress(_lib_alglib, 'x_minnsstate_set_needfij'));
    Touch(x_minnsstate_set_needfij);
    x_minnsstate_get_xupdated := Tx_minnsstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_minnsstate_get_xupdated'));
    Touch(x_minnsstate_get_xupdated); // avoid messages about unused variables
    x_minnsstate_set_xupdated := Tx_minnsstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_minnsstate_set_xupdated'));
    Touch(x_minnsstate_set_xupdated);
    x_minnsstate_get_f := Tx_minnsstate_get_f(XGetProcAddress(_lib_alglib, 'x_minnsstate_get_f'));
    Touch(x_minnsstate_get_f); // avoid messages about unused variables
    x_minnsstate_set_f := Tx_minnsstate_set_f(XGetProcAddress(_lib_alglib, 'x_minnsstate_set_f'));
    Touch(x_minnsstate_set_f);
    x_minnsstate_get_fi := Tx_minnsstate_get_fi(XGetProcAddress(_lib_alglib, 'x_minnsstate_get_fi'));
    Touch(x_minnsstate_get_fi); // avoid messages about unused variables
    x_minnsstate_get_j := Tx_minnsstate_get_j(XGetProcAddress(_lib_alglib, 'x_minnsstate_get_j'));
    Touch(x_minnsstate_get_j); // avoid messages about unused variables
    x_minnsstate_get_x := Tx_minnsstate_get_x(XGetProcAddress(_lib_alglib, 'x_minnsstate_get_x'));
    Touch(x_minnsstate_get_x); // avoid messages about unused variables
    x_xv2_minnscreate := Tminnscreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnscreate'));
    x_xv2_minnscreatef := Tminnscreatef(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnscreatef'));
    x_xv2_minnssetbc := Tminnssetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnssetbc'));
    x_xv2_minnssetlc := Tminnssetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnssetlc'));
    x_xv2_minnssetnlc := Tminnssetnlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnssetnlc'));
    x_xv2_minnssetcond := Tminnssetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnssetcond'));
    x_xv2_minnssetscale := Tminnssetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnssetscale'));
    x_xv2_minnssetalgoags := Tminnssetalgoags(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnssetalgoags'));
    x_xv2_minnssetxrep := Tminnssetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnssetxrep'));
    x_xv2_minnsrequesttermination := Tminnsrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnsrequesttermination'));
    x_xv2_minnsiteration := Tminnsiteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnsiteration'));
    x_xv2_minnsresults := Tminnsresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnsresults'));
    x_xv2_minnsresultsbuf := Tminnsresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnsresultsbuf'));
    x_xv2_minnsrestartfrom := Tminnsrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_minnsrestartfrom'));
    x_obj_copy_minasastate := Tx_obj_copy_minasastate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minasastate'));
    x_obj_free_minasastate := Tx_obj_free_minasastate(XGetProcAddress(_lib_alglib, 'x_obj_free_minasastate'));
    x_minasastate_get_needfg := Tx_minasastate_get_needfg(XGetProcAddress(_lib_alglib, 'x_minasastate_get_needfg'));
    Touch(x_minasastate_get_needfg); // avoid messages about unused variables
    x_minasastate_set_needfg := Tx_minasastate_set_needfg(XGetProcAddress(_lib_alglib, 'x_minasastate_set_needfg'));
    Touch(x_minasastate_set_needfg);
    x_minasastate_get_xupdated := Tx_minasastate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_minasastate_get_xupdated'));
    Touch(x_minasastate_get_xupdated); // avoid messages about unused variables
    x_minasastate_set_xupdated := Tx_minasastate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_minasastate_set_xupdated'));
    Touch(x_minasastate_set_xupdated);
    x_minasastate_get_f := Tx_minasastate_get_f(XGetProcAddress(_lib_alglib, 'x_minasastate_get_f'));
    Touch(x_minasastate_get_f); // avoid messages about unused variables
    x_minasastate_set_f := Tx_minasastate_set_f(XGetProcAddress(_lib_alglib, 'x_minasastate_set_f'));
    Touch(x_minasastate_set_f);
    x_minasastate_get_g := Tx_minasastate_get_g(XGetProcAddress(_lib_alglib, 'x_minasastate_get_g'));
    Touch(x_minasastate_get_g); // avoid messages about unused variables
    x_minasastate_get_x := Tx_minasastate_get_x(XGetProcAddress(_lib_alglib, 'x_minasastate_get_x'));
    Touch(x_minasastate_get_x); // avoid messages about unused variables
    x_xv2_minlbfgssetdefaultpreconditioner := Tminlbfgssetdefaultpreconditioner(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetdefaultpreconditioner'));
    x_xv2_minlbfgssetcholeskypreconditioner := Tminlbfgssetcholeskypreconditioner(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlbfgssetcholeskypreconditioner'));
    x_xv2_minbleicsetbarrierwidth := Tminbleicsetbarrierwidth(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetbarrierwidth'));
    x_xv2_minbleicsetbarrierdecay := Tminbleicsetbarrierdecay(XGetProcAddress(_lib_alglib, 'alglib_xv2_minbleicsetbarrierdecay'));
    x_xv2_minasacreate := Tminasacreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasacreate'));
    x_xv2_minasasetcond := Tminasasetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasasetcond'));
    x_xv2_minasasetxrep := Tminasasetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasasetxrep'));
    x_xv2_minasasetalgorithm := Tminasasetalgorithm(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasasetalgorithm'));
    x_xv2_minasasetstpmax := Tminasasetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasasetstpmax'));
    x_xv2_minasaiteration := Tminasaiteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasaiteration'));
    x_xv2_minasaresults := Tminasaresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasaresults'));
    x_xv2_minasaresultsbuf := Tminasaresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasaresultsbuf'));
    x_xv2_minasarestartfrom := Tminasarestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_minasarestartfrom'));
    x_obj_copy_mincgstate := Tx_obj_copy_mincgstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_mincgstate'));
    x_obj_free_mincgstate := Tx_obj_free_mincgstate(XGetProcAddress(_lib_alglib, 'x_obj_free_mincgstate'));
    x_mincgstate_get_needf := Tx_mincgstate_get_needf(XGetProcAddress(_lib_alglib, 'x_mincgstate_get_needf'));
    Touch(x_mincgstate_get_needf); // avoid messages about unused variables
    x_mincgstate_set_needf := Tx_mincgstate_set_needf(XGetProcAddress(_lib_alglib, 'x_mincgstate_set_needf'));
    Touch(x_mincgstate_set_needf);
    x_mincgstate_get_needfg := Tx_mincgstate_get_needfg(XGetProcAddress(_lib_alglib, 'x_mincgstate_get_needfg'));
    Touch(x_mincgstate_get_needfg); // avoid messages about unused variables
    x_mincgstate_set_needfg := Tx_mincgstate_set_needfg(XGetProcAddress(_lib_alglib, 'x_mincgstate_set_needfg'));
    Touch(x_mincgstate_set_needfg);
    x_mincgstate_get_xupdated := Tx_mincgstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_mincgstate_get_xupdated'));
    Touch(x_mincgstate_get_xupdated); // avoid messages about unused variables
    x_mincgstate_set_xupdated := Tx_mincgstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_mincgstate_set_xupdated'));
    Touch(x_mincgstate_set_xupdated);
    x_mincgstate_get_f := Tx_mincgstate_get_f(XGetProcAddress(_lib_alglib, 'x_mincgstate_get_f'));
    Touch(x_mincgstate_get_f); // avoid messages about unused variables
    x_mincgstate_set_f := Tx_mincgstate_set_f(XGetProcAddress(_lib_alglib, 'x_mincgstate_set_f'));
    Touch(x_mincgstate_set_f);
    x_mincgstate_get_g := Tx_mincgstate_get_g(XGetProcAddress(_lib_alglib, 'x_mincgstate_get_g'));
    Touch(x_mincgstate_get_g); // avoid messages about unused variables
    x_mincgstate_get_x := Tx_mincgstate_get_x(XGetProcAddress(_lib_alglib, 'x_mincgstate_get_x'));
    Touch(x_mincgstate_get_x); // avoid messages about unused variables
    x_xv2_mincgcreate := Tmincgcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgcreate'));
    x_xv2_mincgcreatef := Tmincgcreatef(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgcreatef'));
    x_xv2_mincgsetcond := Tmincgsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetcond'));
    x_xv2_mincgsetscale := Tmincgsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetscale'));
    x_xv2_mincgsetxrep := Tmincgsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetxrep'));
    x_xv2_mincgsetcgtype := Tmincgsetcgtype(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetcgtype'));
    x_xv2_mincgsetstpmax := Tmincgsetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetstpmax'));
    x_xv2_mincgsuggeststep := Tmincgsuggeststep(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsuggeststep'));
    x_xv2_mincgsetprecdefault := Tmincgsetprecdefault(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetprecdefault'));
    x_xv2_mincgsetprecdiag := Tmincgsetprecdiag(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetprecdiag'));
    x_xv2_mincgsetprecscale := Tmincgsetprecscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgsetprecscale'));
    x_xv2_mincgiteration := Tmincgiteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgiteration'));
    x_xv2_mincgoptguardgradient := Tmincgoptguardgradient(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgoptguardgradient'));
    x_xv2_mincgoptguardsmoothness := Tmincgoptguardsmoothness(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgoptguardsmoothness'));
    x_xv2_mincgoptguardresults := Tmincgoptguardresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgoptguardresults'));
    x_xv2_mincgoptguardnonc1test0results := Tmincgoptguardnonc1test0results(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgoptguardnonc1test0results'));
    x_xv2_mincgoptguardnonc1test1results := Tmincgoptguardnonc1test1results(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgoptguardnonc1test1results'));
    x_xv2_mincgresults := Tmincgresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgresults'));
    x_xv2_mincgresultsbuf := Tmincgresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgresultsbuf'));
    x_xv2_mincgrestartfrom := Tmincgrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgrestartfrom'));
    x_xv2_mincgrequesttermination := Tmincgrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_mincgrequesttermination'));
    x_obj_copy_minlmstate := Tx_obj_copy_minlmstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_minlmstate'));
    x_obj_free_minlmstate := Tx_obj_free_minlmstate(XGetProcAddress(_lib_alglib, 'x_obj_free_minlmstate'));
    x_minlmstate_get_needf := Tx_minlmstate_get_needf(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_needf'));
    Touch(x_minlmstate_get_needf); // avoid messages about unused variables
    x_minlmstate_set_needf := Tx_minlmstate_set_needf(XGetProcAddress(_lib_alglib, 'x_minlmstate_set_needf'));
    Touch(x_minlmstate_set_needf);
    x_minlmstate_get_needfg := Tx_minlmstate_get_needfg(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_needfg'));
    Touch(x_minlmstate_get_needfg); // avoid messages about unused variables
    x_minlmstate_set_needfg := Tx_minlmstate_set_needfg(XGetProcAddress(_lib_alglib, 'x_minlmstate_set_needfg'));
    Touch(x_minlmstate_set_needfg);
    x_minlmstate_get_needfgh := Tx_minlmstate_get_needfgh(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_needfgh'));
    Touch(x_minlmstate_get_needfgh); // avoid messages about unused variables
    x_minlmstate_set_needfgh := Tx_minlmstate_set_needfgh(XGetProcAddress(_lib_alglib, 'x_minlmstate_set_needfgh'));
    Touch(x_minlmstate_set_needfgh);
    x_minlmstate_get_needfi := Tx_minlmstate_get_needfi(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_needfi'));
    Touch(x_minlmstate_get_needfi); // avoid messages about unused variables
    x_minlmstate_set_needfi := Tx_minlmstate_set_needfi(XGetProcAddress(_lib_alglib, 'x_minlmstate_set_needfi'));
    Touch(x_minlmstate_set_needfi);
    x_minlmstate_get_needfij := Tx_minlmstate_get_needfij(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_needfij'));
    Touch(x_minlmstate_get_needfij); // avoid messages about unused variables
    x_minlmstate_set_needfij := Tx_minlmstate_set_needfij(XGetProcAddress(_lib_alglib, 'x_minlmstate_set_needfij'));
    Touch(x_minlmstate_set_needfij);
    x_minlmstate_get_xupdated := Tx_minlmstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_xupdated'));
    Touch(x_minlmstate_get_xupdated); // avoid messages about unused variables
    x_minlmstate_set_xupdated := Tx_minlmstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_minlmstate_set_xupdated'));
    Touch(x_minlmstate_set_xupdated);
    x_minlmstate_get_f := Tx_minlmstate_get_f(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_f'));
    Touch(x_minlmstate_get_f); // avoid messages about unused variables
    x_minlmstate_set_f := Tx_minlmstate_set_f(XGetProcAddress(_lib_alglib, 'x_minlmstate_set_f'));
    Touch(x_minlmstate_set_f);
    x_minlmstate_get_fi := Tx_minlmstate_get_fi(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_fi'));
    Touch(x_minlmstate_get_fi); // avoid messages about unused variables
    x_minlmstate_get_g := Tx_minlmstate_get_g(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_g'));
    Touch(x_minlmstate_get_g); // avoid messages about unused variables
    x_minlmstate_get_h := Tx_minlmstate_get_h(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_h'));
    Touch(x_minlmstate_get_h); // avoid messages about unused variables
    x_minlmstate_get_j := Tx_minlmstate_get_j(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_j'));
    Touch(x_minlmstate_get_j); // avoid messages about unused variables
    x_minlmstate_get_x := Tx_minlmstate_get_x(XGetProcAddress(_lib_alglib, 'x_minlmstate_get_x'));
    Touch(x_minlmstate_get_x); // avoid messages about unused variables
    x_xv2_minlmcreatevj := Tminlmcreatevj(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmcreatevj'));
    x_xv2_minlmcreatev := Tminlmcreatev(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmcreatev'));
    x_xv2_minlmcreatefgh := Tminlmcreatefgh(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmcreatefgh'));
    x_xv2_minlmsetcond := Tminlmsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmsetcond'));
    x_xv2_minlmsetxrep := Tminlmsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmsetxrep'));
    x_xv2_minlmsetstpmax := Tminlmsetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmsetstpmax'));
    x_xv2_minlmsetscale := Tminlmsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmsetscale'));
    x_xv2_minlmsetbc := Tminlmsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmsetbc'));
    x_xv2_minlmsetlc := Tminlmsetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmsetlc'));
    x_xv2_minlmsetacctype := Tminlmsetacctype(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmsetacctype'));
    x_xv2_minlmiteration := Tminlmiteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmiteration'));
    x_xv2_minlmoptguardgradient := Tminlmoptguardgradient(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmoptguardgradient'));
    x_xv2_minlmoptguardresults := Tminlmoptguardresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmoptguardresults'));
    x_xv2_minlmresults := Tminlmresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmresults'));
    x_xv2_minlmresultsbuf := Tminlmresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmresultsbuf'));
    x_xv2_minlmrestartfrom := Tminlmrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmrestartfrom'));
    x_xv2_minlmrequesttermination := Tminlmrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmrequesttermination'));
    x_xv2_minlmcreatevgj := Tminlmcreatevgj(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmcreatevgj'));
    x_xv2_minlmcreatefgj := Tminlmcreatefgj(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmcreatefgj'));
    x_xv2_minlmcreatefj := Tminlmcreatefj(XGetProcAddress(_lib_alglib, 'alglib_xv2_minlmcreatefj'));
    x_obj_copy_eigsubspacestate := Tx_obj_copy_eigsubspacestate(XGetProcAddress(_lib_alglib, 'x_obj_copy_eigsubspacestate'));
    x_obj_free_eigsubspacestate := Tx_obj_free_eigsubspacestate(XGetProcAddress(_lib_alglib, 'x_obj_free_eigsubspacestate'));
    x_xv2_eigsubspacecreate := Teigsubspacecreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspacecreate'));
    x_xv2_eigsubspacecreatebuf := Teigsubspacecreatebuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspacecreatebuf'));
    x_xv2_eigsubspacesetcond := Teigsubspacesetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspacesetcond'));
    x_xv2_eigsubspacesetwarmstart := Teigsubspacesetwarmstart(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspacesetwarmstart'));
    x_xv2_eigsubspaceoocstart := Teigsubspaceoocstart(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspaceoocstart'));
    x_xv2_eigsubspaceooccontinue := Teigsubspaceooccontinue(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspaceooccontinue'));
    x_xv2_eigsubspaceoocgetrequestinfo := Teigsubspaceoocgetrequestinfo(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspaceoocgetrequestinfo'));
    x_xv2_eigsubspaceoocgetrequestdata := Teigsubspaceoocgetrequestdata(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspaceoocgetrequestdata'));
    x_xv2_eigsubspaceoocsendresult := Teigsubspaceoocsendresult(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspaceoocsendresult'));
    x_xv2_eigsubspaceoocstop := Teigsubspaceoocstop(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspaceoocstop'));
    x_xv2_eigsubspacesolvedenses := Teigsubspacesolvedenses(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspacesolvedenses'));
    x_xv2_eigsubspacesolvesparses := Teigsubspacesolvesparses(XGetProcAddress(_lib_alglib, 'alglib_xv2_eigsubspacesolvesparses'));
    x_xv2_smatrixevd := Tsmatrixevd(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixevd'));
    x_xv2_smatrixevdr := Tsmatrixevdr(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixevdr'));
    x_xv2_smatrixevdi := Tsmatrixevdi(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixevdi'));
    x_xv2_hmatrixevd := Thmatrixevd(XGetProcAddress(_lib_alglib, 'alglib_xv2_hmatrixevd'));
    x_xv2_hmatrixevdr := Thmatrixevdr(XGetProcAddress(_lib_alglib, 'alglib_xv2_hmatrixevdr'));
    x_xv2_hmatrixevdi := Thmatrixevdi(XGetProcAddress(_lib_alglib, 'alglib_xv2_hmatrixevdi'));
    x_xv2_smatrixtdevd := Tsmatrixtdevd(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixtdevd'));
    x_xv2_smatrixtdevdr := Tsmatrixtdevdr(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixtdevdr'));
    x_xv2_smatrixtdevdi := Tsmatrixtdevdi(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixtdevdi'));
    x_xv2_rmatrixevd := Trmatrixevd(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixevd'));
    x_xv2_samplemoments := Tsamplemoments(XGetProcAddress(_lib_alglib, 'alglib_xv2_samplemoments'));
    x_xv2_samplemean := Tsamplemean(XGetProcAddress(_lib_alglib, 'alglib_xv2_samplemean'));
    x_xv2_samplevariance := Tsamplevariance(XGetProcAddress(_lib_alglib, 'alglib_xv2_samplevariance'));
    x_xv2_sampleskewness := Tsampleskewness(XGetProcAddress(_lib_alglib, 'alglib_xv2_sampleskewness'));
    x_xv2_samplekurtosis := Tsamplekurtosis(XGetProcAddress(_lib_alglib, 'alglib_xv2_samplekurtosis'));
    x_xv2_sampleadev := Tsampleadev(XGetProcAddress(_lib_alglib, 'alglib_xv2_sampleadev'));
    x_xv2_samplemedian := Tsamplemedian(XGetProcAddress(_lib_alglib, 'alglib_xv2_samplemedian'));
    x_xv2_samplepercentile := Tsamplepercentile(XGetProcAddress(_lib_alglib, 'alglib_xv2_samplepercentile'));
    x_xv2_cov2 := Tcov2(XGetProcAddress(_lib_alglib, 'alglib_xv2_cov2'));
    x_xv2_pearsoncorr2 := Tpearsoncorr2(XGetProcAddress(_lib_alglib, 'alglib_xv2_pearsoncorr2'));
    x_xv2_spearmancorr2 := Tspearmancorr2(XGetProcAddress(_lib_alglib, 'alglib_xv2_spearmancorr2'));
    x_xv2_covm := Tcovm(XGetProcAddress(_lib_alglib, 'alglib_xv2_covm'));
    x_xv2_pearsoncorrm := Tpearsoncorrm(XGetProcAddress(_lib_alglib, 'alglib_xv2_pearsoncorrm'));
    x_xv2_spearmancorrm := Tspearmancorrm(XGetProcAddress(_lib_alglib, 'alglib_xv2_spearmancorrm'));
    x_xv2_covm2 := Tcovm2(XGetProcAddress(_lib_alglib, 'alglib_xv2_covm2'));
    x_xv2_pearsoncorrm2 := Tpearsoncorrm2(XGetProcAddress(_lib_alglib, 'alglib_xv2_pearsoncorrm2'));
    x_xv2_spearmancorrm2 := Tspearmancorrm2(XGetProcAddress(_lib_alglib, 'alglib_xv2_spearmancorrm2'));
    x_xv2_rankdata := Trankdata(XGetProcAddress(_lib_alglib, 'alglib_xv2_rankdata'));
    x_xv2_rankdatacentered := Trankdatacentered(XGetProcAddress(_lib_alglib, 'alglib_xv2_rankdatacentered'));
    x_xv2_pearsoncorrelation := Tpearsoncorrelation(XGetProcAddress(_lib_alglib, 'alglib_xv2_pearsoncorrelation'));
    x_xv2_spearmanrankcorrelation := Tspearmanrankcorrelation(XGetProcAddress(_lib_alglib, 'alglib_xv2_spearmanrankcorrelation'));
    x_xv2_pcabuildbasis := Tpcabuildbasis(XGetProcAddress(_lib_alglib, 'alglib_xv2_pcabuildbasis'));
    x_xv2_pcatruncatedsubspace := Tpcatruncatedsubspace(XGetProcAddress(_lib_alglib, 'alglib_xv2_pcatruncatedsubspace'));
    x_xv2_pcatruncatedsubspacesparse := Tpcatruncatedsubspacesparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_pcatruncatedsubspacesparse'));
    x_xv2_dsoptimalsplit2 := Tdsoptimalsplit2(XGetProcAddress(_lib_alglib, 'alglib_xv2_dsoptimalsplit2'));
    x_xv2_dsoptimalsplit2fast := Tdsoptimalsplit2fast(XGetProcAddress(_lib_alglib, 'alglib_xv2_dsoptimalsplit2fast'));
    x_obj_copy_multilayerperceptron := Tx_obj_copy_multilayerperceptron(XGetProcAddress(_lib_alglib, 'x_obj_copy_multilayerperceptron'));
    x_obj_free_multilayerperceptron := Tx_obj_free_multilayerperceptron(XGetProcAddress(_lib_alglib, 'x_obj_free_multilayerperceptron'));
    x_mlpserialize := Tmlpserialize(  XGetProcAddress(_lib_alglib, 'alglib_mlpserialize'));
    x_mlpunserialize := Tmlpunserialize(XGetProcAddress(_lib_alglib, 'alglib_mlpunserialize'));
    x_mlpserialize_stream := Tmlpserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_mlpserialize_stream'));
    x_mlpunserialize_stream := Tmlpunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_mlpunserialize_stream'));
    x_xv2_mlpcreate0 := Tmlpcreate0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreate0'));
    x_xv2_mlpcreate1 := Tmlpcreate1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreate1'));
    x_xv2_mlpcreate2 := Tmlpcreate2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreate2'));
    x_xv2_mlpcreateb0 := Tmlpcreateb0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreateb0'));
    x_xv2_mlpcreateb1 := Tmlpcreateb1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreateb1'));
    x_xv2_mlpcreateb2 := Tmlpcreateb2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreateb2'));
    x_xv2_mlpcreater0 := Tmlpcreater0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreater0'));
    x_xv2_mlpcreater1 := Tmlpcreater1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreater1'));
    x_xv2_mlpcreater2 := Tmlpcreater2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreater2'));
    x_xv2_mlpcreatec0 := Tmlpcreatec0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreatec0'));
    x_xv2_mlpcreatec1 := Tmlpcreatec1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreatec1'));
    x_xv2_mlpcreatec2 := Tmlpcreatec2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreatec2'));
    x_xv2_mlpcopy := Tmlpcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcopy'));
    x_xv2_mlpcopytunableparameters := Tmlpcopytunableparameters(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcopytunableparameters'));
    x_xv2_mlprandomize := Tmlprandomize(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlprandomize'));
    x_xv2_mlprandomizefull := Tmlprandomizefull(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlprandomizefull'));
    x_xv2_mlpinitpreprocessor := Tmlpinitpreprocessor(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpinitpreprocessor'));
    x_xv2_mlpproperties := Tmlpproperties(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpproperties'));
    x_xv2_mlpgetinputscount := Tmlpgetinputscount(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetinputscount'));
    x_xv2_mlpgetoutputscount := Tmlpgetoutputscount(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetoutputscount'));
    x_xv2_mlpgetweightscount := Tmlpgetweightscount(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetweightscount'));
    x_xv2_mlpissoftmax := Tmlpissoftmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpissoftmax'));
    x_xv2_mlpgetlayerscount := Tmlpgetlayerscount(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetlayerscount'));
    x_xv2_mlpgetlayersize := Tmlpgetlayersize(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetlayersize'));
    x_xv2_mlpgetinputscaling := Tmlpgetinputscaling(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetinputscaling'));
    x_xv2_mlpgetoutputscaling := Tmlpgetoutputscaling(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetoutputscaling'));
    x_xv2_mlpgetneuroninfo := Tmlpgetneuroninfo(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetneuroninfo'));
    x_xv2_mlpgetweight := Tmlpgetweight(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgetweight'));
    x_xv2_mlpsetinputscaling := Tmlpsetinputscaling(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetinputscaling'));
    x_xv2_mlpsetoutputscaling := Tmlpsetoutputscaling(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetoutputscaling'));
    x_xv2_mlpsetneuroninfo := Tmlpsetneuroninfo(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetneuroninfo'));
    x_xv2_mlpsetweight := Tmlpsetweight(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetweight'));
    x_xv2_mlpactivationfunction := Tmlpactivationfunction(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpactivationfunction'));
    x_xv2_mlpprocess := Tmlpprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpprocess'));
    x_xv2_mlpprocessi := Tmlpprocessi(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpprocessi'));
    x_xv2_mlperror := Tmlperror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlperror'));
    x_xv2_mlperrorsparse := Tmlperrorsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlperrorsparse'));
    x_xv2_mlperrorn := Tmlperrorn(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlperrorn'));
    x_xv2_mlpclserror := Tmlpclserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpclserror'));
    x_xv2_mlprelclserror := Tmlprelclserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlprelclserror'));
    x_xv2_mlprelclserrorsparse := Tmlprelclserrorsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlprelclserrorsparse'));
    x_xv2_mlpavgce := Tmlpavgce(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpavgce'));
    x_xv2_mlpavgcesparse := Tmlpavgcesparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpavgcesparse'));
    x_xv2_mlprmserror := Tmlprmserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlprmserror'));
    x_xv2_mlprmserrorsparse := Tmlprmserrorsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlprmserrorsparse'));
    x_xv2_mlpavgerror := Tmlpavgerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpavgerror'));
    x_xv2_mlpavgerrorsparse := Tmlpavgerrorsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpavgerrorsparse'));
    x_xv2_mlpavgrelerror := Tmlpavgrelerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpavgrelerror'));
    x_xv2_mlpavgrelerrorsparse := Tmlpavgrelerrorsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpavgrelerrorsparse'));
    x_xv2_mlpgrad := Tmlpgrad(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgrad'));
    x_xv2_mlpgradn := Tmlpgradn(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgradn'));
    x_xv2_mlpgradbatch := Tmlpgradbatch(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgradbatch'));
    x_xv2_mlpgradbatchsparse := Tmlpgradbatchsparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgradbatchsparse'));
    x_xv2_mlpgradbatchsubset := Tmlpgradbatchsubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgradbatchsubset'));
    x_xv2_mlpgradbatchsparsesubset := Tmlpgradbatchsparsesubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgradbatchsparsesubset'));
    x_xv2_mlpgradnbatch := Tmlpgradnbatch(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpgradnbatch'));
    x_xv2_mlphessiannbatch := Tmlphessiannbatch(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlphessiannbatch'));
    x_xv2_mlphessianbatch := Tmlphessianbatch(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlphessianbatch'));
    x_xv2_mlpallerrorssubset := Tmlpallerrorssubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpallerrorssubset'));
    x_xv2_mlpallerrorssparsesubset := Tmlpallerrorssparsesubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpallerrorssparsesubset'));
    x_xv2_mlperrorsubset := Tmlperrorsubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlperrorsubset'));
    x_xv2_mlperrorsparsesubset := Tmlperrorsparsesubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlperrorsparsesubset'));
    x_xv2_fisherlda := Tfisherlda(XGetProcAddress(_lib_alglib, 'alglib_xv2_fisherlda'));
    x_xv2_fisherldan := Tfisherldan(XGetProcAddress(_lib_alglib, 'alglib_xv2_fisherldan'));
    x_obj_copy_ssamodel := Tx_obj_copy_ssamodel(XGetProcAddress(_lib_alglib, 'x_obj_copy_ssamodel'));
    x_obj_free_ssamodel := Tx_obj_free_ssamodel(XGetProcAddress(_lib_alglib, 'x_obj_free_ssamodel'));
    x_xv2_ssacreate := Tssacreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssacreate'));
    x_xv2_ssasetwindow := Tssasetwindow(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssasetwindow'));
    x_xv2_ssasetseed := Tssasetseed(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssasetseed'));
    x_xv2_ssasetpoweruplength := Tssasetpoweruplength(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssasetpoweruplength'));
    x_xv2_ssasetmemorylimit := Tssasetmemorylimit(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssasetmemorylimit'));
    x_xv2_ssaaddsequence := Tssaaddsequence(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaaddsequence'));
    x_xv2_ssaappendpointandupdate := Tssaappendpointandupdate(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaappendpointandupdate'));
    x_xv2_ssaappendsequenceandupdate := Tssaappendsequenceandupdate(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaappendsequenceandupdate'));
    x_xv2_ssasetalgoprecomputed := Tssasetalgoprecomputed(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssasetalgoprecomputed'));
    x_xv2_ssasetalgotopkdirect := Tssasetalgotopkdirect(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssasetalgotopkdirect'));
    x_xv2_ssasetalgotopkrealtime := Tssasetalgotopkrealtime(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssasetalgotopkrealtime'));
    x_xv2_ssacleardata := Tssacleardata(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssacleardata'));
    x_xv2_ssagetbasis := Tssagetbasis(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssagetbasis'));
    x_xv2_ssagetlrr := Tssagetlrr(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssagetlrr'));
    x_xv2_ssaanalyzelastwindow := Tssaanalyzelastwindow(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaanalyzelastwindow'));
    x_xv2_ssaanalyzelast := Tssaanalyzelast(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaanalyzelast'));
    x_xv2_ssaanalyzesequence := Tssaanalyzesequence(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaanalyzesequence'));
    x_xv2_ssaforecastlast := Tssaforecastlast(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaforecastlast'));
    x_xv2_ssaforecastsequence := Tssaforecastsequence(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaforecastsequence'));
    x_xv2_ssaforecastavglast := Tssaforecastavglast(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaforecastavglast'));
    x_xv2_ssaforecastavgsequence := Tssaforecastavgsequence(XGetProcAddress(_lib_alglib, 'alglib_xv2_ssaforecastavgsequence'));
    x_xv2_gammafunction := Tgammafunction(XGetProcAddress(_lib_alglib, 'alglib_xv2_gammafunction'));
    x_xv2_lngamma := Tlngamma(XGetProcAddress(_lib_alglib, 'alglib_xv2_lngamma'));
    x_xv2_errorfunction := Terrorfunction(XGetProcAddress(_lib_alglib, 'alglib_xv2_errorfunction'));
    x_xv2_errorfunctionc := Terrorfunctionc(XGetProcAddress(_lib_alglib, 'alglib_xv2_errorfunctionc'));
    x_xv2_normaldistribution := Tnormaldistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_normaldistribution'));
    x_xv2_normalpdf := Tnormalpdf(XGetProcAddress(_lib_alglib, 'alglib_xv2_normalpdf'));
    x_xv2_normalcdf := Tnormalcdf(XGetProcAddress(_lib_alglib, 'alglib_xv2_normalcdf'));
    x_xv2_inverf := Tinverf(XGetProcAddress(_lib_alglib, 'alglib_xv2_inverf'));
    x_xv2_invnormaldistribution := Tinvnormaldistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_invnormaldistribution'));
    x_xv2_invnormalcdf := Tinvnormalcdf(XGetProcAddress(_lib_alglib, 'alglib_xv2_invnormalcdf'));
    x_xv2_bivariatenormalpdf := Tbivariatenormalpdf(XGetProcAddress(_lib_alglib, 'alglib_xv2_bivariatenormalpdf'));
    x_xv2_bivariatenormalcdf := Tbivariatenormalcdf(XGetProcAddress(_lib_alglib, 'alglib_xv2_bivariatenormalcdf'));
    x_xv2_incompletegamma := Tincompletegamma(XGetProcAddress(_lib_alglib, 'alglib_xv2_incompletegamma'));
    x_xv2_incompletegammac := Tincompletegammac(XGetProcAddress(_lib_alglib, 'alglib_xv2_incompletegammac'));
    x_xv2_invincompletegammac := Tinvincompletegammac(XGetProcAddress(_lib_alglib, 'alglib_xv2_invincompletegammac'));
    x_obj_copy_linearmodel := Tx_obj_copy_linearmodel(XGetProcAddress(_lib_alglib, 'x_obj_copy_linearmodel'));
    x_obj_free_linearmodel := Tx_obj_free_linearmodel(XGetProcAddress(_lib_alglib, 'x_obj_free_linearmodel'));
    x_xv2_lrbuild := Tlrbuild(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrbuild'));
    x_xv2_lrbuilds := Tlrbuilds(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrbuilds'));
    x_xv2_lrbuildzs := Tlrbuildzs(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrbuildzs'));
    x_xv2_lrbuildz := Tlrbuildz(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrbuildz'));
    x_xv2_lrunpack := Tlrunpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrunpack'));
    x_xv2_lrpack := Tlrpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrpack'));
    x_xv2_lrprocess := Tlrprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrprocess'));
    x_xv2_lrrmserror := Tlrrmserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_lrrmserror'));
    x_xv2_lravgerror := Tlravgerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_lravgerror'));
    x_xv2_lravgrelerror := Tlravgrelerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_lravgrelerror'));
    x_xv2_filtersma := Tfiltersma(XGetProcAddress(_lib_alglib, 'alglib_xv2_filtersma'));
    x_xv2_filterema := Tfilterema(XGetProcAddress(_lib_alglib, 'alglib_xv2_filterema'));
    x_xv2_filterlrma := Tfilterlrma(XGetProcAddress(_lib_alglib, 'alglib_xv2_filterlrma'));
    x_obj_copy_logitmodel := Tx_obj_copy_logitmodel(XGetProcAddress(_lib_alglib, 'x_obj_copy_logitmodel'));
    x_obj_free_logitmodel := Tx_obj_free_logitmodel(XGetProcAddress(_lib_alglib, 'x_obj_free_logitmodel'));
    x_xv2_mnltrainh := Tmnltrainh(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnltrainh'));
    x_xv2_mnlprocess := Tmnlprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlprocess'));
    x_xv2_mnlprocessi := Tmnlprocessi(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlprocessi'));
    x_xv2_mnlunpack := Tmnlunpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlunpack'));
    x_xv2_mnlpack := Tmnlpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlpack'));
    x_xv2_mnlavgce := Tmnlavgce(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlavgce'));
    x_xv2_mnlrelclserror := Tmnlrelclserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlrelclserror'));
    x_xv2_mnlrmserror := Tmnlrmserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlrmserror'));
    x_xv2_mnlavgerror := Tmnlavgerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlavgerror'));
    x_xv2_mnlavgrelerror := Tmnlavgrelerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlavgrelerror'));
    x_xv2_mnlclserror := Tmnlclserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mnlclserror'));
    x_obj_copy_mcpdstate := Tx_obj_copy_mcpdstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_mcpdstate'));
    x_obj_free_mcpdstate := Tx_obj_free_mcpdstate(XGetProcAddress(_lib_alglib, 'x_obj_free_mcpdstate'));
    x_xv2_mcpdcreate := Tmcpdcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdcreate'));
    x_xv2_mcpdcreateentry := Tmcpdcreateentry(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdcreateentry'));
    x_xv2_mcpdcreateexit := Tmcpdcreateexit(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdcreateexit'));
    x_xv2_mcpdcreateentryexit := Tmcpdcreateentryexit(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdcreateentryexit'));
    x_xv2_mcpdaddtrack := Tmcpdaddtrack(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdaddtrack'));
    x_xv2_mcpdsetec := Tmcpdsetec(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdsetec'));
    x_xv2_mcpdaddec := Tmcpdaddec(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdaddec'));
    x_xv2_mcpdsetbc := Tmcpdsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdsetbc'));
    x_xv2_mcpdaddbc := Tmcpdaddbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdaddbc'));
    x_xv2_mcpdsetlc := Tmcpdsetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdsetlc'));
    x_xv2_mcpdsettikhonovregularizer := Tmcpdsettikhonovregularizer(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdsettikhonovregularizer'));
    x_xv2_mcpdsetprior := Tmcpdsetprior(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdsetprior'));
    x_xv2_mcpdsetpredictionweights := Tmcpdsetpredictionweights(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdsetpredictionweights'));
    x_xv2_mcpdsolve := Tmcpdsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdsolve'));
    x_xv2_mcpdresults := Tmcpdresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_mcpdresults'));
    x_obj_copy_mlpensemble := Tx_obj_copy_mlpensemble(XGetProcAddress(_lib_alglib, 'x_obj_copy_mlpensemble'));
    x_obj_free_mlpensemble := Tx_obj_free_mlpensemble(XGetProcAddress(_lib_alglib, 'x_obj_free_mlpensemble'));
    x_mlpeserialize := Tmlpeserialize(  XGetProcAddress(_lib_alglib, 'alglib_mlpeserialize'));
    x_mlpeunserialize := Tmlpeunserialize(XGetProcAddress(_lib_alglib, 'alglib_mlpeunserialize'));
    x_mlpeserialize_stream := Tmlpeserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_mlpeserialize_stream'));
    x_mlpeunserialize_stream := Tmlpeunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_mlpeunserialize_stream'));
    x_xv2_mlpecreate0 := Tmlpecreate0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreate0'));
    x_xv2_mlpecreate1 := Tmlpecreate1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreate1'));
    x_xv2_mlpecreate2 := Tmlpecreate2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreate2'));
    x_xv2_mlpecreateb0 := Tmlpecreateb0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreateb0'));
    x_xv2_mlpecreateb1 := Tmlpecreateb1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreateb1'));
    x_xv2_mlpecreateb2 := Tmlpecreateb2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreateb2'));
    x_xv2_mlpecreater0 := Tmlpecreater0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreater0'));
    x_xv2_mlpecreater1 := Tmlpecreater1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreater1'));
    x_xv2_mlpecreater2 := Tmlpecreater2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreater2'));
    x_xv2_mlpecreatec0 := Tmlpecreatec0(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreatec0'));
    x_xv2_mlpecreatec1 := Tmlpecreatec1(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreatec1'));
    x_xv2_mlpecreatec2 := Tmlpecreatec2(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreatec2'));
    x_xv2_mlpecreatefromnetwork := Tmlpecreatefromnetwork(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpecreatefromnetwork'));
    x_xv2_mlperandomize := Tmlperandomize(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlperandomize'));
    x_xv2_mlpeproperties := Tmlpeproperties(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpeproperties'));
    x_xv2_mlpeissoftmax := Tmlpeissoftmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpeissoftmax'));
    x_xv2_mlpeprocess := Tmlpeprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpeprocess'));
    x_xv2_mlpeprocessi := Tmlpeprocessi(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpeprocessi'));
    x_xv2_mlperelclserror := Tmlperelclserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlperelclserror'));
    x_xv2_mlpeavgce := Tmlpeavgce(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpeavgce'));
    x_xv2_mlpermserror := Tmlpermserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpermserror'));
    x_xv2_mlpeavgerror := Tmlpeavgerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpeavgerror'));
    x_xv2_mlpeavgrelerror := Tmlpeavgrelerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpeavgrelerror'));
    x_obj_copy_mlptrainer := Tx_obj_copy_mlptrainer(XGetProcAddress(_lib_alglib, 'x_obj_copy_mlptrainer'));
    x_obj_free_mlptrainer := Tx_obj_free_mlptrainer(XGetProcAddress(_lib_alglib, 'x_obj_free_mlptrainer'));
    x_xv2_mlptrainlm := Tmlptrainlm(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlptrainlm'));
    x_xv2_mlptrainlbfgs := Tmlptrainlbfgs(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlptrainlbfgs'));
    x_xv2_mlptraines := Tmlptraines(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlptraines'));
    x_xv2_mlpkfoldcvlbfgs := Tmlpkfoldcvlbfgs(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpkfoldcvlbfgs'));
    x_xv2_mlpkfoldcvlm := Tmlpkfoldcvlm(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpkfoldcvlm'));
    x_xv2_mlpkfoldcv := Tmlpkfoldcv(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpkfoldcv'));
    x_xv2_mlpcreatetrainer := Tmlpcreatetrainer(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreatetrainer'));
    x_xv2_mlpcreatetrainercls := Tmlpcreatetrainercls(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcreatetrainercls'));
    x_xv2_mlpsetdataset := Tmlpsetdataset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetdataset'));
    x_xv2_mlpsetsparsedataset := Tmlpsetsparsedataset(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetsparsedataset'));
    x_xv2_mlpsetdecay := Tmlpsetdecay(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetdecay'));
    x_xv2_mlpsetcond := Tmlpsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetcond'));
    x_xv2_mlpsetalgobatch := Tmlpsetalgobatch(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpsetalgobatch'));
    x_xv2_mlptrainnetwork := Tmlptrainnetwork(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlptrainnetwork'));
    x_xv2_mlpstarttraining := Tmlpstarttraining(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpstarttraining'));
    x_xv2_mlpcontinuetraining := Tmlpcontinuetraining(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpcontinuetraining'));
    x_xv2_mlpebagginglm := Tmlpebagginglm(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpebagginglm'));
    x_xv2_mlpebagginglbfgs := Tmlpebagginglbfgs(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpebagginglbfgs'));
    x_xv2_mlpetraines := Tmlpetraines(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlpetraines'));
    x_xv2_mlptrainensemblees := Tmlptrainensemblees(XGetProcAddress(_lib_alglib, 'alglib_xv2_mlptrainensemblees'));
    x_obj_copy_clusterizerstate := Tx_obj_copy_clusterizerstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_clusterizerstate'));
    x_obj_free_clusterizerstate := Tx_obj_free_clusterizerstate(XGetProcAddress(_lib_alglib, 'x_obj_free_clusterizerstate'));
    x_xv2_clusterizercreate := Tclusterizercreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizercreate'));
    x_xv2_clusterizersetpoints := Tclusterizersetpoints(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizersetpoints'));
    x_xv2_clusterizersetdistances := Tclusterizersetdistances(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizersetdistances'));
    x_xv2_clusterizersetahcalgo := Tclusterizersetahcalgo(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizersetahcalgo'));
    x_xv2_clusterizersetkmeanslimits := Tclusterizersetkmeanslimits(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizersetkmeanslimits'));
    x_xv2_clusterizersetkmeansinit := Tclusterizersetkmeansinit(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizersetkmeansinit'));
    x_xv2_clusterizersetseed := Tclusterizersetseed(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizersetseed'));
    x_xv2_clusterizerrunahc := Tclusterizerrunahc(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizerrunahc'));
    x_xv2_clusterizerrunkmeans := Tclusterizerrunkmeans(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizerrunkmeans'));
    x_xv2_clusterizergetdistances := Tclusterizergetdistances(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizergetdistances'));
    x_xv2_clusterizergetkclusters := Tclusterizergetkclusters(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizergetkclusters'));
    x_xv2_clusterizerseparatedbydist := Tclusterizerseparatedbydist(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizerseparatedbydist'));
    x_xv2_clusterizerseparatedbycorr := Tclusterizerseparatedbycorr(XGetProcAddress(_lib_alglib, 'alglib_xv2_clusterizerseparatedbycorr'));
    x_obj_copy_decisionforestbuilder := Tx_obj_copy_decisionforestbuilder(XGetProcAddress(_lib_alglib, 'x_obj_copy_decisionforestbuilder'));
    x_obj_free_decisionforestbuilder := Tx_obj_free_decisionforestbuilder(XGetProcAddress(_lib_alglib, 'x_obj_free_decisionforestbuilder'));
    x_obj_copy_decisionforestbuffer := Tx_obj_copy_decisionforestbuffer(XGetProcAddress(_lib_alglib, 'x_obj_copy_decisionforestbuffer'));
    x_obj_free_decisionforestbuffer := Tx_obj_free_decisionforestbuffer(XGetProcAddress(_lib_alglib, 'x_obj_free_decisionforestbuffer'));
    x_obj_copy_decisionforest := Tx_obj_copy_decisionforest(XGetProcAddress(_lib_alglib, 'x_obj_copy_decisionforest'));
    x_obj_free_decisionforest := Tx_obj_free_decisionforest(XGetProcAddress(_lib_alglib, 'x_obj_free_decisionforest'));
    x_dfserialize := Tdfserialize(  XGetProcAddress(_lib_alglib, 'alglib_dfserialize'));
    x_dfunserialize := Tdfunserialize(XGetProcAddress(_lib_alglib, 'alglib_dfunserialize'));
    x_dfserialize_stream := Tdfserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_dfserialize_stream'));
    x_dfunserialize_stream := Tdfunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_dfunserialize_stream'));
    x_xv2_dfcreatebuffer := Tdfcreatebuffer(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfcreatebuffer'));
    x_xv2_dfbuildercreate := Tdfbuildercreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildercreate'));
    x_xv2_dfbuildersetdataset := Tdfbuildersetdataset(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetdataset'));
    x_xv2_dfbuildersetrndvars := Tdfbuildersetrndvars(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetrndvars'));
    x_xv2_dfbuildersetrndvarsratio := Tdfbuildersetrndvarsratio(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetrndvarsratio'));
    x_xv2_dfbuildersetrndvarsauto := Tdfbuildersetrndvarsauto(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetrndvarsauto'));
    x_xv2_dfbuildersetsubsampleratio := Tdfbuildersetsubsampleratio(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetsubsampleratio'));
    x_xv2_dfbuildersetseed := Tdfbuildersetseed(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetseed'));
    x_xv2_dfbuildersetrdfalgo := Tdfbuildersetrdfalgo(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetrdfalgo'));
    x_xv2_dfbuildersetrdfsplitstrength := Tdfbuildersetrdfsplitstrength(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetrdfsplitstrength'));
    x_xv2_dfbuildersetimportancetrngini := Tdfbuildersetimportancetrngini(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetimportancetrngini'));
    x_xv2_dfbuildersetimportanceoobgini := Tdfbuildersetimportanceoobgini(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetimportanceoobgini'));
    x_xv2_dfbuildersetimportancepermutation := Tdfbuildersetimportancepermutation(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetimportancepermutation'));
    x_xv2_dfbuildersetimportancenone := Tdfbuildersetimportancenone(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildersetimportancenone'));
    x_xv2_dfbuildergetprogress := Tdfbuildergetprogress(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildergetprogress'));
    x_xv2_dfbuilderpeekprogress := Tdfbuilderpeekprogress(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuilderpeekprogress'));
    x_xv2_dfbuilderbuildrandomforest := Tdfbuilderbuildrandomforest(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuilderbuildrandomforest'));
    x_xv2_dfbinarycompression := Tdfbinarycompression(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbinarycompression'));
    x_xv2_dfprocess := Tdfprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfprocess'));
    x_xv2_dfprocessi := Tdfprocessi(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfprocessi'));
    x_xv2_dfprocess0 := Tdfprocess0(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfprocess0'));
    x_xv2_dfclassify := Tdfclassify(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfclassify'));
    x_xv2_dftsprocess := Tdftsprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_dftsprocess'));
    x_xv2_dfrelclserror := Tdfrelclserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfrelclserror'));
    x_xv2_dfavgce := Tdfavgce(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfavgce'));
    x_xv2_dfrmserror := Tdfrmserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfrmserror'));
    x_xv2_dfavgerror := Tdfavgerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfavgerror'));
    x_xv2_dfavgrelerror := Tdfavgrelerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfavgrelerror'));
    x_xv2_dfbuildrandomdecisionforest := Tdfbuildrandomdecisionforest(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildrandomdecisionforest'));
    x_xv2_dfbuildrandomdecisionforestx1 := Tdfbuildrandomdecisionforestx1(XGetProcAddress(_lib_alglib, 'alglib_xv2_dfbuildrandomdecisionforestx1'));
    x_obj_copy_knnbuffer := Tx_obj_copy_knnbuffer(XGetProcAddress(_lib_alglib, 'x_obj_copy_knnbuffer'));
    x_obj_free_knnbuffer := Tx_obj_free_knnbuffer(XGetProcAddress(_lib_alglib, 'x_obj_free_knnbuffer'));
    x_obj_copy_knnbuilder := Tx_obj_copy_knnbuilder(XGetProcAddress(_lib_alglib, 'x_obj_copy_knnbuilder'));
    x_obj_free_knnbuilder := Tx_obj_free_knnbuilder(XGetProcAddress(_lib_alglib, 'x_obj_free_knnbuilder'));
    x_obj_copy_knnmodel := Tx_obj_copy_knnmodel(XGetProcAddress(_lib_alglib, 'x_obj_copy_knnmodel'));
    x_obj_free_knnmodel := Tx_obj_free_knnmodel(XGetProcAddress(_lib_alglib, 'x_obj_free_knnmodel'));
    x_knnserialize := Tknnserialize(  XGetProcAddress(_lib_alglib, 'alglib_knnserialize'));
    x_knnunserialize := Tknnunserialize(XGetProcAddress(_lib_alglib, 'alglib_knnunserialize'));
    x_knnserialize_stream := Tknnserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_knnserialize_stream'));
    x_knnunserialize_stream := Tknnunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_knnunserialize_stream'));
    x_xv2_knncreatebuffer := Tknncreatebuffer(XGetProcAddress(_lib_alglib, 'alglib_xv2_knncreatebuffer'));
    x_xv2_knnbuildercreate := Tknnbuildercreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnbuildercreate'));
    x_xv2_knnbuildersetdatasetreg := Tknnbuildersetdatasetreg(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnbuildersetdatasetreg'));
    x_xv2_knnbuildersetdatasetcls := Tknnbuildersetdatasetcls(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnbuildersetdatasetcls'));
    x_xv2_knnbuildersetnorm := Tknnbuildersetnorm(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnbuildersetnorm'));
    x_xv2_knnbuilderbuildknnmodel := Tknnbuilderbuildknnmodel(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnbuilderbuildknnmodel'));
    x_xv2_knnrewritekeps := Tknnrewritekeps(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnrewritekeps'));
    x_xv2_knnprocess := Tknnprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnprocess'));
    x_xv2_knnprocess0 := Tknnprocess0(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnprocess0'));
    x_xv2_knnclassify := Tknnclassify(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnclassify'));
    x_xv2_knnprocessi := Tknnprocessi(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnprocessi'));
    x_xv2_knntsprocess := Tknntsprocess(XGetProcAddress(_lib_alglib, 'alglib_xv2_knntsprocess'));
    x_xv2_knnrelclserror := Tknnrelclserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnrelclserror'));
    x_xv2_knnavgce := Tknnavgce(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnavgce'));
    x_xv2_knnrmserror := Tknnrmserror(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnrmserror'));
    x_xv2_knnavgerror := Tknnavgerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnavgerror'));
    x_xv2_knnavgrelerror := Tknnavgrelerror(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnavgrelerror'));
    x_xv2_knnallerrors := Tknnallerrors(XGetProcAddress(_lib_alglib, 'alglib_xv2_knnallerrors'));
    x_xv2_kmeansgenerate := Tkmeansgenerate(XGetProcAddress(_lib_alglib, 'alglib_xv2_kmeansgenerate'));
    x_xv2_gqgeneraterec := Tgqgeneraterec(XGetProcAddress(_lib_alglib, 'alglib_xv2_gqgeneraterec'));
    x_xv2_gqgenerategausslobattorec := Tgqgenerategausslobattorec(XGetProcAddress(_lib_alglib, 'alglib_xv2_gqgenerategausslobattorec'));
    x_xv2_gqgenerategaussradaurec := Tgqgenerategaussradaurec(XGetProcAddress(_lib_alglib, 'alglib_xv2_gqgenerategaussradaurec'));
    x_xv2_gqgenerategausslegendre := Tgqgenerategausslegendre(XGetProcAddress(_lib_alglib, 'alglib_xv2_gqgenerategausslegendre'));
    x_xv2_gqgenerategaussjacobi := Tgqgenerategaussjacobi(XGetProcAddress(_lib_alglib, 'alglib_xv2_gqgenerategaussjacobi'));
    x_xv2_gqgenerategausslaguerre := Tgqgenerategausslaguerre(XGetProcAddress(_lib_alglib, 'alglib_xv2_gqgenerategausslaguerre'));
    x_xv2_gqgenerategausshermite := Tgqgenerategausshermite(XGetProcAddress(_lib_alglib, 'alglib_xv2_gqgenerategausshermite'));
    x_xv2_gkqgeneraterec := Tgkqgeneraterec(XGetProcAddress(_lib_alglib, 'alglib_xv2_gkqgeneraterec'));
    x_xv2_gkqgenerategausslegendre := Tgkqgenerategausslegendre(XGetProcAddress(_lib_alglib, 'alglib_xv2_gkqgenerategausslegendre'));
    x_xv2_gkqgenerategaussjacobi := Tgkqgenerategaussjacobi(XGetProcAddress(_lib_alglib, 'alglib_xv2_gkqgenerategaussjacobi'));
    x_xv2_gkqlegendrecalc := Tgkqlegendrecalc(XGetProcAddress(_lib_alglib, 'alglib_xv2_gkqlegendrecalc'));
    x_xv2_gkqlegendretbl := Tgkqlegendretbl(XGetProcAddress(_lib_alglib, 'alglib_xv2_gkqlegendretbl'));
    x_obj_copy_autogkstate := Tx_obj_copy_autogkstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_autogkstate'));
    x_obj_free_autogkstate := Tx_obj_free_autogkstate(XGetProcAddress(_lib_alglib, 'x_obj_free_autogkstate'));
    x_autogkstate_get_needf := Tx_autogkstate_get_needf(XGetProcAddress(_lib_alglib, 'x_autogkstate_get_needf'));
    Touch(x_autogkstate_get_needf); // avoid messages about unused variables
    x_autogkstate_set_needf := Tx_autogkstate_set_needf(XGetProcAddress(_lib_alglib, 'x_autogkstate_set_needf'));
    Touch(x_autogkstate_set_needf);
    x_autogkstate_get_x := Tx_autogkstate_get_x(XGetProcAddress(_lib_alglib, 'x_autogkstate_get_x'));
    Touch(x_autogkstate_get_x); // avoid messages about unused variables
    x_autogkstate_set_x := Tx_autogkstate_set_x(XGetProcAddress(_lib_alglib, 'x_autogkstate_set_x'));
    Touch(x_autogkstate_set_x);
    x_autogkstate_get_xminusa := Tx_autogkstate_get_xminusa(XGetProcAddress(_lib_alglib, 'x_autogkstate_get_xminusa'));
    Touch(x_autogkstate_get_xminusa); // avoid messages about unused variables
    x_autogkstate_set_xminusa := Tx_autogkstate_set_xminusa(XGetProcAddress(_lib_alglib, 'x_autogkstate_set_xminusa'));
    Touch(x_autogkstate_set_xminusa);
    x_autogkstate_get_bminusx := Tx_autogkstate_get_bminusx(XGetProcAddress(_lib_alglib, 'x_autogkstate_get_bminusx'));
    Touch(x_autogkstate_get_bminusx); // avoid messages about unused variables
    x_autogkstate_set_bminusx := Tx_autogkstate_set_bminusx(XGetProcAddress(_lib_alglib, 'x_autogkstate_set_bminusx'));
    Touch(x_autogkstate_set_bminusx);
    x_autogkstate_get_f := Tx_autogkstate_get_f(XGetProcAddress(_lib_alglib, 'x_autogkstate_get_f'));
    Touch(x_autogkstate_get_f); // avoid messages about unused variables
    x_autogkstate_set_f := Tx_autogkstate_set_f(XGetProcAddress(_lib_alglib, 'x_autogkstate_set_f'));
    Touch(x_autogkstate_set_f);
    x_xv2_autogksmooth := Tautogksmooth(XGetProcAddress(_lib_alglib, 'alglib_xv2_autogksmooth'));
    x_xv2_autogksmoothw := Tautogksmoothw(XGetProcAddress(_lib_alglib, 'alglib_xv2_autogksmoothw'));
    x_xv2_autogksingular := Tautogksingular(XGetProcAddress(_lib_alglib, 'alglib_xv2_autogksingular'));
    x_xv2_autogkiteration := Tautogkiteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_autogkiteration'));
    x_xv2_autogkresults := Tautogkresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_autogkresults'));
    x_xv2_fftc1d := Tfftc1d(XGetProcAddress(_lib_alglib, 'alglib_xv2_fftc1d'));
    x_xv2_fftc1dinv := Tfftc1dinv(XGetProcAddress(_lib_alglib, 'alglib_xv2_fftc1dinv'));
    x_xv2_fftr1d := Tfftr1d(XGetProcAddress(_lib_alglib, 'alglib_xv2_fftr1d'));
    x_xv2_fftr1dinv := Tfftr1dinv(XGetProcAddress(_lib_alglib, 'alglib_xv2_fftr1dinv'));
    x_xv2_fhtr1d := Tfhtr1d(XGetProcAddress(_lib_alglib, 'alglib_xv2_fhtr1d'));
    x_xv2_fhtr1dinv := Tfhtr1dinv(XGetProcAddress(_lib_alglib, 'alglib_xv2_fhtr1dinv'));
    x_xv2_convc1d := Tconvc1d(XGetProcAddress(_lib_alglib, 'alglib_xv2_convc1d'));
    x_xv2_convc1dinv := Tconvc1dinv(XGetProcAddress(_lib_alglib, 'alglib_xv2_convc1dinv'));
    x_xv2_convc1dcircular := Tconvc1dcircular(XGetProcAddress(_lib_alglib, 'alglib_xv2_convc1dcircular'));
    x_xv2_convc1dcircularinv := Tconvc1dcircularinv(XGetProcAddress(_lib_alglib, 'alglib_xv2_convc1dcircularinv'));
    x_xv2_convr1d := Tconvr1d(XGetProcAddress(_lib_alglib, 'alglib_xv2_convr1d'));
    x_xv2_convr1dinv := Tconvr1dinv(XGetProcAddress(_lib_alglib, 'alglib_xv2_convr1dinv'));
    x_xv2_convr1dcircular := Tconvr1dcircular(XGetProcAddress(_lib_alglib, 'alglib_xv2_convr1dcircular'));
    x_xv2_convr1dcircularinv := Tconvr1dcircularinv(XGetProcAddress(_lib_alglib, 'alglib_xv2_convr1dcircularinv'));
    x_xv2_corrc1d := Tcorrc1d(XGetProcAddress(_lib_alglib, 'alglib_xv2_corrc1d'));
    x_xv2_corrc1dcircular := Tcorrc1dcircular(XGetProcAddress(_lib_alglib, 'alglib_xv2_corrc1dcircular'));
    x_xv2_corrr1d := Tcorrr1d(XGetProcAddress(_lib_alglib, 'alglib_xv2_corrr1d'));
    x_xv2_corrr1dcircular := Tcorrr1dcircular(XGetProcAddress(_lib_alglib, 'alglib_xv2_corrr1dcircular'));
    x_obj_copy_idwcalcbuffer := Tx_obj_copy_idwcalcbuffer(XGetProcAddress(_lib_alglib, 'x_obj_copy_idwcalcbuffer'));
    x_obj_free_idwcalcbuffer := Tx_obj_free_idwcalcbuffer(XGetProcAddress(_lib_alglib, 'x_obj_free_idwcalcbuffer'));
    x_obj_copy_idwmodel := Tx_obj_copy_idwmodel(XGetProcAddress(_lib_alglib, 'x_obj_copy_idwmodel'));
    x_obj_free_idwmodel := Tx_obj_free_idwmodel(XGetProcAddress(_lib_alglib, 'x_obj_free_idwmodel'));
    x_obj_copy_idwbuilder := Tx_obj_copy_idwbuilder(XGetProcAddress(_lib_alglib, 'x_obj_copy_idwbuilder'));
    x_obj_free_idwbuilder := Tx_obj_free_idwbuilder(XGetProcAddress(_lib_alglib, 'x_obj_free_idwbuilder'));
    x_idwserialize := Tidwserialize(  XGetProcAddress(_lib_alglib, 'alglib_idwserialize'));
    x_idwunserialize := Tidwunserialize(XGetProcAddress(_lib_alglib, 'alglib_idwunserialize'));
    x_idwserialize_stream := Tidwserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_idwserialize_stream'));
    x_idwunserialize_stream := Tidwunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_idwunserialize_stream'));
    x_xv2_idwcreatecalcbuffer := Tidwcreatecalcbuffer(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwcreatecalcbuffer'));
    x_xv2_idwbuildercreate := Tidwbuildercreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildercreate'));
    x_xv2_idwbuildersetnlayers := Tidwbuildersetnlayers(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetnlayers'));
    x_xv2_idwbuildersetpoints := Tidwbuildersetpoints(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetpoints'));
    x_xv2_idwbuildersetalgomstab := Tidwbuildersetalgomstab(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetalgomstab'));
    x_xv2_idwbuildersetalgotextbookshepard := Tidwbuildersetalgotextbookshepard(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetalgotextbookshepard'));
    x_xv2_idwbuildersetalgotextbookmodshepard := Tidwbuildersetalgotextbookmodshepard(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetalgotextbookmodshepard'));
    x_xv2_idwbuildersetuserterm := Tidwbuildersetuserterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetuserterm'));
    x_xv2_idwbuildersetconstterm := Tidwbuildersetconstterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetconstterm'));
    x_xv2_idwbuildersetzeroterm := Tidwbuildersetzeroterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwbuildersetzeroterm'));
    x_xv2_idwcalc1 := Tidwcalc1(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwcalc1'));
    x_xv2_idwcalc2 := Tidwcalc2(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwcalc2'));
    x_xv2_idwcalc3 := Tidwcalc3(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwcalc3'));
    x_xv2_idwcalc := Tidwcalc(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwcalc'));
    x_xv2_idwcalcbuf := Tidwcalcbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwcalcbuf'));
    x_xv2_idwtscalcbuf := Tidwtscalcbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwtscalcbuf'));
    x_xv2_idwfit := Tidwfit(XGetProcAddress(_lib_alglib, 'alglib_xv2_idwfit'));
    x_obj_copy_barycentricinterpolant := Tx_obj_copy_barycentricinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_copy_barycentricinterpolant'));
    x_obj_free_barycentricinterpolant := Tx_obj_free_barycentricinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_free_barycentricinterpolant'));
    x_xv2_barycentriccalc := Tbarycentriccalc(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentriccalc'));
    x_xv2_barycentricdiff1 := Tbarycentricdiff1(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentricdiff1'));
    x_xv2_barycentricdiff2 := Tbarycentricdiff2(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentricdiff2'));
    x_xv2_barycentriclintransx := Tbarycentriclintransx(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentriclintransx'));
    x_xv2_barycentriclintransy := Tbarycentriclintransy(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentriclintransy'));
    x_xv2_barycentricunpack := Tbarycentricunpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentricunpack'));
    x_xv2_barycentricbuildxyw := Tbarycentricbuildxyw(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentricbuildxyw'));
    x_xv2_barycentricbuildfloaterhormann := Tbarycentricbuildfloaterhormann(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentricbuildfloaterhormann'));
    x_xv2_fitspherels := Tfitspherels(XGetProcAddress(_lib_alglib, 'alglib_xv2_fitspherels'));
    x_xv2_fitspheremc := Tfitspheremc(XGetProcAddress(_lib_alglib, 'alglib_xv2_fitspheremc'));
    x_xv2_fitspheremi := Tfitspheremi(XGetProcAddress(_lib_alglib, 'alglib_xv2_fitspheremi'));
    x_xv2_fitspheremz := Tfitspheremz(XGetProcAddress(_lib_alglib, 'alglib_xv2_fitspheremz'));
    x_xv2_fitspherex := Tfitspherex(XGetProcAddress(_lib_alglib, 'alglib_xv2_fitspherex'));
    x_obj_copy_spline1dinterpolant := Tx_obj_copy_spline1dinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_copy_spline1dinterpolant'));
    x_obj_free_spline1dinterpolant := Tx_obj_free_spline1dinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_free_spline1dinterpolant'));
    x_xv2_spline1dbuildlinear := Tspline1dbuildlinear(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dbuildlinear'));
    x_xv2_spline1dbuildcubic := Tspline1dbuildcubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dbuildcubic'));
    x_xv2_spline1dgriddiffcubic := Tspline1dgriddiffcubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dgriddiffcubic'));
    x_xv2_spline1dgriddiff2cubic := Tspline1dgriddiff2cubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dgriddiff2cubic'));
    x_xv2_spline1dconvcubic := Tspline1dconvcubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dconvcubic'));
    x_xv2_spline1dconvdiffcubic := Tspline1dconvdiffcubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dconvdiffcubic'));
    x_xv2_spline1dconvdiff2cubic := Tspline1dconvdiff2cubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dconvdiff2cubic'));
    x_xv2_spline1dbuildcatmullrom := Tspline1dbuildcatmullrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dbuildcatmullrom'));
    x_xv2_spline1dbuildhermite := Tspline1dbuildhermite(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dbuildhermite'));
    x_xv2_spline1dbuildakima := Tspline1dbuildakima(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dbuildakima'));
    x_xv2_spline1dcalc := Tspline1dcalc(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dcalc'));
    x_xv2_spline1ddiff := Tspline1ddiff(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1ddiff'));
    x_xv2_spline1dunpack := Tspline1dunpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dunpack'));
    x_xv2_spline1dlintransx := Tspline1dlintransx(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dlintransx'));
    x_xv2_spline1dlintransy := Tspline1dlintransy(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dlintransy'));
    x_xv2_spline1dintegrate := Tspline1dintegrate(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dintegrate'));
    x_xv2_spline1dfit := Tspline1dfit(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dfit'));
    x_xv2_spline1dbuildmonotone := Tspline1dbuildmonotone(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dbuildmonotone'));
    x_obj_copy_pspline2interpolant := Tx_obj_copy_pspline2interpolant(XGetProcAddress(_lib_alglib, 'x_obj_copy_pspline2interpolant'));
    x_obj_free_pspline2interpolant := Tx_obj_free_pspline2interpolant(XGetProcAddress(_lib_alglib, 'x_obj_free_pspline2interpolant'));
    x_obj_copy_pspline3interpolant := Tx_obj_copy_pspline3interpolant(XGetProcAddress(_lib_alglib, 'x_obj_copy_pspline3interpolant'));
    x_obj_free_pspline3interpolant := Tx_obj_free_pspline3interpolant(XGetProcAddress(_lib_alglib, 'x_obj_free_pspline3interpolant'));
    x_xv2_pspline2build := Tpspline2build(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2build'));
    x_xv2_pspline3build := Tpspline3build(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3build'));
    x_xv2_pspline2buildperiodic := Tpspline2buildperiodic(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2buildperiodic'));
    x_xv2_pspline3buildperiodic := Tpspline3buildperiodic(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3buildperiodic'));
    x_xv2_pspline2parametervalues := Tpspline2parametervalues(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2parametervalues'));
    x_xv2_pspline3parametervalues := Tpspline3parametervalues(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3parametervalues'));
    x_xv2_pspline2calc := Tpspline2calc(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2calc'));
    x_xv2_pspline3calc := Tpspline3calc(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3calc'));
    x_xv2_pspline2tangent := Tpspline2tangent(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2tangent'));
    x_xv2_pspline3tangent := Tpspline3tangent(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3tangent'));
    x_xv2_pspline2diff := Tpspline2diff(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2diff'));
    x_xv2_pspline3diff := Tpspline3diff(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3diff'));
    x_xv2_pspline2diff2 := Tpspline2diff2(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2diff2'));
    x_xv2_pspline3diff2 := Tpspline3diff2(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3diff2'));
    x_xv2_pspline2arclength := Tpspline2arclength(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline2arclength'));
    x_xv2_pspline3arclength := Tpspline3arclength(XGetProcAddress(_lib_alglib, 'alglib_xv2_pspline3arclength'));
    x_xv2_parametricrdpfixed := Tparametricrdpfixed(XGetProcAddress(_lib_alglib, 'alglib_xv2_parametricrdpfixed'));
    x_obj_copy_spline3dinterpolant := Tx_obj_copy_spline3dinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_copy_spline3dinterpolant'));
    x_obj_free_spline3dinterpolant := Tx_obj_free_spline3dinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_free_spline3dinterpolant'));
    x_xv2_spline3dcalc := Tspline3dcalc(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dcalc'));
    x_xv2_spline3dlintransxyz := Tspline3dlintransxyz(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dlintransxyz'));
    x_xv2_spline3dlintransf := Tspline3dlintransf(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dlintransf'));
    x_xv2_spline3dresampletrilinear := Tspline3dresampletrilinear(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dresampletrilinear'));
    x_xv2_spline3dbuildtrilinearv := Tspline3dbuildtrilinearv(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dbuildtrilinearv'));
    x_xv2_spline3dcalcvbuf := Tspline3dcalcvbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dcalcvbuf'));
    x_xv2_spline3dcalcv := Tspline3dcalcv(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dcalcv'));
    x_xv2_spline3dunpackv := Tspline3dunpackv(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline3dunpackv'));
    x_xv2_polynomialbar2cheb := Tpolynomialbar2cheb(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialbar2cheb'));
    x_xv2_polynomialcheb2bar := Tpolynomialcheb2bar(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialcheb2bar'));
    x_xv2_polynomialbar2pow := Tpolynomialbar2pow(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialbar2pow'));
    x_xv2_polynomialpow2bar := Tpolynomialpow2bar(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialpow2bar'));
    x_xv2_polynomialbuild := Tpolynomialbuild(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialbuild'));
    x_xv2_polynomialbuildeqdist := Tpolynomialbuildeqdist(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialbuildeqdist'));
    x_xv2_polynomialbuildcheb1 := Tpolynomialbuildcheb1(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialbuildcheb1'));
    x_xv2_polynomialbuildcheb2 := Tpolynomialbuildcheb2(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialbuildcheb2'));
    x_xv2_polynomialcalceqdist := Tpolynomialcalceqdist(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialcalceqdist'));
    x_xv2_polynomialcalccheb1 := Tpolynomialcalccheb1(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialcalccheb1'));
    x_xv2_polynomialcalccheb2 := Tpolynomialcalccheb2(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialcalccheb2'));
    x_obj_copy_lsfitstate := Tx_obj_copy_lsfitstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_lsfitstate'));
    x_obj_free_lsfitstate := Tx_obj_free_lsfitstate(XGetProcAddress(_lib_alglib, 'x_obj_free_lsfitstate'));
    x_lsfitstate_get_needf := Tx_lsfitstate_get_needf(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_needf'));
    Touch(x_lsfitstate_get_needf); // avoid messages about unused variables
    x_lsfitstate_set_needf := Tx_lsfitstate_set_needf(XGetProcAddress(_lib_alglib, 'x_lsfitstate_set_needf'));
    Touch(x_lsfitstate_set_needf);
    x_lsfitstate_get_needfg := Tx_lsfitstate_get_needfg(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_needfg'));
    Touch(x_lsfitstate_get_needfg); // avoid messages about unused variables
    x_lsfitstate_set_needfg := Tx_lsfitstate_set_needfg(XGetProcAddress(_lib_alglib, 'x_lsfitstate_set_needfg'));
    Touch(x_lsfitstate_set_needfg);
    x_lsfitstate_get_needfgh := Tx_lsfitstate_get_needfgh(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_needfgh'));
    Touch(x_lsfitstate_get_needfgh); // avoid messages about unused variables
    x_lsfitstate_set_needfgh := Tx_lsfitstate_set_needfgh(XGetProcAddress(_lib_alglib, 'x_lsfitstate_set_needfgh'));
    Touch(x_lsfitstate_set_needfgh);
    x_lsfitstate_get_xupdated := Tx_lsfitstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_xupdated'));
    Touch(x_lsfitstate_get_xupdated); // avoid messages about unused variables
    x_lsfitstate_set_xupdated := Tx_lsfitstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_lsfitstate_set_xupdated'));
    Touch(x_lsfitstate_set_xupdated);
    x_lsfitstate_get_c := Tx_lsfitstate_get_c(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_c'));
    Touch(x_lsfitstate_get_c); // avoid messages about unused variables
    x_lsfitstate_get_f := Tx_lsfitstate_get_f(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_f'));
    Touch(x_lsfitstate_get_f); // avoid messages about unused variables
    x_lsfitstate_set_f := Tx_lsfitstate_set_f(XGetProcAddress(_lib_alglib, 'x_lsfitstate_set_f'));
    Touch(x_lsfitstate_set_f);
    x_lsfitstate_get_g := Tx_lsfitstate_get_g(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_g'));
    Touch(x_lsfitstate_get_g); // avoid messages about unused variables
    x_lsfitstate_get_h := Tx_lsfitstate_get_h(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_h'));
    Touch(x_lsfitstate_get_h); // avoid messages about unused variables
    x_lsfitstate_get_x := Tx_lsfitstate_get_x(XGetProcAddress(_lib_alglib, 'x_lsfitstate_get_x'));
    Touch(x_lsfitstate_get_x); // avoid messages about unused variables
    x_xv2_lstfitpiecewiselinearrdpfixed := Tlstfitpiecewiselinearrdpfixed(XGetProcAddress(_lib_alglib, 'alglib_xv2_lstfitpiecewiselinearrdpfixed'));
    x_xv2_lstfitpiecewiselinearrdp := Tlstfitpiecewiselinearrdp(XGetProcAddress(_lib_alglib, 'alglib_xv2_lstfitpiecewiselinearrdp'));
    x_xv2_polynomialfit := Tpolynomialfit(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialfit'));
    x_xv2_polynomialfitwc := Tpolynomialfitwc(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialfitwc'));
    x_xv2_logisticcalc4 := Tlogisticcalc4(XGetProcAddress(_lib_alglib, 'alglib_xv2_logisticcalc4'));
    x_xv2_logisticcalc5 := Tlogisticcalc5(XGetProcAddress(_lib_alglib, 'alglib_xv2_logisticcalc5'));
    x_xv2_logisticfit4 := Tlogisticfit4(XGetProcAddress(_lib_alglib, 'alglib_xv2_logisticfit4'));
    x_xv2_logisticfit4ec := Tlogisticfit4ec(XGetProcAddress(_lib_alglib, 'alglib_xv2_logisticfit4ec'));
    x_xv2_logisticfit5 := Tlogisticfit5(XGetProcAddress(_lib_alglib, 'alglib_xv2_logisticfit5'));
    x_xv2_logisticfit5ec := Tlogisticfit5ec(XGetProcAddress(_lib_alglib, 'alglib_xv2_logisticfit5ec'));
    x_xv2_logisticfit45x := Tlogisticfit45x(XGetProcAddress(_lib_alglib, 'alglib_xv2_logisticfit45x'));
    x_xv2_barycentricfitfloaterhormannwc := Tbarycentricfitfloaterhormannwc(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentricfitfloaterhormannwc'));
    x_xv2_barycentricfitfloaterhormann := Tbarycentricfitfloaterhormann(XGetProcAddress(_lib_alglib, 'alglib_xv2_barycentricfitfloaterhormann'));
    x_xv2_spline1dfitcubicwc := Tspline1dfitcubicwc(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dfitcubicwc'));
    x_xv2_spline1dfithermitewc := Tspline1dfithermitewc(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dfithermitewc'));
    x_xv2_spline1dfitcubic := Tspline1dfitcubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dfitcubic'));
    x_xv2_spline1dfithermite := Tspline1dfithermite(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dfithermite'));
    x_xv2_lsfitlinearw := Tlsfitlinearw(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitlinearw'));
    x_xv2_lsfitlinearwc := Tlsfitlinearwc(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitlinearwc'));
    x_xv2_lsfitlinear := Tlsfitlinear(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitlinear'));
    x_xv2_lsfitlinearc := Tlsfitlinearc(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitlinearc'));
    x_xv2_lsfitcreatewf := Tlsfitcreatewf(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitcreatewf'));
    x_xv2_lsfitcreatef := Tlsfitcreatef(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitcreatef'));
    x_xv2_lsfitcreatewfg := Tlsfitcreatewfg(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitcreatewfg'));
    x_xv2_lsfitcreatefg := Tlsfitcreatefg(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitcreatefg'));
    x_xv2_lsfitcreatewfgh := Tlsfitcreatewfgh(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitcreatewfgh'));
    x_xv2_lsfitcreatefgh := Tlsfitcreatefgh(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitcreatefgh'));
    x_xv2_lsfitsetcond := Tlsfitsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitsetcond'));
    x_xv2_lsfitsetstpmax := Tlsfitsetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitsetstpmax'));
    x_xv2_lsfitsetxrep := Tlsfitsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitsetxrep'));
    x_xv2_lsfitsetscale := Tlsfitsetscale(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitsetscale'));
    x_xv2_lsfitsetbc := Tlsfitsetbc(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitsetbc'));
    x_xv2_lsfitsetlc := Tlsfitsetlc(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitsetlc'));
    x_xv2_lsfititeration := Tlsfititeration(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfititeration'));
    x_xv2_lsfitresults := Tlsfitresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitresults'));
    x_xv2_lsfitsetgradientcheck := Tlsfitsetgradientcheck(XGetProcAddress(_lib_alglib, 'alglib_xv2_lsfitsetgradientcheck'));
    x_obj_copy_spline2dinterpolant := Tx_obj_copy_spline2dinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_copy_spline2dinterpolant'));
    x_obj_free_spline2dinterpolant := Tx_obj_free_spline2dinterpolant(XGetProcAddress(_lib_alglib, 'x_obj_free_spline2dinterpolant'));
    x_obj_copy_spline2dbuilder := Tx_obj_copy_spline2dbuilder(XGetProcAddress(_lib_alglib, 'x_obj_copy_spline2dbuilder'));
    x_obj_free_spline2dbuilder := Tx_obj_free_spline2dbuilder(XGetProcAddress(_lib_alglib, 'x_obj_free_spline2dbuilder'));
    x_spline2dserialize := Tspline2dserialize(  XGetProcAddress(_lib_alglib, 'alglib_spline2dserialize'));
    x_spline2dunserialize := Tspline2dunserialize(XGetProcAddress(_lib_alglib, 'alglib_spline2dunserialize'));
    x_spline2dserialize_stream := Tspline2dserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_spline2dserialize_stream'));
    x_spline2dunserialize_stream := Tspline2dunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_spline2dunserialize_stream'));
    x_xv2_spline2dcalc := Tspline2dcalc(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dcalc'));
    x_xv2_spline2ddiff := Tspline2ddiff(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2ddiff'));
    x_xv2_spline2dcalcvbuf := Tspline2dcalcvbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dcalcvbuf'));
    x_xv2_spline2dcalcvi := Tspline2dcalcvi(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dcalcvi'));
    x_xv2_spline2dcalcv := Tspline2dcalcv(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dcalcv'));
    x_xv2_spline2ddiffvi := Tspline2ddiffvi(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2ddiffvi'));
    x_xv2_spline2dlintransxy := Tspline2dlintransxy(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dlintransxy'));
    x_xv2_spline2dlintransf := Tspline2dlintransf(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dlintransf'));
    x_xv2_spline2dcopy := Tspline2dcopy(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dcopy'));
    x_xv2_spline2dresamplebicubic := Tspline2dresamplebicubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dresamplebicubic'));
    x_xv2_spline2dresamplebilinear := Tspline2dresamplebilinear(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dresamplebilinear'));
    x_xv2_spline2dbuildbilinearv := Tspline2dbuildbilinearv(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildbilinearv'));
    x_xv2_spline2dbuildbicubicv := Tspline2dbuildbicubicv(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildbicubicv'));
    x_xv2_spline2dunpackv := Tspline2dunpackv(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dunpackv'));
    x_xv2_spline2dbuildbilinear := Tspline2dbuildbilinear(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildbilinear'));
    x_xv2_spline2dbuildbicubic := Tspline2dbuildbicubic(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildbicubic'));
    x_xv2_spline2dunpack := Tspline2dunpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dunpack'));
    x_xv2_spline2dbuildercreate := Tspline2dbuildercreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildercreate'));
    x_xv2_spline2dbuildersetuserterm := Tspline2dbuildersetuserterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetuserterm'));
    x_xv2_spline2dbuildersetlinterm := Tspline2dbuildersetlinterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetlinterm'));
    x_xv2_spline2dbuildersetconstterm := Tspline2dbuildersetconstterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetconstterm'));
    x_xv2_spline2dbuildersetzeroterm := Tspline2dbuildersetzeroterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetzeroterm'));
    x_xv2_spline2dbuildersetpoints := Tspline2dbuildersetpoints(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetpoints'));
    x_xv2_spline2dbuildersetareaauto := Tspline2dbuildersetareaauto(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetareaauto'));
    x_xv2_spline2dbuildersetarea := Tspline2dbuildersetarea(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetarea'));
    x_xv2_spline2dbuildersetgrid := Tspline2dbuildersetgrid(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetgrid'));
    x_xv2_spline2dbuildersetalgofastddm := Tspline2dbuildersetalgofastddm(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetalgofastddm'));
    x_xv2_spline2dbuildersetalgoblocklls := Tspline2dbuildersetalgoblocklls(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetalgoblocklls'));
    x_xv2_spline2dbuildersetalgonaivells := Tspline2dbuildersetalgonaivells(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dbuildersetalgonaivells'));
    x_xv2_spline2dfit := Tspline2dfit(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline2dfit'));
    x_obj_copy_rbfcalcbuffer := Tx_obj_copy_rbfcalcbuffer(XGetProcAddress(_lib_alglib, 'x_obj_copy_rbfcalcbuffer'));
    x_obj_free_rbfcalcbuffer := Tx_obj_free_rbfcalcbuffer(XGetProcAddress(_lib_alglib, 'x_obj_free_rbfcalcbuffer'));
    x_obj_copy_rbfmodel := Tx_obj_copy_rbfmodel(XGetProcAddress(_lib_alglib, 'x_obj_copy_rbfmodel'));
    x_obj_free_rbfmodel := Tx_obj_free_rbfmodel(XGetProcAddress(_lib_alglib, 'x_obj_free_rbfmodel'));
    x_rbfserialize := Trbfserialize(  XGetProcAddress(_lib_alglib, 'alglib_rbfserialize'));
    x_rbfunserialize := Trbfunserialize(XGetProcAddress(_lib_alglib, 'alglib_rbfunserialize'));
    x_rbfserialize_stream := Trbfserialize_stream(  XGetProcAddress(_lib_alglib, 'alglib_rbfserialize_stream'));
    x_rbfunserialize_stream := Trbfunserialize_stream(XGetProcAddress(_lib_alglib, 'alglib_rbfunserialize_stream'));
    x_xv2_rbfcreate := Trbfcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfcreate'));
    x_xv2_rbfcreatecalcbuffer := Trbfcreatecalcbuffer(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfcreatecalcbuffer'));
    x_xv2_rbfsetpoints := Trbfsetpoints(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetpoints'));
    x_xv2_rbfsetpointsandscales := Trbfsetpointsandscales(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetpointsandscales'));
    x_xv2_rbfsetalgoqnn := Trbfsetalgoqnn(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetalgoqnn'));
    x_xv2_rbfsetalgomultilayer := Trbfsetalgomultilayer(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetalgomultilayer'));
    x_xv2_rbfsetalgohierarchical := Trbfsetalgohierarchical(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetalgohierarchical'));
    x_xv2_rbfsetlinterm := Trbfsetlinterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetlinterm'));
    x_xv2_rbfsetconstterm := Trbfsetconstterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetconstterm'));
    x_xv2_rbfsetzeroterm := Trbfsetzeroterm(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetzeroterm'));
    x_xv2_rbfsetv2bf := Trbfsetv2bf(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetv2bf'));
    x_xv2_rbfsetv2its := Trbfsetv2its(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetv2its'));
    x_xv2_rbfsetv2supportr := Trbfsetv2supportr(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfsetv2supportr'));
    x_xv2_rbfbuildmodel := Trbfbuildmodel(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfbuildmodel'));
    x_xv2_rbfcalc1 := Trbfcalc1(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfcalc1'));
    x_xv2_rbfcalc2 := Trbfcalc2(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfcalc2'));
    x_xv2_rbfcalc3 := Trbfcalc3(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfcalc3'));
    x_xv2_rbfcalc := Trbfcalc(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfcalc'));
    x_xv2_rbfcalcbuf := Trbfcalcbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfcalcbuf'));
    x_xv2_rbftscalcbuf := Trbftscalcbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbftscalcbuf'));
    x_xv2_rbfgridcalc2 := Trbfgridcalc2(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfgridcalc2'));
    x_xv2_rbfgridcalc2v := Trbfgridcalc2v(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfgridcalc2v'));
    x_xv2_rbfgridcalc2vsubset := Trbfgridcalc2vsubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfgridcalc2vsubset'));
    x_xv2_rbfgridcalc3v := Trbfgridcalc3v(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfgridcalc3v'));
    x_xv2_rbfgridcalc3vsubset := Trbfgridcalc3vsubset(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfgridcalc3vsubset'));
    x_xv2_rbfunpack := Trbfunpack(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfunpack'));
    x_xv2_rbfgetmodelversion := Trbfgetmodelversion(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfgetmodelversion'));
    x_xv2_rbfpeekprogress := Trbfpeekprogress(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfpeekprogress'));
    x_xv2_rbfrequesttermination := Trbfrequesttermination(XGetProcAddress(_lib_alglib, 'alglib_xv2_rbfrequesttermination'));
    x_xv2_nsfitspheremcc := Tnsfitspheremcc(XGetProcAddress(_lib_alglib, 'alglib_xv2_nsfitspheremcc'));
    x_xv2_nsfitspheremic := Tnsfitspheremic(XGetProcAddress(_lib_alglib, 'alglib_xv2_nsfitspheremic'));
    x_xv2_nsfitspheremzc := Tnsfitspheremzc(XGetProcAddress(_lib_alglib, 'alglib_xv2_nsfitspheremzc'));
    x_xv2_nsfitspherex := Tnsfitspherex(XGetProcAddress(_lib_alglib, 'alglib_xv2_nsfitspherex'));
    x_xv2_spline1dfitpenalized := Tspline1dfitpenalized(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dfitpenalized'));
    x_xv2_spline1dfitpenalizedw := Tspline1dfitpenalizedw(XGetProcAddress(_lib_alglib, 'alglib_xv2_spline1dfitpenalizedw'));
    x_xv2_ellipticintegralk := Tellipticintegralk(XGetProcAddress(_lib_alglib, 'alglib_xv2_ellipticintegralk'));
    x_xv2_ellipticintegralkhighprecision := Tellipticintegralkhighprecision(XGetProcAddress(_lib_alglib, 'alglib_xv2_ellipticintegralkhighprecision'));
    x_xv2_incompleteellipticintegralk := Tincompleteellipticintegralk(XGetProcAddress(_lib_alglib, 'alglib_xv2_incompleteellipticintegralk'));
    x_xv2_ellipticintegrale := Tellipticintegrale(XGetProcAddress(_lib_alglib, 'alglib_xv2_ellipticintegrale'));
    x_xv2_incompleteellipticintegrale := Tincompleteellipticintegrale(XGetProcAddress(_lib_alglib, 'alglib_xv2_incompleteellipticintegrale'));
    x_xv2_hermitecalculate := Thermitecalculate(XGetProcAddress(_lib_alglib, 'alglib_xv2_hermitecalculate'));
    x_xv2_hermitesum := Thermitesum(XGetProcAddress(_lib_alglib, 'alglib_xv2_hermitesum'));
    x_xv2_hermitecoefficients := Thermitecoefficients(XGetProcAddress(_lib_alglib, 'alglib_xv2_hermitecoefficients'));
    x_xv2_dawsonintegral := Tdawsonintegral(XGetProcAddress(_lib_alglib, 'alglib_xv2_dawsonintegral'));
    x_xv2_sinecosineintegrals := Tsinecosineintegrals(XGetProcAddress(_lib_alglib, 'alglib_xv2_sinecosineintegrals'));
    x_xv2_hyperbolicsinecosineintegrals := Thyperbolicsinecosineintegrals(XGetProcAddress(_lib_alglib, 'alglib_xv2_hyperbolicsinecosineintegrals'));
    x_xv2_poissondistribution := Tpoissondistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_poissondistribution'));
    x_xv2_poissoncdistribution := Tpoissoncdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_poissoncdistribution'));
    x_xv2_invpoissondistribution := Tinvpoissondistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_invpoissondistribution'));
    x_xv2_besselj0 := Tbesselj0(XGetProcAddress(_lib_alglib, 'alglib_xv2_besselj0'));
    x_xv2_besselj1 := Tbesselj1(XGetProcAddress(_lib_alglib, 'alglib_xv2_besselj1'));
    x_xv2_besseljn := Tbesseljn(XGetProcAddress(_lib_alglib, 'alglib_xv2_besseljn'));
    x_xv2_bessely0 := Tbessely0(XGetProcAddress(_lib_alglib, 'alglib_xv2_bessely0'));
    x_xv2_bessely1 := Tbessely1(XGetProcAddress(_lib_alglib, 'alglib_xv2_bessely1'));
    x_xv2_besselyn := Tbesselyn(XGetProcAddress(_lib_alglib, 'alglib_xv2_besselyn'));
    x_xv2_besseli0 := Tbesseli0(XGetProcAddress(_lib_alglib, 'alglib_xv2_besseli0'));
    x_xv2_besseli1 := Tbesseli1(XGetProcAddress(_lib_alglib, 'alglib_xv2_besseli1'));
    x_xv2_besselk0 := Tbesselk0(XGetProcAddress(_lib_alglib, 'alglib_xv2_besselk0'));
    x_xv2_besselk1 := Tbesselk1(XGetProcAddress(_lib_alglib, 'alglib_xv2_besselk1'));
    x_xv2_besselkn := Tbesselkn(XGetProcAddress(_lib_alglib, 'alglib_xv2_besselkn'));
    x_xv2_incompletebeta := Tincompletebeta(XGetProcAddress(_lib_alglib, 'alglib_xv2_incompletebeta'));
    x_xv2_invincompletebeta := Tinvincompletebeta(XGetProcAddress(_lib_alglib, 'alglib_xv2_invincompletebeta'));
    x_xv2_fdistribution := Tfdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_fdistribution'));
    x_xv2_fcdistribution := Tfcdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_fcdistribution'));
    x_xv2_invfdistribution := Tinvfdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_invfdistribution'));
    x_xv2_fresnelintegral := Tfresnelintegral(XGetProcAddress(_lib_alglib, 'alglib_xv2_fresnelintegral'));
    x_xv2_jacobianellipticfunctions := Tjacobianellipticfunctions(XGetProcAddress(_lib_alglib, 'alglib_xv2_jacobianellipticfunctions'));
    x_xv2_psi := Tpsi(XGetProcAddress(_lib_alglib, 'alglib_xv2_psi'));
    x_xv2_exponentialintegralei := Texponentialintegralei(XGetProcAddress(_lib_alglib, 'alglib_xv2_exponentialintegralei'));
    x_xv2_exponentialintegralen := Texponentialintegralen(XGetProcAddress(_lib_alglib, 'alglib_xv2_exponentialintegralen'));
    x_xv2_laguerrecalculate := Tlaguerrecalculate(XGetProcAddress(_lib_alglib, 'alglib_xv2_laguerrecalculate'));
    x_xv2_laguerresum := Tlaguerresum(XGetProcAddress(_lib_alglib, 'alglib_xv2_laguerresum'));
    x_xv2_laguerrecoefficients := Tlaguerrecoefficients(XGetProcAddress(_lib_alglib, 'alglib_xv2_laguerrecoefficients'));
    x_xv2_chisquaredistribution := Tchisquaredistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_chisquaredistribution'));
    x_xv2_chisquarecdistribution := Tchisquarecdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_chisquarecdistribution'));
    x_xv2_invchisquaredistribution := Tinvchisquaredistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_invchisquaredistribution'));
    x_xv2_legendrecalculate := Tlegendrecalculate(XGetProcAddress(_lib_alglib, 'alglib_xv2_legendrecalculate'));
    x_xv2_legendresum := Tlegendresum(XGetProcAddress(_lib_alglib, 'alglib_xv2_legendresum'));
    x_xv2_legendrecoefficients := Tlegendrecoefficients(XGetProcAddress(_lib_alglib, 'alglib_xv2_legendrecoefficients'));
    x_xv2_beta := Tbeta(XGetProcAddress(_lib_alglib, 'alglib_xv2_beta'));
    x_xv2_chebyshevcalculate := Tchebyshevcalculate(XGetProcAddress(_lib_alglib, 'alglib_xv2_chebyshevcalculate'));
    x_xv2_chebyshevsum := Tchebyshevsum(XGetProcAddress(_lib_alglib, 'alglib_xv2_chebyshevsum'));
    x_xv2_chebyshevcoefficients := Tchebyshevcoefficients(XGetProcAddress(_lib_alglib, 'alglib_xv2_chebyshevcoefficients'));
    x_xv2_fromchebyshev := Tfromchebyshev(XGetProcAddress(_lib_alglib, 'alglib_xv2_fromchebyshev'));
    x_xv2_studenttdistribution := Tstudenttdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_studenttdistribution'));
    x_xv2_invstudenttdistribution := Tinvstudenttdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_invstudenttdistribution'));
    x_xv2_binomialdistribution := Tbinomialdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_binomialdistribution'));
    x_xv2_binomialcdistribution := Tbinomialcdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_binomialcdistribution'));
    x_xv2_invbinomialdistribution := Tinvbinomialdistribution(XGetProcAddress(_lib_alglib, 'alglib_xv2_invbinomialdistribution'));
    x_xv2_airy := Tairy(XGetProcAddress(_lib_alglib, 'alglib_xv2_airy'));
    x_xv2_wilcoxonsignedranktest := Twilcoxonsignedranktest(XGetProcAddress(_lib_alglib, 'alglib_xv2_wilcoxonsignedranktest'));
    x_xv2_onesamplesigntest := Tonesamplesigntest(XGetProcAddress(_lib_alglib, 'alglib_xv2_onesamplesigntest'));
    x_xv2_pearsoncorrelationsignificance := Tpearsoncorrelationsignificance(XGetProcAddress(_lib_alglib, 'alglib_xv2_pearsoncorrelationsignificance'));
    x_xv2_spearmanrankcorrelationsignificance := Tspearmanrankcorrelationsignificance(XGetProcAddress(_lib_alglib, 'alglib_xv2_spearmanrankcorrelationsignificance'));
    x_xv2_studentttest1 := Tstudentttest1(XGetProcAddress(_lib_alglib, 'alglib_xv2_studentttest1'));
    x_xv2_studentttest2 := Tstudentttest2(XGetProcAddress(_lib_alglib, 'alglib_xv2_studentttest2'));
    x_xv2_unequalvariancettest := Tunequalvariancettest(XGetProcAddress(_lib_alglib, 'alglib_xv2_unequalvariancettest'));
    x_xv2_mannwhitneyutest := Tmannwhitneyutest(XGetProcAddress(_lib_alglib, 'alglib_xv2_mannwhitneyutest'));
    x_xv2_jarqueberatest := Tjarqueberatest(XGetProcAddress(_lib_alglib, 'alglib_xv2_jarqueberatest'));
    x_xv2_ftest := Tftest(XGetProcAddress(_lib_alglib, 'alglib_xv2_ftest'));
    x_xv2_onesamplevariancetest := Tonesamplevariancetest(XGetProcAddress(_lib_alglib, 'alglib_xv2_onesamplevariancetest'));
    x_xv2_rmatrixschur := Trmatrixschur(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixschur'));
    x_xv2_smatrixgevd := Tsmatrixgevd(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixgevd'));
    x_xv2_smatrixgevdreduce := Tsmatrixgevdreduce(XGetProcAddress(_lib_alglib, 'alglib_xv2_smatrixgevdreduce'));
    x_xv2_rmatrixinvupdatesimple := Trmatrixinvupdatesimple(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixinvupdatesimple'));
    x_xv2_rmatrixinvupdaterow := Trmatrixinvupdaterow(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixinvupdaterow'));
    x_xv2_rmatrixinvupdatecolumn := Trmatrixinvupdatecolumn(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixinvupdatecolumn'));
    x_xv2_rmatrixinvupdateuv := Trmatrixinvupdateuv(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixinvupdateuv'));
    x_xv2_rmatrixludet := Trmatrixludet(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixludet'));
    x_xv2_rmatrixdet := Trmatrixdet(XGetProcAddress(_lib_alglib, 'alglib_xv2_rmatrixdet'));
    x_xv2_cmatrixludet := Tcmatrixludet(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixludet'));
    x_xv2_cmatrixdet := Tcmatrixdet(XGetProcAddress(_lib_alglib, 'alglib_xv2_cmatrixdet'));
    x_xv2_spdmatrixcholeskydet := Tspdmatrixcholeskydet(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixcholeskydet'));
    x_xv2_spdmatrixdet := Tspdmatrixdet(XGetProcAddress(_lib_alglib, 'alglib_xv2_spdmatrixdet'));
    x_xv2_polynomialsolve := Tpolynomialsolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_polynomialsolve'));
    x_obj_copy_nleqstate := Tx_obj_copy_nleqstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_nleqstate'));
    x_obj_free_nleqstate := Tx_obj_free_nleqstate(XGetProcAddress(_lib_alglib, 'x_obj_free_nleqstate'));
    x_nleqstate_get_needf := Tx_nleqstate_get_needf(XGetProcAddress(_lib_alglib, 'x_nleqstate_get_needf'));
    Touch(x_nleqstate_get_needf); // avoid messages about unused variables
    x_nleqstate_set_needf := Tx_nleqstate_set_needf(XGetProcAddress(_lib_alglib, 'x_nleqstate_set_needf'));
    Touch(x_nleqstate_set_needf);
    x_nleqstate_get_needfij := Tx_nleqstate_get_needfij(XGetProcAddress(_lib_alglib, 'x_nleqstate_get_needfij'));
    Touch(x_nleqstate_get_needfij); // avoid messages about unused variables
    x_nleqstate_set_needfij := Tx_nleqstate_set_needfij(XGetProcAddress(_lib_alglib, 'x_nleqstate_set_needfij'));
    Touch(x_nleqstate_set_needfij);
    x_nleqstate_get_xupdated := Tx_nleqstate_get_xupdated(XGetProcAddress(_lib_alglib, 'x_nleqstate_get_xupdated'));
    Touch(x_nleqstate_get_xupdated); // avoid messages about unused variables
    x_nleqstate_set_xupdated := Tx_nleqstate_set_xupdated(XGetProcAddress(_lib_alglib, 'x_nleqstate_set_xupdated'));
    Touch(x_nleqstate_set_xupdated);
    x_nleqstate_get_f := Tx_nleqstate_get_f(XGetProcAddress(_lib_alglib, 'x_nleqstate_get_f'));
    Touch(x_nleqstate_get_f); // avoid messages about unused variables
    x_nleqstate_set_f := Tx_nleqstate_set_f(XGetProcAddress(_lib_alglib, 'x_nleqstate_set_f'));
    Touch(x_nleqstate_set_f);
    x_nleqstate_get_fi := Tx_nleqstate_get_fi(XGetProcAddress(_lib_alglib, 'x_nleqstate_get_fi'));
    Touch(x_nleqstate_get_fi); // avoid messages about unused variables
    x_nleqstate_get_j := Tx_nleqstate_get_j(XGetProcAddress(_lib_alglib, 'x_nleqstate_get_j'));
    Touch(x_nleqstate_get_j); // avoid messages about unused variables
    x_nleqstate_get_x := Tx_nleqstate_get_x(XGetProcAddress(_lib_alglib, 'x_nleqstate_get_x'));
    Touch(x_nleqstate_get_x); // avoid messages about unused variables
    x_xv2_nleqcreatelm := Tnleqcreatelm(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqcreatelm'));
    x_xv2_nleqsetcond := Tnleqsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqsetcond'));
    x_xv2_nleqsetxrep := Tnleqsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqsetxrep'));
    x_xv2_nleqsetstpmax := Tnleqsetstpmax(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqsetstpmax'));
    x_xv2_nleqiteration := Tnleqiteration(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqiteration'));
    x_xv2_nleqresults := Tnleqresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqresults'));
    x_xv2_nleqresultsbuf := Tnleqresultsbuf(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqresultsbuf'));
    x_xv2_nleqrestartfrom := Tnleqrestartfrom(XGetProcAddress(_lib_alglib, 'alglib_xv2_nleqrestartfrom'));
    x_xv2_sparsesolvesks := Tsparsesolvesks(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsesolvesks'));
    x_xv2_sparsecholeskysolvesks := Tsparsecholeskysolvesks(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsecholeskysolvesks'));
    x_xv2_sparsesolve := Tsparsesolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparsesolve'));
    x_xv2_sparselusolve := Tsparselusolve(XGetProcAddress(_lib_alglib, 'alglib_xv2_sparselusolve'));
    x_obj_copy_lincgstate := Tx_obj_copy_lincgstate(XGetProcAddress(_lib_alglib, 'x_obj_copy_lincgstate'));
    x_obj_free_lincgstate := Tx_obj_free_lincgstate(XGetProcAddress(_lib_alglib, 'x_obj_free_lincgstate'));
    x_xv2_lincgcreate := Tlincgcreate(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgcreate'));
    x_xv2_lincgsetstartingpoint := Tlincgsetstartingpoint(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsetstartingpoint'));
    x_xv2_lincgsetprecunit := Tlincgsetprecunit(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsetprecunit'));
    x_xv2_lincgsetprecdiag := Tlincgsetprecdiag(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsetprecdiag'));
    x_xv2_lincgsetcond := Tlincgsetcond(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsetcond'));
    x_xv2_lincgsolvesparse := Tlincgsolvesparse(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsolvesparse'));
    x_xv2_lincgresults := Tlincgresults(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgresults'));
    x_xv2_lincgsetrestartfreq := Tlincgsetrestartfreq(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsetrestartfreq'));
    x_xv2_lincgsetrupdatefreq := Tlincgsetrupdatefreq(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsetrupdatefreq'));
    x_xv2_lincgsetxrep := Tlincgsetxrep(XGetProcAddress(_lib_alglib, 'alglib_xv2_lincgsetxrep'));

end.


